.\" Automatically generated by Pod::Man version 1.15
.\" Fri Apr 20 13:10:08 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "Math::BigInt 3"
.TH Math::BigInt 3 "perl v5.6.1" "2001-02-23" "Perl Programmers Reference Guide"
.UC
.SH "NAME"
Math::BigInt \- Arbitrary size integer math package
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Math::BigInt;
\&  $i = Math::BigInt->new($string);
.Ve
.Vb 16
\&  $i->bneg return BINT               negation
\&  $i->babs return BINT               absolute value
\&  $i->bcmp(BINT) return CODE         compare numbers (undef,<0,=0,>0)
\&  $i->badd(BINT) return BINT         addition
\&  $i->bsub(BINT) return BINT         subtraction
\&  $i->bmul(BINT) return BINT         multiplication
\&  $i->bdiv(BINT) return (BINT,BINT)  division (quo,rem) just quo if scalar
\&  $i->bmod(BINT) return BINT         modulus
\&  $i->bgcd(BINT) return BINT         greatest common divisor
\&  $i->bnorm return BINT              normalization
\&  $i->blsft(BINT) return BINT        left shift
\&  $i->brsft(BINT) return (BINT,BINT) right shift (quo,rem) just quo if scalar
\&  $i->band(BINT) return BINT         bit-wise and
\&  $i->bior(BINT) return BINT         bit-wise inclusive or
\&  $i->bxor(BINT) return BINT         bit-wise exclusive or
\&  $i->bnot return BINT               bit-wise not
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
All basic math operations are overloaded if you declare your big
integers as
.PP
.Vb 1
\&  $i = new Math::BigInt '123 456 789 123 456 789';
.Ve
.Ip "Canonical notation" 2
.IX Item "Canonical notation"
Big integer value are strings of the form \f(CW\*(C`/^[+\-]\ed+$/\*(C'\fR with leading
zeros suppressed.
.Ip "Input" 2
.IX Item "Input"
Input values to these routines may be strings of the form
\&\f(CW\*(C`/^\es*[+\-]?[\ed\es]+$/\*(C'\fR.
.Ip "Output" 2
.IX Item "Output"
Output values always always in canonical form
.PP
Actual math is done in an internal format consisting of an array
whose first element is the sign (/^[+\-]$/) and whose remaining 
elements are base 100000 digits with the least significant digit first.
The string 'NaN' is used to represent the result when input arguments 
are not numbers, as well as the result of dividing by zero.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 3
\&   '+0'                            canonical zero value
\&   '   -123 123 123'               canonical value '-123123123'
\&   '1 23 456 7890'                 canonical value '+1234567890'
.Ve
.SH "Autocreating constants"
.IX Header "Autocreating constants"
After \f(CW\*(C`use Math::BigInt ':constant'\*(C'\fR all the integer decimal constants
in the given scope are converted to \f(CW\*(C`Math::BigInt\*(C'\fR.  This conversion
happens at compile time.
.PP
In particular
.PP
.Vb 1
\&  perl -MMath::BigInt=:constant -e 'print 2**100'
.Ve
print the integer value of \f(CW\*(C`2**100\*(C'\fR.  Note that without conversion of 
constants the expression 2**100 will be calculated as floating point number.
.SH "BUGS"
.IX Header "BUGS"
The current version of this module is a preliminary version of the
real thing that is currently (as of perl5.002) under development.
.SH "AUTHOR"
.IX Header "AUTHOR"
Mark Biggar, overloaded interface by Ilya Zakharevich.
