.\" Automatically generated by Pod::Man version 1.15
.\" Mon Apr 23 12:33:49 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "Bulkmail 3"
.TH Bulkmail 3 "perl v5.6.1" "2000-10-03" "User Contributed Perl Documentation"
.UC
.SH "NAME"
Mail::Bulkmail 2.05 \- Platform independent mailing list module
.SH "AUTHOR"
.IX Header "AUTHOR"
Jim Thomason thomasoniii@yahoo.com
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\& $bulk = Mail::Bulkmail->new(
\&           "LIST" => "/home/jim3.list",
\&           "From" => 'thomasoniii@yahoo.com',
\&        "Subject" => 'This is a test message!',
\&        "Message" => "Here is the text of my message!"
\& );
.Ve
.Vb 1
\& $bulk->bulkmail;
.Ve
Be sure to set your default variables in the module, or set them
in each bulk mail object.  Otherwise, you'll be using the defaults.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Mail::Bulkmail gives a fairly complete set of tools for managing
mass-mailing lists.  I wrote it because our existing tools were just
too damn slow for mailing out to thousands of recipients.
.PP
2.00 is a major major \fBmajor\fR upgrade to the previous version (1.11).
I literally threw out all of the code from 1.00 and started over.  Well,
almost all of it, I'm really content with the email validation, so I kept
that.  :)
.PP
Everything else is brand spanking new.  All of the bugs from the 1.x releases should
be gone (ever try allowing duplicates?  Good.).  And, of course, a bunch of new toys
have been added in.
.PP
The two major additions to v2 are the ability to send via envelope and support for dynamic
messaging.  Sending via the envelope allows you to potentially transfer your email \fImuch\fR
faster (I've been estimating a 900% speed increase vs. non-envelope sending in 1.11).  Dynamic
messaging allows you to actually construct the message that you're sending out on the fly.
Specify which components of a message you want to include, and Bulkmail will generate the message
for you.  So every person on your list could potentially receive a different message, if you wanted.
.PP
Dynamic messaging is a few steps above a simple mail merge.  While you could accomplish the same
effect using a simple mail merge it wouldn't be pretty.  You'd have to duplicate each component
of the message for each person on the list.
.PP
Further changes are listed in the version history and \s-1FAQ\s0 sections below, I just wanted to mention
the big guns up front.
.SH "REQUIRES"
.IX Header "REQUIRES"
Perl5.004, Socket
.SH "OBJECT METHODS"
.IX Header "OBJECT METHODS"
.Sh "\s-1CREATION\s0"
.IX Subsection "CREATION"
New Mail::Bulkmail objects are created with the \fInew()\fR constructor.  For a minimalist 
creation, do this:
.PP
$bulk = Mail::Bulkmail->\fInew()\fR;
.PP
You can also initialize values at creation time, such as:
.PP
.Vb 4
\& $bulk = Mail::Bulkmail->new(
\&            From => 'thomasoniii@yahoo.com',
\&            Smtp => 'some.smtp.com'
\& );
.Ve
When Bulkmail objects are destroyed, they automatically disconnect from the server they're connected to
if they're still connected.
.Ip "add_attr"
.IX Item "add_attr"
Mail::Bulkmail is much easier to subclass now (I hope).  I like using arrays for my objects instead of hashes.
Perhaps one day I'll switch to pseudo-hashes, but not yet.
.PP
Until that time, you need to allocate new space in the array for your new attributes if you want to subclass
the thing.  But how do you do that nicely?  Push onto the blessed arrayref?  Too messy, and you can't do the
nice trick of setting up a variable with the value of the place in the array.  Besides, if I do switch away from
arrays this'll break.  So use add_attr to tack it onto the end of the object.
.PP
package Mail::Bulkmail::My_version;
.PP
@ISA = qw(Mail::Bulkmail);
.PP
.Vb 1
\& my $new_attribute = Mail::Bulkmail->add_attr();
.Ve
.Vb 1
\& $my_bulk_object->[$new_attribute] = "my value";
.Ve
.Sh "\s-1BUILT\s0 \s-1IN\s0 \s-1ACCESSORS\s0"
.IX Subsection "BUILT IN ACCESSORS"
Okay, here's where the fun stuff beings.  Since these are objects, the important stuff is how
you access your data.
.PP
Object methods work as you probably expect.
.PP
$bulk->property
.PP
.Vb 1
\&  Will return the value of "property" in $bulk
.Ve
$bulk->property(\*(L"new value\*(R")
.PP
Will set the value of \*(L"property\*(R" in \f(CW$bulk\fR to \*(L"new value\*(R" and return \*(L"new value\*(R".
The property may not be set if \f(CW$bulk\fR->Trusting has a false value and the property has a
validation check on it.  See Validated Accessors, below.
.PP
All accessor methods are case sensitive.  Be careful!
.PP
Here are all of the accessors that come built in to your Mail::Bulkmail objects.
.Ip "From" 11
.IX Item "From"
The e-mail address this list is coming from.  This can be either a simple e-mail address 
(thomasoniii@yahoo.com), or a name + e-mail address (\*(L"Jim Thomason\*(R"<thomasoniii@yahoo.com>).  This is checked
to make sure it's a valid email address unless you have Trusting turned on (see below).
.Sp
\&\fIv1.x equivalent\fR:  From 
.Ip "Subject" 11
.IX Item "Subject"
The subject of the e-mail message.  If it's not set, you'll use the default.
.Sp
\&\fIv1.x equivalent\fR:  Subject
.Ip "Message" 11
.IX Item "Message"
This is the actual text that will appear in the message body.  You can also specify control fields
to allow your message to be dynamically individually built on the fly, as well as do a mail merge
to personalize your email to each recipient
.Sp
\&\fIv1.x equivalent\fR:  Message
.Ip "merge" 11
.IX Item "merge"
This is where you define a mail merge for your message.  See the section \s-1MERGING\s0 below.
.Sp
A merge is defined with a hashref as follows:
.Sp
.Vb 4
\& $bulk->merge(
\&    "Date"    => "June 22nd",
\&    "Company" => "Foofram Industries"
\& );
.Ve
\&\fIv1.x equivalent\fR:  Map
.Ip "Smtp" 11
.IX Item "Smtp"
This sets the \s-1SMTP\s0 server that you're going to connect to.  You'll probably just want to
use whatever you've set as your default \s-1SMTP\s0 server in the module.  You did set your default \s-1SMTP\s0 
server when you double-checked all the other defaults, right?
.Sp
\&\fIv1.x equivalent\fR:  Smtp
.Ip "Port" 11
.IX Item "Port"
This sets the port on which to connect to your \s-1SMTP\s0 server.  You'll probably just want to use
25 (the default).
.Sp
\&\fIv1.x equivalent\fR:  Port
.Ip "Tries" 11
.IX Item "Tries"
This sets the number of times that you will attempt to connect to a server.  You'll probably
just want to use the default.
.Sp
\&\fIv1.x equivalent\fR:  Tries
.Ip "Precedence" 11
.IX Item "Precedence"
This sets the precedence of the e-mail message.  This is validated unless you turn off
validation by making your object Trusting.  Default precedence is \*(L"list\*(R", although you can
set a precedence of either \*(L"bulk\*(R" (bulk, usually unsolicited mail) or \*(L"junk\*(R" (totally worthless
message)
.Sp
\&\fIv1.x equivalent\fR:  Precedence
.Ip "Domain" 11
.IX Item "Domain"
You're going to be saying \s-1HELO\s0 to an \s-1SMTP\s0 server, you'd better be willing to give it a domain
as well.  You can explicitly set the Domain here, or choose not to.  If no Domain is set, the domain
of the From e-mail address will be used instead.  It doesn't do you any good to set Domain after
you've connected to a server.
.Sp
\&\fIv1.x equivalent\fR:  Domain
.Ip "\s-1HTML\s0" 11
.IX Item "HTML"
People can be dopes.  It's very very easy to send out mass \s-1HTML\s0 email with Mail::Bulkmail, just set
a content-type:
.Sp
.Vb 1
\& $bulk->header("Content-type", "text/html");
.Ve
But most people don't seem to know that, so I've added the \s-1HTML\s0 accessor.  Give it true value to send
out \s-1HTML\s0 mail, a false value to send out plaintext.  It's false by default.
.Ip "use_envelope" 11
.IX Item "use_envelope"
use_envelope is like lasing a stick of dynamite.  Mail::Bulkmail is fast.  Mail::Bulkmail with use_envelope
is ungodly incredibly unbelievably fast.
.Sp
For the uninformed, an email message contains two parts, the message itself and the envelope.   Mail servers only
care about the envelope (for the most part), since that's where they find out who the message is to and from, and
they don't really need to know anything else.
.Sp
A nifty feature of the envelope is that you can submit multiple addresses within the envelope, and then your
mail server will automagically send along the message to everyone contained within the envelope.  You end up
sending a hell of a lot less data across your connection, your \s-1SMTP\s0 server has less work to do, and everything
ends up working out wonderfully.
.Sp
There are two catches.  First of all, with envelope sending turned off, the recipient will have their own email
address in the \*(L"To\*(R" field (To: thomasoniii@yahoo.com, fer instance).  With the envelope on, the recipient will only
receive a generic email address (\*(L"To: list@myserver.com\*(R", fer instance)  Most people don't care since that's
how most email lists work, but you should be aware of it.
.Sp
Secondly, you \fB\s-1MUST\s0\fR and I mean \fB\s-1MUST\s0\fR sort your list by domain.  Envelopes can only be bundled up by domain,
so that we send all email to a domain in one burst, all of the email to another domain in the next burst, and so
on.  So you need to have all of your domains clustered together in your list.  If you don't, your list will still
go out, but it will be a \fIlot\fR slower, since Mail::Bulkmail has a fair amount more processing to do when you send
with then envelope.  This is normally more than offset by the gains received from sending fewer messages.  But with
an unsorted list, you never see the big gains and you see a major slow down.  Sort your lists. 
.Ip "envelope_limit" 11
.IX Item "envelope_limit"
It's entirely likely that with a very large list you'll have a very large number of people in the
same domain.  For instance, there are an awful lot of people that have yahoo addresses.  So, for example,
say that you have a list of 100,000 people and 20,000 of them are in the foobar.com domain and you're sending
using the envelope.  That means that the server at foobar.com is going to receive one message with 20,000
people in the envelope!
.Sp
Now, this might be a bad thing.  We don't know if the foobar.com mail server will actually process a message
with 20,000 envelope recipients.  It may or may not and the only way to find out is to try it.  If it does work,
then great no worries, but if it doesn't, then you're stuck.  If you stop using envelope sending, you sacrifice
its major speed gains, but if you keep using it you can't send to foobar.com.
.Sp
\&\fIenvelope_limit\fR fixes that.
.Sp
envelope_limit is precisely what it sounds like, it allows you to specify a limit on the number of recipients
that will be specified in your envelope.  That way, with our previous example, you can specify an envelope limit of
1000, for example.
.Sp
.Vb 1
\& $bulk->envelope_limit(1000);
.Ve
This means that foobar.com will get 20 messages, each with 1000 recipients in the envelope.  Of course, this still
may not be small enough, so you can tweak it as much as necessary.
.Sp
Setting an envelope limit does trade off some of the gains from using the envelope, but it's still over all
a vast speed boost over not using it.
.Sp
envelope_limit is set to 0 (zero) by default, meaning that there is no limit specified. 
.Ip "\s-1LIST\s0" 11
.IX Item "LIST"
\&\s-1IO\s0 is a lot smarter in v2.0.  In Bulkmail 1.x, the various \s-1IO\s0 methods (\s-1LIST\s0, \s-1BAD\s0, etc.) had to be
globs to file handles, which was rather restrictive.
.Sp
In 2.0, you have four options for how you want to import your list, a string, or a reference to either
an array, a glob, or a function.
.Sp
If you have a flat text file, you can use it by simply passing a string containing the path to the file:
.Sp
.Vb 1
\& $bulk->LIST("/home/jim3/list.txt");
.Ve
And Bulkmail will open the file and manage it internally, so you don't need to worry about polluting
your namespace with filehandles the way you did with 1.x.
.Sp
Of course, if you \fIwant\fR to pollute your namespace, then feel free to.
.Sp
.Vb 2
\& open (LIST, "/home/jim3/list.txt");
\& $bulk->LIST(\e*LIST);
.Ve
Just note that you now have to pass a reference to the glob, \fInot\fR the glob itself as you did in 1.x.
.Sp
Flat file lists will read in one entry per line, where a line is determined by whatever value you've
set with \fIlineterm()\fR.
.Sp
Alternatively, you can pass a ref to an array for your list.
.Sp
my \f(CW@list\fR = ('thomasoniii@yahoo.com', 'someguy@somewhere.com', 'invalid_@address');
.Sp
$bulk->LIST(\e@list);
.Sp
#or, with an anonymous array
.Sp
$bulk->LIST(['thomasoniii@yahoo.com', 'someguy@somewhere.com', 'invalid_@address']);
.Sp
You probably don't want to use arrays for your lists unless you're doing small tests.  Otherwise, you'll
read your whole list into memory in advance, which is probably not what you wanted to do.
.Sp
Arrays as lists will return the values in order from the front to the end of the array.
.Sp
Probably the most powerful method to build your list is to pass a ref to a function.
.Sp
.Vb 2
\& {
\&  my @list = ('thomasoniii@yahoo.com', 'someguy@somewhere.com', 'invalid_@address');
.Ve
.Vb 2
\&  sub some_function {return shift @list};
\& };
.Ve
.Vb 1
\& $bulk->LIST(\e&some_function);
.Ve
Of course, in this case it's wasteful to actually pass a function reference instead of just an array ref
to \f(CW@list\fR, but it serves as a good example.
.Sp
By passing function refs around, you can extract your list directly from a database if you want.
.Sp
.Vb 3
\& my $dbh = DBI->connect();
\& my $sth = $dbh->prepare("SELECT name, email FROM MAIL_LIST");
\& $sth->execute;
.Ve
.Vb 1
\& sub mail_list {return $sth->fetch_row_array};
.Ve
.Vb 1
\& $bulk->LIST(\e&mail_list);
.Ve
No more having to export your list to a flat file first.
.Sp
You can't just pass a ref to \f(CW$sth\fR->fetch_row_array because it doesn't work that way.  \e&{$sth->fetchrow_array}
returns a coderef to a hash containing the return value, which ain't what you want.  &$sth...doesn't work and
so on.  If anyone *does* know a way to do it directly, please do let me know.  :)
.Sp
The values are returned in whatever order your function returns them in.  Be sure to return undef when you're
done, otherwise Bulkmail won't know when you've finished.
.Sp
Each of these methods returns \*(L"lines\*(R" of entries in your mailing list.  So what the hell's a line?  An email
address?  A delimited string?  A code ref?  Actually, it's anything you want.  :)  See the section on \s-1MERGING\s0
below.
.Sp
\&\fIv1.x equivalent\fR:  \s-1LIST\s0
.Ip "\s-1BAD\s0" 11
.IX Item "BAD"
This is an optional item which specifies a place to log bad addresses (invalid, banned, etc.).  Just like \s-1LIST\s0
above, in v1.x it had to be a glob to a file handle, but not so any more!
.Sp
You have the same four options that you did for list, a string, a ref to a glob, a ref to a function, and a ref
to an array.
.Sp
The string will cause a file to be opened for appending (\*(L">>\*(R").  The ref to a glob is a file that you already
have open for appending (or simply for writing).
.Sp
If you pass a ref to an array, any items will be pushed onto the array as they're encountered.
.Sp
If you pass a ref to a function, then the function will be called with a single argument of whatever it is
that was going to be logged.
.Sp
For example, if \*(L".thomasoniii@yahoo.com\*(R" is encountered (a bad address!), any of the following would end up happening,
depending upon what \*(L"\s-1BAD\s0\*(R" is:
.Sp
.Vb 3
\& print BAD ".jim3@ psynet.net", $bulk->lineterm(); #BAD is a file
\& push @BAD, ".jim3@ psynet.net";                   #BAD is an array
\& &BAD(".jim3@ psynet.net");                        #BAD is a function
.Ve
\&\fIv1.x equivalent\fR:  \s-1BAD\s0
.Ip "\s-1GOOD\s0" 11
.IX Item "GOOD"
This is an optional item which specifies a place to log good addresses (anything not invalid or banned).  That
way, you'll have a list at the end of all of your good addresses with the bad ones weeded out.
.Sp
There is one issue with the \s-1GOOD\s0 list, when using the envelope.  You're not guaranteed that everything
in the good list actually went through, unlike when not using the envelope.  When not using the envelope,
a message is logged as being good as soon as it's completely transmitted to the server.  When using the envelope,
however, a message is logged as being good as soon as the attempt is made to transmit it to the server.  As long
as the message is accepted and delivered, everything is fine.  But if the message isn't accepted (if you specified
too many people in the envelope, for instance), you'll log everyone else in the envelope as being good
even though they weren't actually sent to.
.Sp
This is a terribly irritating bug to me, but I haven't thought of a clever way to handle it perfectly without
caching those recipients elsewhere, which I'd rather not do since it's messy.  Ho hum.  Let me know if you
have a clever solution.
.Sp
You have the same options as with \s-1BAD\s0, above.
.Sp
\&\fIv1.x equivalent\fR:  \s-1GOOD\s0
.Ip "\s-1ERRFILE\s0" 11
.IX Item "ERRFILE"
This is an optional item which specifies a place to log any and all errors that occur while running.  It is recommended
that you run with this option on, so it's easier to see if anything bad is happening.
.Sp
\&\fIv1.x equivalent\fR:  \s-1ERROR\s0
.Ip "log_full_line" 11
.IX Item "log_full_line"
It occurred to me that log_it was only logging the email address of a person.  So if you encounter
a bad address of, say 'thomasoniii@yahoo', it will log 'thomasoniii@yahoo'.  No problems, right?  But
what if you're using a mailmerge?  Then things can get tricky.  If your line is, for example, 
.Sp
.Vb 2
\& #BULK_MAILMERGE is BULK_EMAIL::NAME::TITLE
\& thomasoniii@yahoo::Jim::Perl Bulkmail Guru
.Ve
you would only log (in the bad file):
.Sp
.Vb 1
\& thomasoniii@yahoo
.Ve
This may or may not be what you want.  As of v2.04, you have the option of choosing to log the full
\&\*(L"line\*(R" of information.  With log_full_line set to true, this would be in the \s-1BAD\s0 file:
.Sp
.Vb 1
\& thomasoniii@yahoo.com::Jim::Perl Bulkmail Guru
.Ve
Which may come in handy for you, or it may not.  But you at least have the option of doing it.  Why did
I add this feature?  I was running a list that was extracting information via a \s-1SQL\s0 query and pulling
out several pieces of information.  After the message was sent, I neede to perform another query to update
that information in the table.  Easily done by setting \s-1GOOD\s0 to a function reference, but that \s-1GOOD\s0 was only
receiving the email address back from bulkmail, not the full line of info.  That meant that I had to cache
the other data in a seperate hash table and then come back to it later.  Most inelegent. This is much better.  :)
.Sp
There are a couple of \*(L"gotchas\*(R" when it comes to log_full_line that I haven't quite ironed out to my
satisfaction yet.  If you have ideas about better ways to handle them, please let me know.
.Sp
First of all, remember that when logging a full line, you get back exactly what you put in as your \*(L"line\*(R"
(recalling that \*(L"lines\*(R" can be strings, hashes, arrays, codes, etc.)  So if your \*(L"line\*(R" of information is
an array (ref), then you'll log that array ref.  Mail::Bulkmail tries to guess about a smart way to log
the item if it's logging to a text file.  Arrays will be de-referenced and delimited by whatever \->\s-1BMD\s0 is.
Hashes will be squashed into their values and delimited by \->\s-1BMD\s0.  The keys won't be stored.  Any other reference
will give you an error, and then happily log the reference which is probably useless.  Delimited strings
are logged unchanged.
.Sp
But this guessing at de-referencing is only done for files.  If you're logging to a function or an 
array, you're expected to know how to de-reference it yourself.  It'll just be a minor code tweak, don't worry.
Just be sure to remember it.
.Sp
log_full_line is set to false by default, but I may set it to true by default in a long-in-the-future release
(think v2.5 or higher). 
.Sp
\&\fINo v1.x equivalent\fR
.Ip "banned" 11
.IX Item "banned"
\&\fIbanned\fR will allows you to provide a list of banned email addresses or domains.  These are people that
you never \fBever\fR want to send email to under any circumstances.  People that email you and say \*(L"Remove me
from your mailing list and never email me again!\*(R" will go in this category.
.Sp
A banned list can be built the same way as \s-1GOOD\s0, \s-1BAD\s0, \s-1LIST\s0, etc., with an array, a filehandle, a function, or
a string containing a filename.  Banned entries are one per line.
.Sp
.Vb 2
\& thomasoniii@yahoo.com
\& yahoo.com
.Ve
would ban email from thomasoniii@yahoo.com, and anyone within the yahoo.com domain.  Please note that domains will only
be banned upwards, not downwards.  So with an entry like this:
.Sp
.Vb 2
\& yahoo.com
\& mail.msn.com
.Ve
your list will be blocked from going to yahoo.com, and mail.msn.com.  It will also be blocked from mail.yahoo.com
(contains yahoo.com), but not from webserver.msn.com (webserver.msn.com does not contain mail.msn.com).
.Sp
You can also construct a banned list using a hashref, though it must be precisely constructed or you'll shoot
yourself in the foot bigtime.  Fortunately, the format is simple.
.Sp
.Vb 1
\& $banned{lowercase email address} = email address.
.Ve
Mail::Bulkmail needs its banned information in this format to function correctly.  Consequently, if you give
it a non-hashref value (array, glob, etc.) it will construct this hash internally.  So if you have a large
number of banned addresses, you'll probably want to put them in a dbm file and hand in a ref to it, so as not
to store everything in memory.
.Sp
Why the funky hash format?  One of the screwball, \s-1IMHO\s0, things about the email specification is that the domain
part of an email address is case insensitive, but the local part is case sensitive.  This means that 
.Sp
.Vb 3
\& thomasoniii@yahoo.com
\& ThomasonIII@yahoo.com
\& tHOMaSoNIii@yahoo.com
.Ve
all could be different addresses.  So, in theory, you could have those three addresses in your mailing list and
they're three different people!  Consequently, we need to keep track of exactly how the email address was typed
or we may lose some information.
.Sp
Yeah, I know it's arguably being silly to do this, since I've never (\fIever\fR) encountered an email server that
allowed multiple differently-cased email addresses like this, but dammit I want to have the option in here
to deal with it!  :\-)
.Sp
\&'course, people could very well subscribe to your list using \*(L"thomasonIII@yahoo.com\*(R" and then try to unsubscribe
using \*(L"thomasoniii@yahoo.com\*(R" and mess things up royally.  That's why we have the safe_banned method.
\&\fISee safe_banned, below\fR
.Sp
\&\fIv1.x equivalent\fR:  \s-1BANNED\s0
.Ip "safe_banned" 11
.IX Item "safe_banned"
safe_banned is set to true by default.  safe_banned makes your matches on addresses case insensitive.
So that a request to ban \*(L"thomasoniii@yahoo.com\*(R" will also ban \*(L"ThomasonIII@yahoo.com\*(R", and \*(L"thomASONIii@yahoo.com\*(R".  You
almost definitely want to leave this on, for safety's sake, but you can turn it off if you'd like.
.Sp
\&\fISee banned above\fR
.Ip "allow_duplicates" 11
.IX Item "allow_duplicates"
allow_duplicates is off by default.  Setting allow_duplicates to 1 will allow people with multiple
entries in your mailing list to receive multiple copies of the message.  Otherwise, they will
only receive one copy of the message.  Duplicate addresses are printed out to \s-1ERRFILE\s0, if you specified
\&\s-1ERRFILE\s0 and you didn't turn allow_duplicates on.
.Sp
allow_duplicates respects safe_banned.  So if safe_banned is false, it will do local-part case-insensitive
matching for duplicates, otherwise it will do local-part case-sensitive matching.
.Ip "Tz" 11
.IX Item "Tz"
This returns the current timezone.
.Sp
\&\fIv1.x equivalent\fR:  _def_Tz
.Ip "Date" 11
.IX Item "Date"
This returns the current date in \s-1RFC\s0 1123 format.
.Sp
\&\fIv1.x equivalent\fR:  _def_Date
.Ip "header" 11
.IX Item "header"
\&\fIheader()\fR is actually a method that pretends to be an accessor.  See \s-1ADDTIONAL\s0 \s-1ACCESSORS\s0, below.
.Sp
\&\fIv1.x equivalent\fR:  headset
.Ip "\s-1HFM\s0" 11
.IX Item "HFM"
\&\s-1HFM\s0 (Headers From Message) will extract any valid headers from the message body.  A valid header is
of the form \*(L"Name:value\*(R", one per line with an empty line seperating the headers from the message.
.Sp
It is \fBmuch\fR better to explicitly set the headers using the header method because it's a tougher 
to make mistakes using header.  Nonetheless, setting \s-1HFM\s0 to any true value will cause the module to
look in the message for headers.  Any valid headers extracted from the message will override existing 
headers.  Dynamically generated headers will override extracted headers, however.  
Headers extracted from the message will be removed from the message body.
.Sp
But be perfectly sure you know what you're doing.
.Sp
.Vb 1
\&    $bulk->HFM(1);
.Ve
.Vb 5
\&    $bulk->Message(
\&        "This is my message.  I'm going to try sending it out to everyone that I know.
\&        Messages are cool, e-mailing software is neat, and everyone will love me for it.
\&        Oh happy day, happy happy day.
\&        Love,
.Ve
.Vb 1
\&        Jim";
.Ve
Before v2.03, since \s-1HFM\s0 is set to true, the first four lines are extracted from the message and sent as headers.
The extent of the message that goes through is \*(L"Jim\*(R" (everything after the first blank line which separates
headers from message body).
.Sp
After v2.03, this will generate an error since \s-1HFM\s0 now makes sure that the headers are formed properly.  It
still doesn't verify its headers, though, so you still need to be careful.  Maybe in the next release...
.Sp
Prior to v2.03, \s-1HFM\s0 would unwrap wrapped headers.  Since 2.04, \s-1HFM\s0 passes any wrapped headers through unchanged.
.Sp
\&\s-1HFM\s0 is off by default.
.Sp
\&\fIv1.x equivalent\fR:  \s-1HFM\s0
.Ip "\s-1BMD\s0" 11
.IX Item "BMD"
\&\s-1BMD\s0 (bulkmail delimiter) tells the module what delimiter to use in the file when using BULK_MAILMERGEs
(see below)
.Sp
\&\fBImportant: \s-1BMD\s0 \f(BImust\fB be different than \s-1DMD\s0 and \s-1DHD\s0\fR
.Sp
\&\s-1BMD\s0 is \*(L"::\*(R" by default.
.Sp
\&\fIv1.x equivalent\fR:  \s-1BMD\s0
.Ip "\s-1DMD\s0" 11
.IX Item "DMD"
\&\s-1DMD\s0 (dynamic mail delimiter) tells the module what delimiter to use in the file when using dynamic messages
(see below)
.Sp
\&\s-1DMD\s0 is \*(L",\*(R" by default.
.Ip "\s-1DMDE\s0" 11
.IX Item "DMDE"
\&\s-1DMDE\s0 (Dynamic Mail delimeter for Equal) tells the module what delimiter to use in the 
file when using for equalities in dynamic messages
(see below)
.Sp
\&\s-1DMDE\s0 is \*(L"=\*(R" by default.
.Ip "\s-1DHD\s0" 11
.IX Item "DHD"
\&\s-1DHD\s0 (dynamic header delimiter) tells the module what delimiter to use in the file when using dynamic headers
(see below)
.Sp
\&\s-1DHD\s0 is \*(L",\*(R" by default.
.Ip "\s-1DHDE\s0" 11
.IX Item "DHDE"
\&\s-1DHDE\s0 (Dynamic Header delimeter for Equal) tells the module what delimiter to use in the 
file when using for equalities in dynamic headers
(see below)
.Sp
\&\s-1DHDE\s0 is \*(L"=\*(R" by default.
.Ip "lineterm" 11
.IX Item "lineterm"
lineterm is nifty.  It allows you to set the ending line character in your files.  So if you have
a file with email addresses that is inexplicably delimited with \*(L"<!X!>\*(R", then simply set lineterm to 
\&\*(L"<!X!>\*(R" and off you go.  No need to convert your files before hand.
.Sp
lineterm is \*(L"\en\*(R" by default.
.Ip "Trusting" 11
.IX Item "Trusting"
\&\fITrusting()\fR lets you decide to turn off error checking.  By default, Mail::Bulkmail will only allow you
to use valid e-mail addresses (well, kinda see the valid_email method for comments), valid dates, valid
timezones, and valid precedences.  Trusting is off by default.  Turn it on by setting it to some non-zero value.
This will bypass \fBall\fR error checking.  You should probabaly just leave it off so you can check for valid e-mails,
dates, etc.  But you have the option, at least.
.Sp
\&\fIv1.x equivalent\fR:  No_errors
.Sh "\s-1ADDITIONAL\s0 \s-1ACCESSORS\s0"
.IX Subsection "ADDITIONAL ACCESSORS"
You're perfectly welcome to access any additional data that you'd like.  We're gonna assume that you're accessing
or setting a header other than the standard ones that are provided.  You even get a special method to access them:
\&\fIheader()\fR.  Using it is a piece of cake:
.PP
$bulk->header('Reply-to', 'thomasoniii@yahoo.com');
.PP
Will set a \*(L"Reply-to\*(R" header to the value of \*(L"thomasoniii@yahoo.com\*(R".  Want to access it?
.PP
$bulk->header('Reply-to');
.PP
What's that you ask?  Why don't we set *all* headers this way?  Well, truth be told you can set them using header.
.PP
$bulk->header('From', 'thomasoniii@yahoo.com');
.PP
Is the same as:
.PP
$bulk->From('thomasoniii@yahoo.com');
.PP
Note that you can only set other _headers_ this way.  The headers that have their own methods are From, Subject, and
Precedence.  Calling header on something else, though (like \*(L"Smtp\*(R") will set a header with that value, which is probably
not what you want to do (a \*(L"Smtp: your.server.com\*(R" header is reeeeeal useful).  I'd recommend just using the provided
From, Subject, and Precedence headers.  That's what they're there for.
.PP
What's that?  Why the hell can't you just say \f(CW$bulk\fR->my_header('some value')?  It's because you may want to have a header
with a non-word character in it (like \*(L"Reply-to\*(R"), and methods with non-word characters are a Perl no-no.  So since it's
not possible for me to check every damn header to see if it has a non-word character in it (things get stripped and messed
up and the original value is lost), you'll just have to use header to set or access additional headers.
.PP
\&\s-1OR\s0\*(--You can just set your headers at object construction.  Realistically, you're going to be setting all of your headers
at construction time, so this is not a problem.  Just remember to quote those things with non-word characters in them.
.PP
.Vb 5
\& $bulk->Mail::Bulkmail->new(
\&        From        => 'thomasoniii@yahoo.com',
\&        Subject     => 'Some mass message',
\&        'Reply-to'  => 'thomasoniii@yahoo.com'
\&    );
.Ve
If you don't quote headers with non-word characters, all sorts of nasty errors may pop up.  And they're tough to track down.
So don't do it.  You've been warned.
.PP
As of v2.03, \->\fIheader()\fR without a specific header name will return a hashref containing all additional headers that have been set.
.PP
\&\fIAlso see dynamic headers below\fR
.Sh "\s-1VALIDATED\s0 \s-1ACCESSORS\s0"
.IX Subsection "VALIDATED ACCESSORS"
The properties that have validation checks are \*(L"From\*(R", \*(L"To\*(R", \*(L"Domain\*(R", and \*(L"Precedence\*(R" to try
to keep you from making mistakes.  The only one that should really ever concern you is perhaps \*(L"From\*(R"
.Ip "From" 11
.IX Item "From"
This checks the return e-mail address against \s-1RFC\s0 822 standards.
The validation routine is not perfect as it's really really hard to be perfect, but
it should accept any valid non-group e-mail address.
There is one bug in the routine that will allow \*(L"Jim<thomasoniii@yahoo.com\*(R" to pass as valid,
but it's a nuisance to fix so I'm not going to.  :\-)
.Sp
\&\fIv1.x equivalent\fR:  From
.Ip "To" 11
.IX Item "To"
This checks the to e-mail address against \s-1RFC\s0 822 standards.
The validation routine is not perfect as it's really really hard to be perfect, but
it should accept any valid non-group e-mail address.
There is one bug in the routine that will allow \*(L"Jim<thomasoniii@yahoo.com\*(R" to pass as valid,
but it's a nuisance to fix so I'm not going to.  :\-)
.Sp
The \->To address is used when you are sending to a list using the envelope.
\&\fISee use_envelope, above\fR
.Ip "Domain" 11
.IX Item "Domain"
Domain sets which domain you'll use to say \s-1HELO\s0 to your \s-1SMTP\s0 server.  If no domain is
specified, you'll just use the domain part of your From address.  You probably won't need
to set this ever.
.Ip "Precedence" 11
.IX Item "Precedence"
We are doing bulkmail here, so the precedence should always be \*(L"list\*(R", \*(L"bulk\*(R",
or \*(L"junk\*(R" and nothing else.  We might as well be polite and not make our servers
think that we're sending out 60,000 first-class or special-delivery messages.
You probably don't want to fiddle with this.
.Sp
\&\fIv1.x equivalent\fR:  Precedence
.Sp
If you don't want to do any validation checks, then set Trusting equal to 1 (see Trusting, below).
That will bypass all validation checks and allow you to insert \*(L"Garbonzo\*(R" as your date if you desire.
It's recommended that you leave error checking on.  It's pretty good.  And you have more important things
to worry about.
.Sh "Methods"
.IX Subsection "Methods"
There are several methods you are allowed to invoke upon your bulkmail object.
.RS 11
.Ip "bulkmail (?local merge?)" 10
.IX Item "bulkmail (?local merge?)"
This method is where the magic is.  This method starts up your mailing, sending 
your message to every person specified in \s-1LIST\s0.  bulkmail returns nothing.  
bulkmail merely loops through everything in your \s-1LIST\s0 file and calls mail on each entry.
.Sp
bulkmail is a hell of a lot more complex then it used to be.  It used to just pass each address
off to the mail method, so it was essentially just a big for loop.
.Sp
Now it's gotta do condition checking, verifications, and 4 or 5 method calls instead of one.
Obviously, those 4\-5 method calls are going to slow down your list processing, so that's bad.
How much it'll slow down I'm not really sure.  I shouldn't be much...10% I'm guessing.  Maybe.
.Sp
So why the hell did I complicate this up and make it slower, you ask?  It needs the extra tricks
to enable envelope sending.  Envelope sending will typically provide you with a performance increase
of somewhere around 400%, I'm estimating.  The little slowdown from the method calls seemed unimportant.
.Sp
bulkmail can be handed a local merge hash.  \fISee merging, below\fR
.Sp
Returns 1 on success, undef on failure.
.Ip "mail (line ?local merge?)" 10
.IX Item "mail (line ?local merge?)"
mail is much much dumber than it used to be.  Give it a line (as in whatever a line would look like
if extracted from your list) and an optional local merge, and it will email that one person.  You can
now very easily accomplish the exact same thing by setting \s-1LIST\s0 to an array with one item and using
bulkmail, but I figured I'd keep mail around for the heck of it so everyone easily knows that you
can email just one person.
.Sp
There may be better modules for emailing to just one person, though.
.Sp
Returns 1 on success, undef on failure.
.Ip "connect (no arguments)" 10
.IX Item "connect (no arguments)"
This method connects to your \s-1SMTP\s0 server.  It is called by the internal build_envelope method.
You can explicitly call it yourself, if you'd like.  That way you can verify that you can connect
to your server in advance, and do something if you can't, I suppose.
.Sp
Returns 1 on success, undef on failure.
.Ip "disconnect (no arguments)" 10
.IX Item "disconnect (no arguments)"
This method disconnects from your \s-1SMTP\s0 server.  It is called at object destruction, or
explicitly if you wish to disconnect earlier.  You should never need to call this method.  Returns
nothing.
.Ip "error (no arguments)" 10
.IX Item "error (no arguments)"
error is where the last error message is kept.  Can be used as follows:
.Sp
$bulk->connect || die \f(CW$bulk\fR->error;
.Sp
All \fBobject\fR error messages will be logged if you specifed an \s-1ERRFILE\s0 file.  Class errors will \fBnot\fR
be logged internally, you'll have to do that yourself.
.Sp
error is also usable as a class method:
.Sp
Mail::Bulkmail->\fIerror()\fR;
.Sp
will return whatever the last global class-wide error is, such as an object construction failure.
In fact, currently that's the only error it catches.  But you can now easily do:
.Sp
.Vb 3
\& my $bulk = Mail::Bulkmail->new(
\&    "From" => 'thomasoniiI@yaho'     #invalid address!
\& ) or die Mail::Bulkmail->error();
.Ve
to find out why construction failed.
.RE
.RS 11
.SH "MERGING"
.IX Header "MERGING"
Finally, the mysterious merging section so often alluded to.
.Sp
Mail merging is exactly the same as \*(L"file mapping\*(R" was in v1.x.  I just didn't realize until long after
I released it that \*(L"file map\*(R" was stupid and that \*(L"mail merge\*(R" is the correct term.  I'm finally correcting
that error.  If you understood mapping in v1.x, you'll understand merging now.  :\-)
.Sp
You are sending out bulk e-mail to any number of people, but perhaps you would like to personalize
the message to some degree.  That's where merging comes in handy.  You are able to define a merge
to replace certain characters (control strings) in an e-mail message with certain other characters
(values).
.Sp
Now in v2.0 you can go one step further and use dynamic messages, which actually allows you to construct
your message on the fly, instead of just inserting values.  \fISee dynamic messages, below\fR
.Sp
Merges can be global so that all control strings in all messages will be replaced with the same value
or local so that control strings are replaced with different values depending upon the recipient.
.Sp
Merges are declared at object constrution or by using the merge accessor.  merge values are either
anonymous hashes or references to hashes.  For example:
.Sp
At constrution:
.Sp
.Vb 7
\&    $bulk = Mail::Bulkmail->new(
\&                "From"    => "thomasoniii@yahoo.com",
\&                "merge"   => {
\&                                'DATE'    => 'today',
\&                                'company' => 'Thomason Industries'
\&                             }
\&            );
.Ve
Or using the accessor:
.Sp
.Vb 1
\&    $bulk->merge({'DATE' => 'yesterday'});
.Ve
Global merges are not terribly useful beyond setting generic values, such as today's date within a message
template or the name of your company.  Local merges are much more helpful since they allow values to be set 
individually in each message.  Local merges can be declared either in a call to the mail method or by using 
the \s-1BULK_MAILMERGE\s0 key.  Local merges are declared with the same keyword (merge) as global merges.
.Sp
As a call to mail:
.Sp
.Vb 7
\&    $bulk->mail(
\&            'thomasoniii@yahoo.com',
\&            {
\&              'ID'   => '36373',
\&              'NAME' => 'Jim Thomason',
\&            }
\&    );
.Ve
Using \s-1BULK_MAILMERGE\s0
.Sp
.Vb 1
\&    $bulk->merge({'BULK_MAILMERGE'=>'BULK_EMAIL::ID::NAME'});
.Ve
Be careful with your control strings to make sure that you don't accidentally replace text in the message
that you didn't mean to.  Control strings are case sensitive, so that \*(L"name\*(R" in a message from the 
above example would not be replaced by \*(L"Jim Thomason\*(R" but \*(L"\s-1NAME\s0\*(R" would be.
.Sp
\&\fB\s-1NOTE:\s0\fR I would \fIhighly\fR recommend against having \*(L"\s-1BULK_\s0\*(R" or \*(L"\s-1DYNAMIC_\s0\*(R" in any of your keys (except \s-1BULK_EMAIL\s0, of course).  
BULK_* keys are used internally by Mail::Bulkmail for keeping track of things that it needs to keep track of.
\&\s-1BULK_MAILMERGE\s0, \s-1BULK_EMAIL\s0, \s-1DYNAMIC_MESSAGE\s0, and \s-1DYNAMIC_HEADERS\s0 are examples of internal keys.  \s-1BULK_LINE\s0 is also hanging around inside, but you
never see it, now do you?  But you never know what keys I may need to add internally at a later date.  I will
\&\fIalways\fR prepend those keys with '\s-1BULK_\s0' or '\s-1DYNAMIC_\s0', so you be sure to \fInever\fR prepend your keys with '\s-1BULK_\s0' or '\s-1DYNAMIC_\s0' 
and we'll all get along just fine.
.Sp
\&\s-1BULK_MAILMERGE\s0 will be explained more below.
.Sh "\s-1BULK_MAILMERGE\s0"
.IX Subsection "BULK_MAILMERGE"
First of all, \s-1BULK_MAILMERGE\s0 is \fBnot\fR compatible with use_envelope.  Use one or the other, but not both.
It'll yell at you if you do.
.Sp
Earlier we learned that \s-1LIST\s0 files may be in two main formats, either a single e-mail address per line,
or an email address and several values per \*(L"line\*(R", either delimited in a line of a file, or stored in
an array or a hash or a function or whatever. 
.Sp
Delimited lists _must_ be used in conjunction with a \s-1BULK_MAILMERGE\s0 parameter to merge.  \s-1BULK_MAILMERGE\s0
allows you to specify that each e-mail message will have unique values inserted for control strings
without having to loop through the address list yourself and specify a new local merge for every message.
\&\s-1BULK_MAILMERGE\s0 may only be set in a global map, its presence is ignored in local merges.
.Sp
.Vb 10
\& If your list file is this:
\&   thomasoniii@yahoo.com::36373::Jim Thomason
\&   or
\&   ["thomasoniii@yahoo.com", "36373", "Jim Thomason"]
\&   or
\&   {
\&       "BULK_EMAIL" => "thomasoniii@yahoo.com,
\&       "ID"         => "36373",
\&       "NAME"         => "Jim Thomason"
\&   }
.Ve
You can have a corresponding merge as any one of the following:
.Sp
.Vb 3
\& $bulk->merge({
\&         'BULK_MAILMERGE'=>'BULK_EMAIL::ID::NAME'
\&         });
.Ve
.Vb 3
\& $bulk->merge({
\&         'BULK_MAILMERGE'=>["BULK_EMAIL", "ID", "NAME"]
\&         });
.Ve
.Vb 7
\& $bulk->merge({
\&         'BULK_MAILMERGE'=>
\&             {"BULK_EMAIL" => undef,
\&              "ID" => undef,
\&              "NAME" => undef
\&             }
\&         });
.Ve
This \s-1BULK_MAILMERGE\s0 will operate the same way that the local merge above operated.  \*(L"\s-1BULK_EMAIL\s0\*(R" is the
only required item, it is case sensitive.  This is where in your delimited line the e-mail
address of the recipient is.  \*(L"\s-1BULK_EMAIL\s0\*(R" _is_ used as a control string in your message.  Be careful.
So if you want to include someone's e-mail address within the text of your message, put the string
\&\*(L"\s-1BULK_EMAIL\s0\*(R" in your message body wherever you'd like to insert it.
.Sp
Everything else may be anything you'd like, these are the control
strings that will be substituted for the values at that location in the line in the file.
You may use global merges, BULK_MAILMERGEs and local merges simultaneously.
.Sp
BULK_MAILMERGEs are declared as delimited by the \s-1BMD\s0 method (or \*(L"::\*(R" by default), the data in the actual file
is also delimited by the \s-1BMD\s0 method.  The default delimiter is \*(L"::\*(R", but as of version 1.10, 
you may use \s-1BMD\s0 to choose any arbitrary delimiter in the file.
.Sp
For example:
.Sp
.Vb 1
\&    $bulk->BMD("-+-");
.Ve
.Vb 1
\&    $bulk->merge({'BULK_MAILMERGE'=>'BULK_EMAIL-+-ID-+-NAME'});
.Ve
.Vb 3
\&    (in your list file)
\&    thomasoniii@yahoo.com-+-ID #1-+-Jim Thomason
\&    thomasoniii@yahoo.com-+-ID #2-+-Jim Thomason
.Ve
If you have set \s-1LIST\s0 to a function, or array, you can have each line return in an array or a hash.  Obviously,
if \s-1LIST\s0 is a file, then every line has to be a delimited string as listed above.
.Sp
But with arrays or functions, you don't have to return a delimited string.  You can return your entry in an
array or in a hash.  An array is listed in the same order as the \s-1BULK_MAILMERGE\s0, and operates the same way.
It's just a little cleaner and quicker since we skip the split step.
.Sp
The hash method is a little slower since it's a hash, and it also takes up a little more memory since you're
returning more values.
.Sp
You'll almost never want to use the hash method, since the array one is preferrable.  I'm debating whether
or not to expand that hash returning approach to allow you to dynamically construct mail merges on the fly
for each individual item.  What do you think about that idea?
.Sh "merge precedence"
.IX Subsection "merge precedence"
local merge values will override global merge values.  \s-1BULK_MAILMERGE\s0 merge values will override anything else.
Evaluation of merge control strings is 
.Sp
.Vb 1
\& BULK_MAILMERGE value -> local value -> global value
.Ve
where the first value found is the one that is used.
.SH "DYNAMIC MESSAGES"
.IX Header "DYNAMIC MESSAGES"
Dynamic messages rock.  :)
.Sp
We had a dotcom company come in one day to try to sell us on their email solution for our mailing lists.  I calmly
sat there, listened to their presentation, and jotted down notes about anything they said that I thought would be
good to incorporate into Mail::Bulkmail.  The best thing that they had was dynamic messages.
.Sp
Dynamic messages are mail merges taken to the next level. A mail merge allows you to insert simple piece of information
into your message, the person's name or phone number or something for personalization purposes.  But it's not a good
idea to do much beyond that because it gets messy to try to maintain it across your list and keep consistency across everything.
A global mail merge is better, but not great.
.Sp
Enter dynamic messages.
.Sp
Dynamic messages allow you to actually construct your message on the fly based upon preferences specified by the user.
.Sp
Say you've got a mailing list on animals, and you want to maintain one list to send out to the people who like bears,
rabbits, and iguanas.  One list is easier to maintain than three, and conceptually they all like animals, so it makes
sense.  Besides, some people may want info on bears and rabbits and wouldn't it be nice to send them one email instead
of two?
.Sp
Dynamic messages must be used in conjunction with \s-1BULK_MAILMERGE\s0, since we're building them based upon the preferences
of the individual recipient.  Use the \s-1DYNAMIC_MESSAGE\s0 keyword in your \s-1BULK_MAILMERGE:\s0
.Sp
.Vb 1
\& "BULK_MAILMERGE" => "BULK_EMAIL::Name::ID::DYNAMIC_MESSAGE"
.Ve
and then your email entry would be:
.Sp
.Vb 1
\& thomasoniii@yahoo.com::Jim Thomason::36373::Bears=yes,Rabbits=no,Iguanas=headlines
.Ve
To specify that I want info on bears, no info on rabbits, and just headlines on iguanas.
.Sp
Then you use the \->dynamic method to declare your hash of hashes.
.Sp
.Vb 18
\& $bulk->dynamic(
\&    "Bears" => {
\&        "yes" => "I see you like bears.  Bears are cuddly and we like them too!",
\&        "black" => "Here is your update on the black bear...",
\&        "polar" => "here is your update on the polar bear...",
\&        "no" => ""
\&    },
\&    "Rabbits" => {
\&        "yes" => "I see that you like rabbits.  Rabbits are cool."
\&        "cottontail" => "Here is information on the cotton tail rabbit..."
\&        "no" => ""
\&    },
\&    "Iguanas" => {
\&        "yes" =" Here is info on iguanas",
\&        "no" => ""
\&        "headlines" => "Here are important iguana stories"
\&    }
\& );
.Ve
or at object creation:
.Sp
.Vb 25
\& my $bulk = Mail::Bulkmail->new(
\&     "message" => "
\&     Bears
\&     Rabbits
\&     Iguanas",
\&     "dynamic" =>
\&     {
\&         "Bears" => {
\&            "yes" => "I see you like bears.  Bears are cuddly and we like them too!",
\&            "black" => "Here is your update on the black bear...",
\&            "polar" => "here is your update on the polar bear...",
\&            "no" => ""
\&        },
\&        "Rabbits" => {
\&            "yes" => "I see that you like rabbits.  Rabbits are cool."
\&            "cottontail" => "Here is information on the cotton tail rabbit..."
\&            "no" => ""
\&        },
\&        "Iguanas" => {
\&            "yes" =" Here is info on iguanas",
\&            "no" => ""
\&            "headlines" => "Here are important iguana stories"
\&        }
\&    }
\& );
.Ve
Which will create this message:
.Sp
.Vb 2
\& I see you like bears.  Bears are cuddly and we like them too!
\& Here are important iguana stories
.Ve
It operates the same way as a mail merge, substituting the key word for whatever keyword value is listed
in the \s-1DYNAMIC_MESSAGE\s0 item.
.Sp
Dynamic messages execute before mail merges, so you can mail merge a dynamic message as well!
.Sp
\&\s-1BULK_MAILMERGE\s0 = \*(L"\s-1BULK_EMAIL::NAME::DYNAMIC_MESSAGE\s0\*(R";
.Sp
.Vb 6
\& $bulk->dynamic(
\&    "Bears" => {
\&        "personal" => "I see you like bears, NAME",
\&        "impersonal" => "I see you like bears, whoever you are"
\&    }
\& );
.Ve
.Vb 1
\& thomasoniii@yahoo.com::Jim Thomason::Bears=personal
.Ve
would send:
.Sp
I see you like bears, Jim Thomason.
.Sp
So you can send truly dynamic, personalized messages.
.SH "DYNAMIC HEADERS"
.IX Header "DYNAMIC HEADERS"
Well, I'm kinda spent after the huge lecture on dynamic messages above, so I'll be briefer.
.Sp
Dynamic headers operate exactly the same way, except with headers instead of message components.  So you can send
individual people individual subjects, for instance.
.Sp
use \s-1DYNAMIC_HEADERS\s0 in a \s-1BULK_MAILMERGE:\s0
.Sp
\&\s-1BULK_MAILMERGE\s0 = \*(L"\s-1BULK_EMAIL::DYNAMIC_HEADERS\s0\*(R";
.Sp
Use the dynamic_headers method:
.Sp
.Vb 7
\& $bulk->dynamic_headers(
\&    "Subject" => {
\&        "Special offer" => "A special offer for valued customers",
\&        "First time" => "Thanks for your first order!",
\&        "No order" => "We miss your business!"
\&    }
\& );
.Ve
or at object construction:
.Sp
.Vb 9
\& my $bulk = Mail::Bulkmail->new(
\&    "dynamic_headers" =>{
\&        "Subject" => {
\&            "Special offer" => "A special offer for valued customers",
\&            "First time" => "Thanks for your first order!",
\&            "No order" => "We miss your business!"
\&        }
\&    }
\&);
.Ve
So that
.Sp
thomasoniii@yahoo.com::Subject=Special offer
.Sp
Will send out your email message to thomasoniii@yahoo.com with 
\&\*(L"A special offer for valued customers\*(R" as the subject.
.Sp
Again, you can use a mail merge into a dynamic header, if you'd like.  So you can insert a personalized header
\&\s-1ID\s0, for instance.
.SH "CLASS VARIABLES"
.IX Header "CLASS VARIABLES"
(well, \fItechnically\fR they aren't class variables, since they're lexically scoped, but the gist is the same)
.Sp
.Vb 12
\& my $def_From              = 'Postmaster';
\& my $def_To                = 'postmaster@your.smtp.com';
\& my $def_Smtp              = 'your.smtp.com';       #<--Set this variable.  Important!
\& my $def_Domain            = "smtp.com";
\& my $def_Port              = '25';
\& my $def_Tries             = '5';
\& my $def_Subject           = "(no subject)";
\& my $def_Precedence        = "list";                #list, bulk, or junk
\& my $def_Trusting          = 0;
\& my $def_log_line          = 0;
\& my $def_envelope_limit    = 0;
\& my $def_allow_duplicates  = 0;
.Ve
.Vb 5
\& my $def_BMD               = "::";
\& my $def_DHD               = ",";
\& my $def_DMD               = ",";
\& my $def_DMDE              = "=";
\& my $def_DHDE              = "=";
.Ve
.Vb 1
\& my $def_lineterm          = "\en";
.Ve
.Vb 1
\& my $def_HFM               = 0;
.Ve
The default values. for various items.  All of which may be overridden in individual objects.
.Sp
These all should be obvious based upon what you've read so far.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
Bulkmail doesn't directly generate any errors.  If something fails, it will return undef
and set the \->error property of the bulkmail object.  If you've provided an error log file,
the error will be printed out to the log file.
.Sp
Check the return of your functions, if it's false, check \->error to find out what happened.
.Sp
isDuplicate and isBanned will return 0 if an address is not a duplicate or banned, respectively,
but this is (probably) not an error condition.
.SH "HISTORY"
.IX Header "HISTORY"
.RS 11
.RE
.Ip "\- 2.05 10/3/00" 14
.IX Item "- 2.05 10/3/00"
Added envelope_limit method.  See 'envelope_limit', above.
.Sp
Cleaned up the documentation a lot.
.Sp
Re-wrote the date generation methods.  They're now 5\-10% faster and I fixed an *old* bug causing
mail to sometimes appear to have been sent yesterday, or tomorrow.
.Sp
Altered logging when using the envelope, see item \s-1GOOD\s0, above.
.Sp
Fixed a bug with undefined values in mailmerges
.Ip "\- 2.04 8/29/00" 14
.IX Item "- 2.04 8/29/00"
Added log_full_line flag.  See 'log_full_line', above.
.Sp
Trusting is now more trusting.
.Sp
Domains can once again be banned.
.Sp
Error checking is done less often and in a slightly different order now
.Sp
\&\->bulkmail now returns 1 on success.  Doh.
.Sp
Fixed an annoyingly subtle bug with construction of dynamic messages
.Sp
Repaired a long-standing bug in the docs.
.Ip "\- 2.03 8/22/00" 14
.IX Item "- 2.03 8/22/00"
Tweaked the constructor.
.Sp
Enhanced 'error'.  See 'error', above.
.Sp
Enhanced \s-1HFM\s0.
.Sp
Various bug fixes.
.Sp
Enhanced the test suite.
.Ip "\- 2.01 8/16/00" 14
.IX Item "- 2.01 8/16/00"
Fixed a *really* stupid error.  Merge hashes and dynamic hashes weren't properly initialized. Damn.
.Ip "\- 2.00 8/11/00" 14
.IX Item "- 2.00 8/11/00"
Re-wrote everything.  Literally \fBeverything\fR.  Total re-write.  Should be a much better module now.  :)
.Ip "\- 1.11 11/09/99" 14
.IX Item "- 1.11 11/09/99"
Banned addresses now checks entire address case insensitively instead of leaving the local part
alone.  Better safe than sorry.
.Sp
$self->fmdl is now used to split \s-1BULK_FILEMAP\s0
.Sp
Various fixes suggested by Chris Nandor to make \fB\-w\fR shut up.
.Sp
Changed the way to provide local merges to mail and bulkmail so it's more intuitive.
.Ip "\- 1.10 09/08/99" 14
.IX Item "- 1.10 09/08/99"
Several little fixes.
.Sp
The module will now re-connect if it receives a 221 (connection terminated) message from the server.
.Sp
Fixed a potential near-infinite loop in the _valid_email routine.
.Sp
_valid_email now merrily strips away comments (even nested ones).  :)
.Sp
hfm (headers from message) method added.
.Sp
fmdl (filemap delimiter) method added.
.Ip "\- 1.01 09/01/99" 14
.IX Item "- 1.01 09/01/99"
E-mail validation and date generation bug fixes
.Ip "\- 1.00 08/18/99" 14
.IX Item "- 1.00 08/18/99"
First public release onto \s-1CPAN\s0
.Ip "\- 0.93 08/12/99" 14
.IX Item "- 0.93 08/12/99"
Re-vamped the documentation substantially.
.Ip "\- 0.92 08/12/99" 14
.IX Item "- 0.92 08/12/99"
Started adding a zero in front of the version name, just like I always should have
.Sp
Changed accessing of non-standard headers so that they have to be accessed and retrieved
via the \*(L"header\*(R" method.  This is because methods cannot have non-word characters in them.
.Sp
From, Subject, and Precedence headers may also be accessed via header, if you so choose.
.Sp
\&\s-1AUTOLOAD\s0 now complains loudly (setting \->error and printing to \s-1STDERR\s0) if it's called.
.Ip "\- 0.91 08/11/99" 14
.IX Item "- 0.91 08/11/99"
Fixed bugs in setting values which require validation checks.
Fixed accessing of non-standard headers so that the returns are identical to every other accesor method.
.Ip "\- 0.90" 14
.IX Item "- 0.90"
08/10/99 Initial \*(L"completed\*(R" release.  First release available to general public.
.RE
.RS 11
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Sh "bulkmailing"
.IX Subsection "bulkmailing"
Here's how we use Bulkmail in one of our programs:
.Sp
.Vb 1
\& use Mail::Bulkmail;
.Ve
.Vb 15
\& $bulk = Mail::Bulkmail->new(
\&    'From'       => $from,
\&    'Subject'    => $subject,
\&    'Message'    => $message,
\&    'X-Header'   => "Rockin' e-mail!",
\&    'merge'      => {
\&                     '<DATE>'            => $today,
\&                     'BULK_MAILMERGE'    => "email::<ID>::<NAME>::<ADDRESS>"
\&                    },
\&    'LIST'       => './list.txt',
\&    'GOOD'       => './good_list.txt',
\&    'BAD'        => './baddata.txt',
\&    'ERROR'      => './error.txt',
\&    'BANNED'     => './banned.txt',
\& );
.Ve
That example will set up a new bulkmail object, fill in who it's from, the subject, and the message,
as well as a \*(L"X-header\*(R" header which is set to \*(L"Rockin' e-mail!\*(R".
It will also define a merge to turn \*(L"<\s-1DATE\s0>\*(R" control strings into the \f(CW$today\fR string, a \s-1BULK_MAILMERGE\s0 to merge 
in the name, id number, and address of the user.  It opens a \s-1LIST\s0 file, and sets up \s-1GOOD\s0, \s-1BAD\s0, and 
\&\s-1ERROR\s0 files for logging.  It also uses a \s-1BANNED\s0 list.
.Sp
This list is then mailed to by simply calling
.Sp
$bulk->\fIbulkmail()\fR or die \f(CW$bulk\fR->\fIerror()\fR;
.Sp
Easy as pie.  Especially considering that when we had to write all of this code out in our original
implementation, it took up well over 100 lines (and was 400x slower).
.Sh "Single mailing"
.IX Subsection "Single mailing"
.Vb 1
\& use Mail::Bulkmail;
.Ve
.Vb 6
\& $bulk = Mail::Bulkmail->new(
\&     'From'     => $from,
\&     'Subject'  => $Subject,
\&     'Message'  => $message,
\&     'X-Header' => "Rockin' e-mail!"
\& );
.Ve
.Vb 9
\& $bulk->mail(
\&      'thomasoniii@yahoo.com',
\&      {
\&         '<DATE>'    => $today,
\&         '<ID>'      => '36373',
\&         '<NAME>'    => 'Jim Thomason',
\&         '<ADDRESS>' => 'Chicago, IL'
\&       }
\& );
.Ve
This will e-mail out a message identical to the one we bulkmailed up above, but it'll only go to
thomasoniii@yahoo.com
.Sh "\s-1HUGE\s0 example with dynamic messaging"
.IX Subsection "HUGE example with dynamic messaging"
.Vb 10
\& {
\&    my @stuff = (
\&        \e&solitary_address, 
\&        ['some_address@somewhere.com', "HOOSIER", "BETDA", "GAMMA",
\&            "hoosier=alpha,pickle=something", 
\&            "To=test,From=mike,Subject=special,Marvelous=Charlie"
\&        ], 
\&        'some_other_address@somewhere.com::able::baker::charlie::::Subject=special', 
\&        'some_address@somewhere_else.com::alpha::bravo::niner::::Subject=special'
\&    );
.Ve
.Vb 3
\&    sub email_list {
\&        return shift @stuff;
\&    };
.Ve
.Vb 6
\&    sub solitary_address { 
\&        return ['another_address@some_server_somewhere.com', "hoosier", "betda", "gamma", 
\&        "hoosier=alpha,pickle=something", 
\&        "To=admin,From=herbert,Subject=yodel,Marvelous=Charlie"
\&        ]
\&    };
.Ve
.Vb 1
\& };
.Ve
.Vb 47
\& my %hash = ("this" => "That");
\& my $bulk = Mail::Bulkmail->new(
\&    "From"             => "thomasoniii\e@yahoo.com",
\&    "Subject"          => "Test with envelope",
\&    "Smtp"             => "email.emailserv.com",
\&    "LIST"             => \e&email_list,
\&    "ERRFILE"          => \e*STDERR,
\&    "use_envelope"     => 0,
\&    "Trusting"         => 0,
\&    "To"               => "My_list@my_server.com",
\&    "allow_duplicates" => 1,
\&    "Message"          => "azz--hello there who are you? (hoosier) (pickle) I see that you're at BULK_EMAIL",
\&    "merge" => {
\&        "this is a test" => "something",
\&        "who" => "what",
\&        "where" => "there",
\&        "ttt" => "things",
\&        "BULK_MAILMERGE" => "BULK_EMAIL::azz::bzz::czz::DYNAMIC_MESSAGE::DYNAMIC_HEADERS"
\&    },
\&    "dynamic" => {
\&        "hoosier" => {
\&            "alpha" => "This is an alpha email component",
\&            "beta" => "This is a beta email component",
\&            "agent" => "This is an agent email component"
\&        },
\&        "pickle" => {
\&            "something" => "You've requested the pickle agent!"
\&        }
\&    },
\&    "dynamic_headers" => {
\&        "Subject" => {
\&            "Hello!" => "Why HELLO there.",
\&            "yodel" => "I'm yodelling!",
\&            "special" => "Get this special offer!"
\&        },
\&        "From" => {
\&            "herbert" => 'herber@hoover.com',
\&            "mike" => 'mike@wallace.com'
\&        },
\&        "To" => {
\&            "admin" => "admin\e@somewhere.com",
\&            "test" => "test\e@elsewhere.com"
\&        },
\&        "Marvelous" => {
\&            "Max" => "Max is marvelous!",
\&            "Charlie" => "Charlie is marvelous!"
\&        }
.Ve
.Vb 2
\&    }
\& ) or die Mail::Bulkmail->error();
.Ve
\&\fBStudy this example\fR.  Change the email addresses.  Run it.  Understand it.  Be happy.
.SH "FAQ"
.IX Header "FAQ"
\&\fBSo just how fast is this thing, anyway?\fR
.Sp
I don't know any more, I don't have access to the same gigantic lists I used to anymore.  :~(
.Sp
Anyway, I'm guesstimating that normal emailing will be about 5\-10% slower than before, at most.
But envelope mailing will be 400+ percent faster.
.Sp
Well, there's a caveat to that.  I'm estimating that normal emailing the same way you'd use v1.11 will be
5\-10% slower than before.  \*(L"normal\*(R" means using flat files as your lists.  If you start using functions or
\&\s-1SQL\s0 queries to build your list, then all bets are off.  For instance, one list I'm using now sends to about
50 people in about 50 seconds (terribly slow).  But it's repeatedly performing a \s-1SQL\s0 query 'til it gets the
result it likes, comparing that result against several conditions, deciding to continue, and then completely
building the message on the fly so every single one is unique.  That's a lot of overhead which slows it down
quite a bit.  So \s-1YMMV\s0, as usual.
.Sp
Here's the 1.x answer, with 2.00 comments
.Sp
Really fast.  Really stupendously incredibly fast.
.Sp
The largest list that I have data on has 91,140 people on it.  This list runs through to \fIcompletion\fR in about
an hour and 43 minutes, which means that Mail::Bulkmail can process (at least) 884 messages per minute or about
53,100 per hour. (\fIthe guess is that with 2.00 and envelope sending, you could email to these people in roughly
17 minutes\fR)
.Sp
\&\fBSo? How big were the individual messages sent out?  Total data transferred is what counts, not total recipients!\fR
.Sp
How right you are.  The last message sent out was 4,979 bytes.  4979 x 91,140 people is 453,786,060 bytes of data 
transferred, or about 453.786 megabytes in 1 hour and 43 minutes.  This is a sustained transfer rate of about 4.4 megabytes
per minute, or 264.34 megabytes per hour. (\fIThis hasn't changed in 2.00, we're just smart enough to send less data\fR)
.Sp
\&\fBAm I going to see transfer speeds that fast?\fR
.Sp
Maybe, maybe not.  It depends on how busy your \s-1SMTP\s0 server is.  If you have a relatively unused \s-1SMTP\s0 server with a fair amount
of horsepower, you can easily get these speeds or beyond.  If you have a relatively busy and/or low powered \s-1SMTP\s0 server, you're
not going to reach speeds that fast.
.Sp
\&\fBHow much faster will Mail::Bulkmail be than my current system?\fR
.Sp
This is a very tough question to answer, since it depends highly upon what your current system is.  For the sake of argument,
let's assume that for your current system, you open an \s-1SMTP\s0 connection to your server, send a message, and close the connection.
And then repeat.  Open, send, close, etc.
.Sp
Mail::Bulkmail will \fIalways\fR be faster than this approach since it opens one \s-1SMTP\s0 connection and sends every single message across
on that one connection.  How much faster depends on how busy your server is as well as the size of your list.
.Sp
Lets assume (for simplicity's sake) that you have a list of 100,000 people.  We'll also assume that you have a pretty busy
\&\s-1SMTP\s0 server and it takes (on average) 25 seconds for the server to respond to a connection request.  We're making 100,000
connection requests (with your old system).  That means 100,000 x 25 seconds = almost 29 days waiting just to make connections
to the server!  Mail::Bulkmail makes one connection, takes 25 seconds for it, and ends up being 100,000x faster!
.Sp
But, now lets assume that you have a very unbusy \s-1SMTP\s0 server and it responds to connection requests in .003 seconds.  We're making
100,000 connection requests.  That means 100,000 x .0003 seconds = about 5 minutes waiting to make connections to the server.
Mail::Bulkmail makes on connection, takes .0003 seconds for it, and ends up only being 1666x faster.  But, even though being
1,666 times faster sounds impressive, the world won't stop spinning on its axis if you use your old system and take up an extra
5 minutes.
.Sp
And this doesn't even begin to take into account systems that don't open and close \s-1SMTP\s0 connections for each message.
.Sp
\&\fI2.00 will probably be a little slower than 1.x without envelope sending.  It'll be \f(BImuch\fI faster with it\fR
.Sp
In short, there's no way to tell how much of a speed increase you'll see.
.Sp
\&\fBHave you benchmarked it against anything else?\fR
.Sp
Not scientifically.  I've heard that Mail::Bulkmail is about 4\-5x faster than Listcaster from Mustang Software, but I don't
have any hard numbers.  
.Sp
If you want to benchmark it against some other system and let me know the results, it'll be much appreciated.  :\-)
.Sp
\&\fBWait a minute!  You said up there that Mail::Bulkmail opens one connection and sends all the messages through.  What happens
if the connection is dropped midway through?\fR
.Sp
Well, either something good or something bad depending on what happens.  If it's something good, the server will send a 221 message
(server closing) which Mail::Bulkmail should pick up and some point, realize its disconnected and then reconnect for the next
message.  If it's something bad, the server will just stop replying and Mail::Bulkmail will sit there forever wondering why
the server won't talk to it anymore.  
.Sp
Realistically, if your server bellyflopped and is not responding at all and won't even alert that it's disconnected, you probably
have something serious to worry about.
.Sp
A future release will probably have a time-out option so Mail::Bulkmail will bow out and assume its disconnected after a
certain period of time. 
.Sp
\&\fBWhat about multipart messages? (\s-1MIME\s0 attachments)\fR
.Sp
*grumble grumble*  This is forthcoming, but it won't be in before version 2.5.  Maybe 3.0...
.Sp
My current employer absolutely needs a mailing system that can handle attachments, so I figure I might
as well finally get around to building it into the module.
.Sp
In the mean time, you can set your own headers, boundaries, etc. and just do the \s-1MIME\s0 encoding yourself.  It will work,
I just won't do it for you.
.Sp
Note that if you just want to sent out a regular \s-1HTML\s0 message instead of text that you can just use the \->\s-1HTML\s0
flag to tell the module that it's \s-1HTML\s0.
.Sp
\&\fBI'd like to send out a mass-mailing that has different From and To fields in the message and the envelope.  Can I do this?\fR
.Sp
Oh all right, go ahead.   I've decided not to punish the legitimate mass emailers because of the spammers.  So go
to town.  I figure it couldn't hurt once people start realizing that a Perl module is one of the fastest freakin'
mass mailers around.  Power to the cause!
.Sp
\&\fBCan I send spam with this thing?\fR
.Sp
No.  Don't be a jerk.
.Sp
\&\fBSo what is it with these version numbers anyway?\fR
.Sp
I'm going to \fItry\fR to be consistent in how I number the releases.
.Sp
The \fBhundredths\fR digit will indicate bug fixes, minor behind-the-scenes changes, etc.
.Sp
The \fBtenths\fR digit will indicate new and/or better functionality, as well as some minor new features.
.Sp
The \fBones\fR digit will indicate a major new feature or re-write.
.Sp
Basically, if you have x.ab and x.ac comes out, you want to get it guaranteed.  Same for x.ad, x.ae, etc.
.Sp
If you have x.ac and x.ba comes out, you'll probably want to get it.  Invariably there will be bug fixes from the last \*(L"hundredths\*(R"
release, but it'll also have additional features.  These will be the releases to be sure to read up on to make sure that nothing
drastic has changes.
.Sp
If you have x.ac and y.ac comes out, it will be the same as x.ac->x.ba but on a much larger scale.  Judging by the
amount of revision and improvement between 1.11 and 2.00, there's a very good chance you'll want to look at this
release.  But, also judging by 1.11\->2.00, you'll want to really pour over the docs, since it probably won't be
backwards compatable and you'll have to fiddle with your script to use it.
.Sp
\&\fBSo what can I expect to see in the future?\fR
.Sp
Neat things.  Really \fIreally\fR neat things.  I've got a few tricks up my sleeve that will send the performance
through the roof.  In theory.  If I can get them to work.  Be patient.
.Sp
But good things are in the works.  I just have too much fun developing this module.  :)
.Sp
\&\fBWow, this module is really cool.  Have you contributed anything else to \s-1CPAN\s0?\fR
.Sp
Yes, Carp::Notify and Text::Flowchart
.Sp
\&\fBWas that a shameless plug?\fR
.Sp
Why, yes.  Yes it was.
.Sp
\&\fBAnything else you want to tell me?\fR
.Sp
Sure, anything you need to know.  Just drop me a message.
.SH "MISCELLANEA"
.IX Header "MISCELLANEA"
Mail::Bulkmail will automatically set three headers for you (well, maybe four).
.RS 11
.RE
.Ip "1" 4
.IX Item "1"
Who the message is from (From:....)
.Ip "2" 4
.IX Item "2"
The subject of the message (Subject:...)
.Ip "3" 4
.IX Item "3"
The precedence of the message (Precedence:...)
.Ip "4" 4
.IX Item "4"
.Vb 3
\& Who the message is to (To:....) I<only if using the envelope>
\& (To: will actually always be set, but if not using the envelope it will
\& be set to the individual receiving it)
.Ve
.RE
.RS 11
.Sp
The defaults will be set unless you give them new values, but regardless these headers \fIwill\fR be set.  No way
around it.  Additional headers are set solely at the descretion of the user.
.Sp
Also, this module was originally written to make my life easier by including in one place all the goodies that I
used constantly.  That's not to say that there aren't goodies that I haven't included that would be beneficial to add.
If there's something that you feel would be worthwhile to include, please let me know and I'll consider adding it.
.Sp
How do you know what's a worthwhile addition?  Basically, if you need to do some sort of pre-processing to your e-mail
addresses so that you have to use your own loop and calls to \fImail()\fR instead of using \fIbulkmail()\fR, and you're using said
loop and processing in several routines, it may be a useful addition.  Definitely let me know about those.  
.Sp
That's not to say that random suggestions wouldn't be good, those I'll listen to as well.  But something big like that
is probably a useful thing to have so I'd be most interested in hearing about them.
.SH "COPYRIGHT (again)"
.IX Header "COPYRIGHT (again)"
Copyright (c) 1999, 2000 James A Thomason \s-1III\s0 (thomasoniii@yahoo.com). All rights reserved.
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "CONTACT INFO"
.IX Header "CONTACT INFO"
So you don't have to scroll all the way back to the top, I'm Jim Thomason (thomasoniii@yahoo.com) and feedback is appreciated.
Bug reports/suggestions/questions/etc.  Hell, drop me a line to let me know that you're using the module and that it's
made your life easier.  :\-)
