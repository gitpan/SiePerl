.\" Automatically generated by Pod::Man version 1.15
.\" Mon Apr 23 13:58:48 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "XML::TreeBuilder 3"
.TH XML::TreeBuilder 3 "perl v5.6.1" "2000-11-04" "User Contributed Perl Documentation"
.UC
.SH "NAME"
\&\s-1XML:\s0:TreeBuilder \- Parser that builds a tree of \s-1XML:\s0:Element objects
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\&  foreach my $file_name (@ARGV) {
\&    my $tree = XML::TreeBuilder->new; # empty tree
\&    $tree->parse_file($file_name);
\&    print "Hey, here's a dump of the parse tree of $file_name:\en";
\&    $tree->dump; # a method we inherit from XML::Element
\&    print "And here it is, bizarrely rerendered as XML:\en",
\&      $tree->as_XML, "\en";
.Ve
.Vb 3
\&    # Now that we're done with it, we must destroy it.
\&    $tree = $tree->delete;
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module uses \s-1XML:\s0:Parser to make \s-1XML\s0 document trees constructed of
\&\s-1XML:\s0:Element objects (and \s-1XML:\s0:Element is a subclass of \s-1HTML:\s0:Element
adapted for \s-1XML\s0).  \s-1XML:\s0:TreeBuilder is meant particularly for people
who are used to the \s-1HTML:\s0:TreeBuilder / \s-1HTML:\s0:Element interface to
document trees, and who don't want to learn some other document
interface like \s-1XML:\s0:Twig or \s-1XML::DOM\s0.
.PP
The way to use this class is to:
.PP
1. start a new (empty) \s-1XML:\s0:TreeBuilder object.
.PP
2. set any of the \*(L"store\*(R" options you want.
.PP
3. then parse the document from a source by calling
\&\f(CW\*(C`$x\->parsefile(...)\*(C'\fR
or
\&\f(CW\*(C`$x\->parse(...)\*(C'\fR (See the XML::Parser manpage docs for the options
that these two methods take)
.PP
4. do whatever you need to do with the syntax tree, presumably
involving traversing it looking for some bit of information in it,
.PP
5. and finally, when you're done with the tree, call \f(CW$tree\fR->delete to
erase the contents of the tree from memory.  This kind of thing
usually isn't necessary with most Perl objects, but it's necessary for
TreeBuilder objects.  See the HTML::Element manpage for a more verbose
explanation of why this is the case.
.SH "METHODS AND ATTRIBUTES"
.IX Header "METHODS AND ATTRIBUTES"
\&\s-1XML:\s0:TreeBuilder is a subclass of \s-1XML:\s0:Element, which in turn is a subclass
of \s-1HTML\s0:Element.  You should read and understand the documentation for
those two modules.
.PP
An \s-1XML:\s0:TreeBuilder object is just a special \s-1XML:\s0:Element object that
allows you to call these additional methods:
.Ip "$root = \s-1XML:\s0:TreeBuilder->\fInew()\fR" 4
.IX Item "$root = XML::TreeBuilder->new()"
Construct a new \s-1XML:\s0:TreeBuilder object.
.Ip "$root->parse(...options...)" 4
.IX Item "$root->parse(...options...)"
Uses \s-1XML:\s0:Parser's \f(CW\*(C`parse\*(C'\fR method to parse \s-1XML\s0 from the source(s?)
specified by the options.  See the XML::Parse manpage
.Ip "$root->parsefile(...options...)" 4
.IX Item "$root->parsefile(...options...)"
Uses \s-1XML:\s0:Parser's \f(CW\*(C`parsefile\*(C'\fR method to parse \s-1XML\s0 from the source(s?)
specified by the options.  See the XML::Parse manpage
.Ip "$root->parse_file(...options...)" 4
.IX Item "$root->parse_file(...options...)"
Simply an alias for \f(CW\*(C`parsefile\*(C'\fR.
.Ip "$root->store_comments(value)" 4
.IX Item "$root->store_comments(value)"
This determines whether TreeBuilder will normally store comments found
while parsing content into \f(CW\*(C`$root\*(C'\fR.  Currently, this is off by default.
.Ip "$root->store_declarations(value)" 4
.IX Item "$root->store_declarations(value)"
This determines whether TreeBuilder will normally store markup
declarations found while parsing content into \f(CW\*(C`$root\*(C'\fR.  Currently,
this is off by default.
.Ip "$root->store_pis(value)" 4
.IX Item "$root->store_pis(value)"
This determines whether TreeBuilder will normally store processing
instructions found while parsing content into \f(CW\*(C`$root\*(C'\fR.
Currently, this is off (false) by default.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
the XML::Parser manpage, the XML::Element manpage, the HTML::TreeBuilder manpage, the HTML::DOMbo manpage.
.PP
And for alternate \s-1XML\s0 document interfaces, the XML::DOM manpage and the XML::Twig manpage.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2000 Sean M. Burke.
.SH "AUTHOR"
.IX Header "AUTHOR"
Sean M. Burke, <sburke@cpan.org>
