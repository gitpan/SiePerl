.\" Automatically generated by Pod::Man version 1.15
.\" Mon Apr 23 13:39:41 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "XML::Doctype 3"
.TH XML::Doctype 3 "perl v5.6.1" "2000-08-17" "User Contributed Perl Documentation"
.UC
.SH "NAME"
\&\s-1XML:\s0:Doctype \- A \s-1DTD\s0 object class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&   # To parse an external DTD at compile time, useful when
\&   # using XML::ValidWriter
\&   use XML::Doctype NAME => 'FooML', SYSTEM_ID => 'FooML.dtd' ;
\&   use XML::Doctype NAME => 'FooML', DTD_TEXT  => $dtd ;
.Ve
.Vb 2
\&   # Parsing at run-time
\&   $doctype = XML::Doctype->new( 'FooML', SYSTEM_ID => 'FooML.dtd' ) ;
.Ve
.Vb 3
\&   # or
\&   $doctype = XML::Doctype->new() ;
\&   $doctype->parse( 'FooML', 'FooML.dtd' ) ;
.Ve
.Vb 3
\&   # Saving the parsed object
\&   open( PM, ">FooML/DTD/v1_000.pm" ) or die $! ;
\&   print PM $doctype->as_pm( 'FooML::DTD::v1_000' ) ;
.Ve
.Vb 2
\&   # Using a saved parsed DTD
\&   use FooML::DTD::v1_000 ;
.Ve
.Vb 1
\&   $doctype = FooML::DTD::v1_000->new() ;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module parses DTDs and allows them to be saved as .pm files and
reloaded.  The ability to save and reload is intended to aid in packaging
parsed DTDs with \s-1XML\s0 tools so that \s-1XML:\s0:Parser need not be installed.
.SH "STATUS"
.IX Header "STATUS"
This module is alpha code.  It's developed enough to support \s-1XML:\s0:ValidWriter,
but need a lot of work.  Some big things that are lacking are:
.Ip "\(bu" 4
methods or objects to build / traverse the \s-1DTD\s0
.Ip "\(bu" 4
\&\s-1XML:\s0:Doctype::ELEMENT
.Ip "\(bu" 4
\&\s-1XML:\s0:Doctype::ATTLIST
.Ip "\(bu" 4
\&\s-1XML:\s0:Doctype::ENITITY
.SH "METHODS"
.IX Header "METHODS"
.Ip "new"
.IX Item "new"
.Vb 3
\&   $doctype = XML::Doctype->new() ;
\&   $doctype = XML::Doctype->new( 'FooML', DTD_TEXT => $doctype_text ) ;
\&   $doctype = XML::Doctype->new( 'FooML', SYSTEM_ID => 'FooML.dtd' ) ;
.Ve
.Ip "name"
.IX Item "name"
.Vb 1
\&   $name = $doctype->name() ;
.Ve
.Vb 1
\&   Sets/gets the name.
.Ve
.Ip "parse_dtd"
.IX Item "parse_dtd"
.Vb 2
\&   $doctype->parse_dtd( $name, $doctype_text ) ;
\&   $doctype->parse_dtd( $name, $doctype_text, 'internal' ) ;
.Ve
Parses the text of a \s-1DTD\s0 from a scalar.  \f(CW$name\fR is used to indicate the
name of the \s-1DOCTYPE\s0, and thus the root node.
.PP
The \s-1DTD\s0 is considered to be external unless the third parameter is
\&\s-1TRUE\s0.
.Ip "parse_dtd_file"
.IX Item "parse_dtd_file"
.Vb 2
\&   $doctype->parse_dtd_file( $name, $system_id [, $public_id] ) ;
\&   $doctype->parse_dtd_file( $name, $system_id [, $public_id], 'internal' ) ;
.Ve
Parses a \s-1DTD\s0 from a file.  Eventually will support full \s-1URL\s0 syntax.
.PP
$public_id is ignored for now, and \f(CW$system_id\fR is used to locate
the \s-1DTD\s0.
.PP
This routine requires \s-1XML:\s0:Parser.  \s-1XML:\s0:Parser is not loaded at any
other time and is not needed to use the resulting \s-1DTD\s0 object.
.PP
The \s-1DTD\s0 is considered to be external unless the fourth parameter is
\&\s-1TRUE\s0.
.PP
.Vb 2
\&   $doctype->parse_dtd_file( $name, $system_id, $p_id, 'internal' ) ;
\&   $doctype->parse_dtd_file( $name, $system_id, undef, 'internal' ) ;
.Ve
.Ip "system_id"
.IX Item "system_id"
.Vb 1
\&   $system_id = $doctype->system_id() ;
.Ve
.Vb 1
\&   Sets/gets the system ID.
.Ve
.Ip "public_id"
.IX Item "public_id"
.Vb 1
\&   $public_id = $doctype->public_id() ;
.Ve
.Vb 1
\&   Sets/gets the public_id.
.Ve
.Ip "element_decl"
.IX Item "element_decl"
.Vb 1
\&   $elt_decl = $doctype->element_decl( $name ) ;
.Ve
Returns the \s-1XML:\s0:Doctype:Element object associated with \f(CW$name\fR.  These can
be defined by <!ELEMENT> tags or undefined, which can happen if they
were just referred-to by <!ELEMENT> or <!ATTLIST> tags.
.Ip "element_names"
.IX Item "element_names"
Returns an unsorted list of element names.  This list includes names that
are declared and undeclared (but referred to in element declarations or
attribute definitions).
.Ip "as_pm"
.IX Item "as_pm"
.Vb 3
\&   open( PM, "FooML/DTD/v1_001.pm" )            or die $! ;
\&   print PM $doctype->as_pm( 'FooML::DTD::v1_001' ) or die $! ;
\&   close PM                                     or die $! ;
.Ve
Then, later:
.PP
.Vb 1
\&   use FooML::DTD::v1_001 ;   # Do *not* use () as a parameter list!
.Ve
Returns string containing the \s-1DTD\s0 as an independant module, allowing the
\&\s-1DTD\s0 to be parsed in the development environment and shipped as Perl code,
so that the target environment need not have \s-1XML:\s0:Parser installed.
.PP
This is useful for \s-1XML\s0 creation-only tools and as an
efficiency tuning measure if you will be rereading the same set of DTDs over
and over again.
.Ip "import"
.IX Item "import"
.PD 0
.Ip "use"
.IX Item "use"
.PD
.Vb 1
\&   use XML::Doctype NAME => 'FooML', SYSTEM_ID => 'dtds/FooML.dtd' ;
.Ve
\&\fIimport()\fR constructs a default \s-1DTD\s0 object for the calling package
so that \s-1XML:\s0:ValidWriter's functional interface can use it.
.PP
If \s-1XML:\s0:Doctype is subclassed, the subclasses' constructor is called with
all parameters.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
This object uses the fields pragma, so you should use base and fields for
any subclasses.
.SH "AUTHOR"
.IX Header "AUTHOR"
Barrie Slaymaker <barries@slaysys.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This module is Copyright 2000, Barrie Slaymaker.  All rights reserved.
.PP
This module is licensed under the \s-1GPL\s0, version 2.  Please contact me if this
does not suit your needs.
