.\" Automatically generated by Pod::Man version 1.15
.\" Tue Jun 12 10:57:52 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "IO::ScalarArray 3"
.TH IO::ScalarArray 3 "perl v5.6.1" "2001-04-04" "User Contributed Perl Documentation"
.UC
.SH "NAME"
\&\s-1IO:\s0:ScalarArray \- \s-1IO::\s0 interface for reading/writing an array of scalars
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
If you have any Perl5, you can use the basic \s-1OO\s0 interface...
.PP
.Vb 1
\&    use IO::ScalarArray;
.Ve
.Vb 3
\&    # Open a handle on an array-of-scalars:
\&    $AH = new IO::ScalarArray;
\&    $AH->open(\e@a);
.Ve
.Vb 5
\&    # Open a handle on an array-of-scalars, read it line-by-line, 
\&    # then close it:
\&    $AH = new IO::ScalarArray \e@a;
\&    while ($_ = $AH->getline) { print "Line: $_" }
\&    $AH->close;
.Ve
.Vb 3
\&    # Open a handle on an array-of-scalars, and slurp in all the lines:
\&    $AH = new IO::ScalarArray \e@a;
\&    print $AH->getlines;
.Ve
.Vb 4
\&    # Open a handle on an array-of-scalars, and append to it:
\&    $AH = new IO::ScalarArray \e@a;
\&    $AH->print("bar\en");
\&    print "some string is now: ", $somestring, "\en";
.Ve
.Vb 2
\&    # Get the current position:
\&    $pos = $AH->getpos;         ### $AH->tell() also works
.Ve
.Vb 2
\&    # Set the current position:
\&    $AH->setpos($pos);          ### $AH->seek(POS,WHENCE) also works
.Ve
.Vb 5
\&    # Open an anonymous temporary scalar array:
\&    $AH = new IO::ScalarArray;
\&    $AH->print("Hi there!\enHey there!\en");
\&    $AH->print("Ho there!\en");
\&    print "I got: ", @{$AH->aref}, "\en";      ### get at value
.Ve
If your Perl is 5.004 or later, you can use the \s-1TIEHANDLE\s0
interface, and read/write as array-of-scalars just like files:
.PP
.Vb 1
\&    use IO::ScalarArray;
.Ve
.Vb 5
\&    # Writing to a scalar array...
\&    my @a; 
\&    tie *OUT, 'IO::ScalarArray', \e@a;
\&    print OUT "line 1\enline 2\en", "line 3\en";
\&    print "s is now... [", join('', @a), "]\en";
.Ve
.Vb 5
\&    # Reading and writing an anonymous scalar array... 
\&    tie *OUT, 'IO::ScalarArray';
\&    print OUT "line 1\enline 2\en", "line 3\en";
\&    tied(OUT)->seek(0,0);
\&    while (<OUT>) { print "LINE: ", $_ }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class implements objects which behave just like FileHandle
(or \s-1IO:\s0:Handle) objects, except that you may use them to write to
(or read from) scalars.  They can be tiehandle'd as well.  
.PP
For writing large amounts of data with individual \fIprint()\fR statements, 
this is likely to be more efficient than \s-1IO:\s0:Scalar.
.PP
Basically, this:
.PP
.Vb 4
\&    my @a;
\&    $AH = new IO::ScalarArray \e@a;
\&    $AH->print("Hel", "lo, ");     
\&    $AH->print("world!\en");
.Ve
Or this (if you have 5.004 or later):
.PP
.Vb 4
\&    my @a;
\&    $AH = tie *OUT, 'IO::ScalarArray', \e@a;
\&    print OUT "Hel", "lo, "; 
\&    print OUT "world!\en";
.Ve
Causes \f(CW@a\fR to be set to the following arrayt of 3 strings:
.PP
.Vb 3
\&    ( "Hel" , 
\&      "lo, " , 
\&      "world!\en" )
.Ve
Compare this with \s-1IO:\s0:Scalar.
.SH "PUBLIC INTERFACE"
.IX Header "PUBLIC INTERFACE"
.Sh "Construction"
.IX Subsection "Construction"
.Ip "new [\s-1ARGS\s0...]" 4
.IX Item "new [ARGS...]"
\&\fIClass method.\fR
Return a new, unattached array handle.  
If any arguments are given, they're sent to \fIopen()\fR.
.Ip "open [\s-1ARRAYREF\s0]" 4
.IX Item "open [ARRAYREF]"
\&\fIInstance method.\fR
Open the array handle on a new array, pointed to by \s-1ARRAYREF\s0.
If no \s-1ARRAYREF\s0 is given, a \*(L"private\*(R" array is created to hold
the file data.
.Sp
Returns the self object on success, undefined on error.
.Ip "opened" 4
.IX Item "opened"
\&\fIInstance method.\fR
Is the array handle opened on something?
.Ip "close" 4
.IX Item "close"
\&\fIInstance method.\fR
Disassociate the array handle from its underlying array.
Done automatically on destroy.
.Sh "Input and output"
.IX Subsection "Input and output"
.Ip "flush" 4
.IX Item "flush"
\&\fIInstance method.\fR
No-op, provided for \s-1OO\s0 compatibility.
.Ip "getc" 4
.IX Item "getc"
\&\fIInstance method.\fR
Return the next character, or undef if none remain.
This does a \fIread\fR\|(1), which is somewhat costly.
.Ip "getline" 4
.IX Item "getline"
\&\fIInstance method.\fR
Return the next line, or undef on end of data.
Can safely be called in an array context.
Currently, lines are delimited by \*(L"\en\*(R".
.Ip "getlines" 4
.IX Item "getlines"
\&\fIInstance method.\fR
Get all remaining lines.
It will \fIcroak()\fR if accidentally called in a scalar context.
.Ip "print \s-1ARGS\s0..." 4
.IX Item "print ARGS..."
\&\fIInstance method.\fR
Print \s-1ARGS\s0 to the underlying array.  
.Sp
Currently, this always causes a \*(L"seek to the end of the array\*(R"
and generates a new array entry.  This may change in the future.
.Ip "read \s-1BUF\s0, \s-1NBYTES\s0, [\s-1OFFSET\s0];" 4
.IX Item "read BUF, NBYTES, [OFFSET];"
\&\fIInstance method.\fR
Read some bytes from the array.
Returns the number of bytes actually read, 0 on end-of-file, undef on error.
.Ip "write \s-1BUF\s0, \s-1NBYTES\s0, [\s-1OFFSET\s0];" 4
.IX Item "write BUF, NBYTES, [OFFSET];"
\&\fIInstance method.\fR
Write some bytes into the array.
.Sh "Seeking/telling and other attributes"
.IX Subsection "Seeking/telling and other attributes"
.Ip "autoflush" 4
.IX Item "autoflush"
\&\fIInstance method.\fR
No-op, provided for \s-1OO\s0 compatibility.
.Ip "binmode" 4
.IX Item "binmode"
\&\fIInstance method.\fR
No-op, provided for \s-1OO\s0 compatibility.
.Ip "clearerr" 4
.IX Item "clearerr"
\&\fIInstance method.\fR  Clear the error and \s-1EOF\s0 flags.  A no-op.
.Ip "eof" 4
.IX Item "eof"
\&\fIInstance method.\fR  Are we at end of file?
.Ip "seek \s-1POS\s0,WHENCE" 4
.IX Item "seek POS,WHENCE"
\&\fIInstance method.\fR
Seek to a given position in the stream.
Only a \s-1WHENCE\s0 of 0 (\s-1SEEK_SET\s0) is supported.
.Ip "tell" 4
.IX Item "tell"
\&\fIInstance method.\fR
Return the current position in the stream, as a numeric offset.
.Ip "setpos \s-1POS\s0" 4
.IX Item "setpos POS"
\&\fIInstance method.\fR
Seek to a given position in the array, using the opaque \fIgetpos()\fR value.
Don't expect this to be a number.
.Ip "getpos" 4
.IX Item "getpos"
\&\fIInstance method.\fR
Return the current position in the array, as an opaque value.
Don't expect this to be a number.
.Ip "aref" 4
.IX Item "aref"
\&\fIInstance method.\fR
Return a reference to the underlying array.
.SH "VERSION"
.IX Header "VERSION"
$Id: ScalarArray.pm,v 1.118 2001/04/04 05:37:51 eryq Exp $
.SH "AUTHOR"
.IX Header "AUTHOR"
.Sh "Principal author"
.IX Subsection "Principal author"
Eryq (\fIeryq@zeegee.com\fR).
President, ZeeGee Software Inc (\fIhttp://www.zeegee.com\fR).
.Sh "Other contributors"
.IX Subsection "Other contributors"
Thanks to the following individuals for their invaluable contributions
(if I've forgotten or misspelled your name, please email me!):
.PP
\&\fIAndy Glew,\fR
for suggesting \f(CW\*(C`getc()\*(C'\fR.
.PP
\&\fIBrandon Browning,\fR
for suggesting \f(CW\*(C`opened()\*(C'\fR.
.PP
\&\fIEric L. Brine,\fR
for his offset-using \fIread()\fR and \fIwrite()\fR implementations. 
