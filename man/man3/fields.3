.\" Automatically generated by Pod::Man version 1.15
.\" Mon Apr 23 08:20:56 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "fields 3"
.TH fields 3 "perl v5.6.1" "2000-12-14" "User Contributed Perl Documentation"
.UC
.SH "NAME"
fields \- compile-time class fields
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  package Foo;
\&  use fields qw(foo bar _Foo_private);
.Ve
.Vb 3
\&  sub new {
\&      my $proto = shift;
\&      my $class = ref $proto || $proto;
.Ve
.Vb 1
\&      my Foo $self = fields::new($class);
.Ve
.Vb 3
\&      $self->{_Foo_private} = "this is Foo's secret";
\&      $self->{foo} = 'everybody knows';
\&      $self->{bar} = 'an open bar';
.Ve
.Vb 2
\&      return $self;
\&  }
.Ve
.Vb 2
\&  my Foo $foo_obj = Foo->new;
\&  $foo_obj->{foo} = 42;
.Ve
.Vb 3
\&  # This will generate a compile-time error.  zap is not a
\&  # public field of Foo.
\&  $foo_obj->{zap} = 42;
.Ve
.Vb 4
\&  # subclassing
\&  package Bar;
\&  use base 'Foo';
\&  use fields qw(baz _Bar_private);  # fields not shared with foo.
.Ve
.Vb 3
\&  sub new {
\&      my $proto = shift;
\&      $self = $proto->SUPER::new;  # call Foo's new()
.Ve
.Vb 2
\&      $self->{baz} = 'and stuff';  # initialize my own fields.
\&      $self->{_Bar_private} = 'our little secret';
.Ve
.Vb 2
\&      return $self;
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`fields\*(C'\fR pragma enables compile-time verified class fields.
.PP
\&\s-1NOTE:\s0 The current implementation keeps the declared fields in the \f(CW%FIELDS\fR
hash of the calling package, but this may change in future versions.
Do \fBnot\fR update the \f(CW%FIELDS\fR hash directly, because it must be created
at compile-time for it to be fully useful, as is done by this pragma.
.PP
If a typed lexical variable (my Dog \f(CW$spot\fR) holding a reference is used
to access a hash element and a package/class with the same name as the
type has declared class fields using this pragma, then the operation
is turned into an array access at compile time.
(the Pseudo-hashes: Using an array as a hash entry in the perlref manpage)
.PP
The relatied \f(CW\*(C`base\*(C'\fR pragma will combine fields from base classes and
any fields declared using the \f(CW\*(C`fields\*(C'\fR pragma.  This enables field
inheritance to work properly.
.PP
Field names that start with an underscore character are made private
to a class and are not visible to subclasses.  Inherited fields can be
overridden but will generate a warning if used together with the \f(CW\*(C`\-w\*(C'\fR
switch.
.PP
The effect of all this is that you can have objects with named fields
which are as compact and as fast arrays to access.  This only works as
long as the objects are accessed through properly typed variables.  If
the objects are not typed, access is only checked at run-time and
performance may suffer a bit.
.Sh "Functions"
.IX Subsection "Functions"
.Ip "\fBnew\fR" 4
.IX Item "new"
.Vb 2
\&  $obj = fields::new($class);
\&  $obj = fields::new($another_obj);
.Ve
\&\fIfields::new()\fR creates and blesses a pseudo-hash comprised of the
fields declared using the \f(CW\*(C`fields\*(C'\fR pragma into the specified class.
This makes it possible to write a constructor like this:
.Sp
.Vb 2
\&    package Critter::Sounds;
\&    use fields qw(cat dog bird);
.Ve
.Vb 3
\&    sub new {
\&        my $proto = shift;
\&        my $class = ref $proto || $proto;
.Ve
.Vb 1
\&        my Critter::Sounds $self = fields::new($class);
.Ve
.Vb 5
\&        %$self = (
\&                  cat     => 'meow',
\&                  dog     => 'bark',
\&                  dogcow  => 'moof',
\&                 );
.Ve
.Vb 2
\&        return $self;
\&    }
.Ve
.Ip "\fBphash\fR" 4
.IX Item "phash"
.Vb 4
\&    $phash = fields::phash;
\&    $phash = fields::phash(\e@keys);
\&    $phash = fields::phash(\e@keys, \e@values);
\&    $phash = fields::phash(%hash);
.Ve
\&\fIfields::phash()\fR can be used to create and initialize a plain
(unblessed) pseudo-hash.  It is prefered that this function be used
instead of creating pseudo-hashes directly.
.Sp
If no arguments are given the resulting pseudohash will be empty and
have no fields.
.Sp
The optional \f(CW@keys\fR will be used to initialize the keys/fields of the
resulting hash.  \f(CW@values\fR, also optional, will be used as the values
for each key.  If \f(CW@values\fR contains less elements than \f(CW@keys\fR, the
trailing elements of the pseudo-hash will not be initialized.  If
there are more \f(CW@values\fR than \f(CW@keys\fR the function will throw a warning
(it may die in the future).
.Sp
This makes it particularly useful for creating a pseudo-hash from
subroutine arguments.
.Sp
.Vb 3
\&    sub dogtag {
\&        my $tag = fields::phash([qw(name rank serial_num)], [@_]);
\&    }
.Ve
\&\fIfields::phash()\fR also accepts a plain \f(CW%hash\fR used to construct the
pseudo-hash.  Examples:
.Sp
.Vb 4
\&    my $tag = fields::phash(name       => 'Kirk',
\&                            rank       => 'Captain',
\&                            serial_num => 42
\&                           );
.Ve
.Vb 1
\&    my $phash = fields::phash(%args);
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
the base manpage, the public manpage, the private manpage, the protected manpage, the Class::Fields manpage
the Pseudo-hashes: Using an array as a hash entry in the perlref manpage
.SH "\fBNOTE\fP"
.IX Header "NOTE"
This is the version of fields.pm which comes with Class::Fields.  \s-1NOT\s0
the version which is distributed with Perl.  This version should
safely emulate everything that perl 5.6.0's fields.pm does.  It passes
all of 5.6.0's regression tests.
.PP
It should also work under 5.005_03, although if you're going to be
screwing around with pseudohashes you really should upgrade to 5.6.0.
.SH "AUTHOR"
.IX Header "AUTHOR"
Michael G Schwern <schwern@pobox.com>.  \fIfields::new()\fR, \fIfields::phash()\fR
and most of the documentation taken from the original fields.pm.
