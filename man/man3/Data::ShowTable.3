.\" Automatically generated by Pod::Man version 1.15
.\" Mon Apr 23 10:27:28 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "ShowTable 3"
.TH ShowTable 3 "perl v5.6.1" "1997-03-02" "User Contributed Perl Documentation"
.UC
.SH "NAME"
\&\fBShowTable\fR \- routines to display tabular data in several formats.
.SH "USAGE"
.IX Header "USAGE"
\&\f(CW\*(C`use Data::ShowTable;\*(C'\fR
.PP
\&\fBShowTable\fR { \fIparameter\fR => \fIvalue\fR, ... };
.PP
\&\fBShowTable\fR \fI\e@titles\fR, \fI\e@types\fR, \fI\e@widths\fR, \fI\e&row_sub\fR [, \fI\e&fmt_sub\fR ];
.PP
\&\fBShowDatabases\fR \fI\e@dbnames\fR;
.PP
\&\fBShowDatabases\fR { \fIparameter\fR => \fIvalue\fR, ... };
.PP
\&\fBShowTables\fR \fI\e@tblnames\fR;
.PP
\&\fBShowTables\fR { \fIparameter\fR => \fIvalue\fR, ... };
.PP
\&\fBShowColumns\fR \fI\e@columns\fR, \fI\e@col_types\fR, \fI\e@col_lengths\fR, \fI\e@col_attrs\fR;
.PP
\&\fBShowColumns\fR { \fIparameter\fR => \fIvalue\fR, ... };
.PP
\&\fBShowBoxTable\fR \fI\e@titles\fR, \fI\e@types\fR, \fI\e@widths\fR, \fI\e&row_sub\fR [, \fI\e&fmt_sub\fR ];
.PP
\&\fBShowBoxTable\fR { \fIparameter\fR => \fIvalue\fR, ... };
.PP
\&\fBShowSimpleTable\fR \fI\e@titles\fR, \fI\e@types\fR, \fI\e@widths\fR, \fI\e&row_sub\fR [, \fI\e&fmt_sub\fR];
.PP
\&\fBShowSimpleTable\fR { \fIparameter\fR => \fIvalue\fR, ... };
.PP
\&\fBShowHTMLTable\fR \fI\e@titles\fR, \fI\e@types\fR, \fI\e@widths\fR, \fI\e&row_sub\fR [, \fI\e&fmt_sub\fR];
.PP
\&\fBShowHTMLTable\fR { \fIparameter\fR => \fIvalue\fR, ... };
.PP
\&\fBShowListTable\fR \fI\e@titles\fR, \fI\e@types\fR, \fI\e@widths\fR, \fI\e&row_sub\fR [, \fI\e&fmt_sub\fR];
.PP
\&\fBShowListTable\fR { \fIparameter\fR => \fIvalue\fR, ... };
.PP
\&\f(CW\*(C`package Data::ShowTable\*(C'\fR;
.PP
\&\fB$Show_Mode\fR = '\fImode\fR';
.PP
\&\fB$Max_Table_Width\fR = \fInumber\fR;
.PP
\&\fB$Max_List_Width\fR = \fInumber\fR;
.PP
\&\fB$No_Escape\fR = \fIflag\fR;
.PP
\&\fB%URL_Keys\fR = { "\fI$colname\fR\*(L" => \*(R"\fI$col_URL\fR", ... };
.PP
\&\fB@Title_Formats\fR = ( \fIfmt1_html\fR, <fmt2_html>, ... );
.PP
\&\fB@Data_Formats\fR = ( \fIfmt1_html\fR, <fmt2_html>, ... );
.PP
\&\fBShowRow\fR \fI$rewindflag\fR, \fI\e$index\fR, \fI$col_array_1\fR [, \fI$col_array_2\fR, ...;]
.PP
\&\fI$fmt\fR = \fBShowTableValue\fR \fI$value\fR, \fI$type\fR, \fI$max_width\fR, \fI$width\fR, \fI$precision\fR, \fI$showmode\fR;
.PP
[\fI$plaintext\fR = ] \fBPlainText\fR [\fI$htmltext\fR];
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \fBShowTable\fR module provides subroutines to display tabular data,
typially from a database, in nicely formatted columns, in several formats.
Its arguments can either be given in a fixed order, or, as
a single, anonymous hash-array.
.PP
The output format for any one invocation can be one of four possible styles:
.Ip "Box" 10
.IX Item "Box"
A tabular format, with the column titles and the entire table surrounded by a
\&\*(L"box\*(R" of "\f(CW\*(C`+\*(C'\fR\*(L", \*(R"\f(CW\*(C`\-\*(C'\fR\*(L", and \*(R"\f(CW\*(C`|\*(C'\fR" characters.  See the section on "ShowBoxTable" for details.
.Ip "Table" 10
.IX Item "Table"
A simple tabular format, with columns automatically aligned, with column titles.
See the section on "ShowSimpleTable".
.Ip "List" 10
.IX Item "List"
A \fIlist\fR style, where columns of data are listed as a \fIname\fR:\fIvalue\fR pair, one
pair per line, with rows being one or more column values, separated by an empty line.
See the section on "ShowListTable".
.Ip "\s-1HTML\s0" 10
.IX Item "HTML"
The data is output as an \s-1HTML\s0 \fI\s-1TABLE\s0\fR, suitable for display through a \fIWeb\fR\-client.
See the section on "ShowHTMLTable".  Input can either be plain \s-1ASCII\s0 text, or text
with embedded \s-1HTML\s0 elements, depending upon an argument or global parameter.
.PP
The subroutines which perform these displays are listed below.
.SH "EXPORTED NAMES"
.IX Header "EXPORTED NAMES"
This module exports the following subroutines: 
.PP
.Vb 11
\& ShowDatabases    - show list of databases
\& ShowTables       - show list of tables
\& ShowColumns      - show table of column info
\& ShowTable        - show a table of data
\& ShowRow          - show a row from one or more columns
\& ShowTableValue   - show a single column's value
\& ShowBoxTable     - show a table of data in a box
\& ShowListTable    - show a table of data in a list
\& ShowSimpleTable  - show a table of data in a simple table
\& ShowHTMLTable    - show a table of data using HTML
\& PlainText        - convert HTML text into plain text
.Ve
All of these subroutines, and others, are described in detail in the
following sections.
.SH "MODULES"
.IX Header "MODULES"
.SH "ShowTable"
.IX Header "ShowTable"
Format and display the contents of one or more rows of data.
.PP
\&\ \fBShowTable\fR { \fIparameter\fR => \fIvalue\fR, ... };
.PP
\&\ \fBShowTable\fR \fI\e@titles\fR, \fI\e@types\fR, \fI\e@widths\fR, \fI\e&row_sub\fR 
[, \fI\e&fmt_sub\fR [, \fI$max_width\fR ] [, \fI$show_mode\fR ] ];
.PP
The \fBShowTable\fR subroutine displays tabular data aligned in columns,
with headers.  \fBShowTable\fR supports four \fImodes\fR of display: \fBBox\fR, \fBTable\fR,
\&\fBList\fR, and \fB\s-1HTML\s0\fR.  Each mode is described separately below.
.PP
The arguments to \fBShowTable\fR may be given in one of two ways: as a
hashed-array, or by a combination of fixed order arguments, and some
package-global variable settings.  The hash-array parameters correspond
to the fixed arguments and the global-parameter settings.
.PP
In the list below, both the hash-array parameter name and the
fixed-order argument name is given as the value.  In the case where
there is no fixed-order argument for a given parameter-value pair, then
the corresponding global variable name is given.
.if n .Ip "\f(CW""""titles""""\fR => \fI\e@titles\fR" 10
.el .Ip "\f(CWtitles\fR => \fI\e@titles\fR" 10
.IX Item "titles => @titles"
A reference to an array of column names, or titles.  If a particular column name
is null, then the string \f(CW\*(C`Field_\f(CInum\f(CW\*(C'\fR is used by default.  To have a column
have no title, use the empty string.
.if n .Ip "\f(CW""""types""""\fR => \fI\e@types\fR" 10
.el .Ip "\f(CWtypes\fR => \fI\e@types\fR" 10
.IX Item "types => @types"
A reference to an array of types, one for each column.  These types are
passed to the \fIfmt_sub\fR for appropriate formatting.  Also, if a column
type matches the regexp "\f(CW\*(C`/text|char|string/i\*(C'\fR", then the column
alignment will be left-justified, otherwise it will be right-justified.
.if n .Ip "\f(CW""""widths""""\fR => \fI\e@widths\fR" 10
.el .Ip "\f(CWwidths\fR => \fI\e@widths\fR" 10
.IX Item "widths => @widths"
A reference to an array of column widths, which may be given as an integer, or
as a string of the form: "\fIwidth\fR.\fIprecision\fR".
.if n .Ip "\f(CW""""row_sub""""\fR => \fI\e&row_sub\fR" 10
.el .Ip "\f(CWrow_sub\fR => \fI\e&row_sub\fR" 10
.IX Item "row_sub => &row_sub"
A reference to a subroutine which successively returns rows of values in an array.
It is called for two purposes, each described separately:
.Sp
* To fetch successive rows of data:
.Sp
.Vb 1
\&    @row = &$row_sub(0);
.Ve
When given a null, zero, or empty argument, the next row is returned.
.Sp
* To initialize or rewind the data traversal.
.Sp
.Vb 1
\&    $rewindable = &$row_sub(1);
.Ve
When invoked with a non-null argument, the subroutine should rewind its
row pointer to start at the first row of data.  If the data which
\&\fIrow_sub\fR is traversing is not rewindable, it must return zero or null.
If the data is rewindable, a non-null, non-zero value should be returned.
.Sp
The \fIrow_sub\fR must expect to be invoked once with a non-null argument,
in order to discover whether or not the data is rewindable.  If the data
cannot be rewound, \fIrow_sub\fR will thereafter only be called with a zero
argument. 
.Sp
Specifically, \fIrow_sub\fR subroutine is used in this manner:
.Sp
.Vb 10
\&    $rewindable = &$row_sub(1);
\&    if ($rewindable) {
\&        while ((@row = &$row_sub(0)), $#row >= 0) {
\&            # examine lengths for optimal formatting
\&        }
\&        &$row_sub(1);   # rewind
\&    }
\&    while ((@row = &$row_sub(0)), $#row >= 0) {
\&        # format the data
\&    }
.Ve
The consequence of data that is not rewindable, a reasonably nice table
will still be formatted, but it may contain fairly large amounts of
whitespace for wide columns.
.if n .Ip "\f(CW""""fmtsub""""\fR => \fI\e&fmt_sub\fR" 10
.el .Ip "\f(CWfmtsub\fR => \fI\e&fmt_sub\fR" 10
.IX Item "fmtsub => &fmt_sub"
A reference to a subroutine which formats a value, according to its
type, width, precision, and the current column width.  It is invoked
either with a fixed list of arguments, or with a hash-array of parameter
and value pairs.
.Sp
.Vb 1
\&  $string = &fmt_sub { I<parameter> => I<value>, ... };
.Ve
.Vb 1
\&  $string = &fmt_sub($value, $type, $max_width, $width, $precision)
.Ve
If \fI\e&fmt_sub\fR is omitted, then a default subroutine, \fBShowTableValue\fR, 
will be used, which will use Perl's standard string formatting rules.
.Sp
The arguments to \fI\e&fmt_sub\fR, either as values passed in a fixed
order, or as part of the parameter value pair, are described in the
section on the section on ""ShowTableValue" below.
.if n .Ip "\f(CW""""max_width""""\fR => \fInumber\fR," 10
.el .Ip "\f(CWmax_width\fR => \fInumber\fR," 10
.IX Item "max_width => number,"
The maximum table width, including the table formatting characters.  If
not given, defaults to the global variable \fB$Max_Table_Width\fR;
.if n .Ip "\f(CW""""show_mode""""\fR => '\fImode\fR'," 10
.el .Ip "\f(CWshow_mode\fR => '\fImode\fR'," 10
.IX Item "show_mode => 'mode',"
The display mode of the output.  One of five strings: \f(CW\*(C`'Box'\*(C'\fR,
\&\f(CW\*(C`'Table'\*(C'\fR, \f(CW\*(C`'Simple'\*(C'\fR, \f(CW\*(C`'List'\*(C'\fR, and \f(CW\*(C`'HTML'\*(C'\fR.
.SH "ShowDatabases"
.IX Header "ShowDatabases"
Show a list of database names.
.PP
\&\ \fBShowDatabases\fR \fI\e@dbnames\fR;
.PP
\&\ \fBShowDatabases\fR { 'data' => \fI\e@dbnames\fR, \fIparameter\fR =>
\&\fIvalue\fR, ...};
.PP
\&\fBShowDatabases\fR is intended to be used to display a list of database
names, under the column heading of \*(L"Databases\*(R".  It is a special case
usage of \fBShowTable\fR (and can thus be passed any parameter suitable 
for \fBShowTable\fR.
.PP
The argument, \fI\e@dbnames\fR, is a reference to an array of strings, used
as the values of the single column display.
.SH "ShowTables"
.IX Header "ShowTables"
Show an array of table names.
.PP
\&\ \fBShowTables\fR \fI\e@tblnames\fR;
.PP
\&\ \fBShowTables\fR { 'data' => \fI\e@tblnames\fR, \fIparameter\fR => \fIvalue\fR, ...};
.PP
\&\fBShowTables\fR is used to display a list of table names, under the column
heading of \*(L"Tables\*(R".  It is a special case usage of \fBShowTable\fR, and can
be passed any the section on "ShowTable" argument parameter.
.SH "ShowColumns"
.IX Header "ShowColumns"
Display a table of column names, types, and attributes.
.PP
\&\ \fBShowColumns\fR { \fIparameter\fR => \fIvalues\fR, ... };
.PP
\&\ \fBShowColumns\fR \fI\e@columns\fR, \fI\e@col_types\fR, \fI\e@col_lengths\fR, \fI\e@col_attrs\fR;
.PP
The \fBShowColumns\fR subroutine displays a table of column names, types, lengths,
and other attributes in a nicely formatted table.  It is a special case usage
of \fBShowTable\fR, and can be passed any argument suitable for the section on "ShowTable";
.PP
The arguments are:
.if n .Ip "\f(CW""""columns""""\fR = \fI\e@columns\fR" 10
.el .Ip "\f(CWcolumns\fR = \fI\e@columns\fR" 10
.IX Item "columns = @columns"
An array of column names.  This provides the value for the first column
of the output.
.if n .Ip "\f(CW""""col_types""""\fR = \fI\e@col_types\fR" 10
.el .Ip "\f(CWcol_types\fR = \fI\e@col_types\fR" 10
.IX Item "col_types = @col_types"
An array of column types names.  This provides the value for the second
column. 
.if n .Ip "\f(CW""""col_lengths""""\fR = \fI\e@col_lengths\fR" 10
.el .Ip "\f(CWcol_lengths\fR = \fI\e@col_lengths\fR" 10
.IX Item "col_lengths = @col_lengths"
An array of maximum lengths for corresponding columns.  This provides
the value for the third column of the output.
.if n .Ip "\f(CW""""col_attrs""""\fR = \fI\e@col_attrs\fR" 10
.el .Ip "\f(CWcol_attrs\fR = \fI\e@col_attrs\fR" 10
.IX Item "col_attrs = @col_attrs"
An array of column attributes array references (ie: an array of arrays).
The attributes array for the first column are at "\fI$col_attrs\fR\-\e>[0]\*(L".
The first attribute of the second column is \*(R"\fI$col_attrs\fR\-\e>[1][0]".
.PP
The columns, types, lengths, and attributes are displayed in a table
with the column headings: \*(L"Column\*(R", \*(L"Type\*(R", \*(L"Length\*(R", and \*(L"Attributes\*(R".
This is a special case usage of \fBShowTable\fR, and can be passed
additional arguments suitable for the section on "ShowTable".
.SH "ShowBoxTable"
.IX Header "ShowBoxTable"
Show tabular data in a box.
.PP
\&\ \fBShowBoxTable\fR { \fIparameter\fR = \fIvalue\fR, ... };
.PP
\&\ \fBShowBoxTable\fR \fI\e@titles\fR, \fI\e@types\fR, \fI\e@widths\fR, \fI\e&row_sub\fR
\&\ [, [ \fI\e&fmt_sub\fR ] [, \fI$max_width\fR ] ];
.PP
The \fBShowBoxTable\fR displays tabular data in titled columns using a \*(L"box\*(R" 
of \s-1ASCII\s0 graphics, looking something like this:
.PP
.Vb 9
\&        +------------+----------+-----+----------+ 
\&        | Column1    | Column2  | ... | ColumnN  |
\&        +------------+----------+-----+----------+
\&        | Value11    | Value12  | ... | Value 1M |
\&        | Value21    | Value22  | ... | Value 2M |
\&        | Value31    | Value32  | ... | Value 3M |
\&        |  ...       |  ...     | ... |  ...     |
\&        | ValueN1    | ValueN2  | ... | Value NM |
\&        +------------+----------+-----+----------+
.Ve
The arguments are the same as with the section on "ShowTable".  If the \fI@titles\fR array
is empty, the header row is omitted.
.SH "ShowSimpleTable"
.IX Header "ShowSimpleTable"
Display a table of data using a simple table format.
.PP
\&\ \fBShowSimpleTable\fR \fI\e@titles\fR, \fI\e@types\fR, \fI\e@widths\fR, \fI\e&row_sub\fR [, \fI\e&fmt_sub\fR];
.PP
\&\ \fBShowSimpleTable\fR { \fIparameter\fR => \fIvalues\fR, ... };
.PP
The \fBShowSimpleTable\fR subroutine formats data into a simple table of
aligned columns, in the following example:
.PP
.Vb 4
\&   Column1  Column2  Column3
\&   -------  -------  -------
\&   Value1   Value2   Value3
\&   Value12  Value22  Value32
.Ve
Columns are auto-sized by the data's widths, plus two spaces between columns.
Values which are too long for the maximum colulmn width are wrapped within
the column.
.SH "ShowHTMLTable"
.IX Header "ShowHTMLTable"
Display a table of data nicely using \s-1HTML\s0 tables.
.PP
\&\ \fBShowHTMLTable\fR { \fIparameter\fR => \fIvalue\fR, ... };
.PP
\&\ \fBShowHTMLTable\fR \fI\e@titles\fR, \fI\e@types\fR, \fI\e@widths\fR, \fI\e&row_sub\fR
[, \fI\e&fmt_sub\fR [, \fI$max_width\fR [, \fI\e%URL_Keys\fR [, \fI$no_escape\fR 
[, \fI\e@title_formats [, \fI\e@data_formats [, \fI$table_attrs\fI ] ] ] ] ] ] ];

\&\fI\fR.PP
The \fBShowHTMLTable\fR displays one or more rows of columns of data using
the \s-1HTML\s0 \f(CW\*(C`\e<TABLE\e\*(C'\fR> feature.  In addition to the usual parameter arguments
of the section on "ShowTable", the following parameter arguments are defined:
.if n .Ip "\f(CW""""url_keys""""\fR => \fI\e%URL_Keys\fR," 10
.el .Ip "\f(CWurl_keys\fR => \fI\e%URL_Keys\fR," 10
.IX Item "url_keys => %URL_Keys,"
This is a hash array of column names (titles) and corresponding base
URLs.  The values of any column names or indexes occuring as keys in
the hash array will be generated as hypertext anchors using the
associated \fIprintf\fR\-like string as the base \s-1URL\s0. Either the column name
or the column index (beginning with 1) may be used as the hash key.
.Sp
In the string value, these macros can be substituted:  
.Sp
"\f(CW\*(C`%K\*(C'\fR" is replaced with the column name.
.Sp
"\f(CW\*(C`%V\*(C'\fR" is replaced with the column value;
.Sp
"\f(CW\*(C`%I\*(C'\fR" is replaced with the column index.
.Sp
For example, if we define the array:
.Sp
.Vb 3
\&    $base_url = "http://www.$domain/cgi/lookup?col=%K?val=%V";
\&    %url_cols = ('Author' => $base_url,
\&                 'Name'   => $base_url);
.Ve
Then, the values in the \f(CW\*(C`Author\*(C'\fR column will be generated with the following
\&\s-1HTML\s0 text:
.Sp
.Vb 1
\&    <A HREF="http://www.$domain/cgi/lookup?col=Author?val=somevalue>somevalue</A>
.Ve
and the values in the \f(CW\*(C`Name\*(C'\fR column will be generated with the \s-1URL:\s0
.Sp
.Vb 1
\&    <A HREF="http://www.$domain/cgi/lookup?col=Name?val=othervalue>othervalue</A>
.Ve
If this variable is not given, it will default to the global variable
\&\f(CW\*(C`\e%URL_Keys\*(C'\fR.
.if n .Ip "\f(CW""""no_escape""""\fR => \fIboolean\fR," 10
.el .Ip "\f(CWno_escape\fR => \fIboolean\fR," 10
.IX Item "no_escape => boolean,"
Unless \fB$no_escape\fR is set, HTML-escaping is performed on the data
values in order to properly display the special \s-1HTML\s0 formatting
characters : '\e<', '\e>', and '&'.  If you wish to display data with
embedded \s-1HTML\s0 text, you must set \fB$no_escape\fR.
.Sp
Enabling embedded \s-1HTML\s0, turns on certain heuristics which enable the
user to more completely define appearance of the table.  For instance,
any \f(CW\*(C`\e<TR\e\*(C'\fR> tokens found embedded *anywhere* within a row of data will
be placed at the front of the row, within the generated \f(CW\*(C`\e<TR\e\*(C'\fR>.
.Sp
Similarly, a row of data containing the \f(CW\*(C`\e<THEAD\e\*(C'\fR> or \f(CW\*(C`\e<TFOOT\e\*(C'\fR>
tokens, and their closing counterparts, will begin and end, respectively
a table header or footer data.
.if n .Ip "\f(CW""""title_formats""""\fR => \fI\e@title_formats\fR," 10
.el .Ip "\f(CWtitle_formats\fR => \fI\e@title_formats\fR," 10
.IX Item "title_formats => @title_formats,"
.PD 0
.if n .Ip "\f(CW""""tformats""""\fR => \fI\e@title_formats\fR," 10
.el .Ip "\f(CWtformats\fR => \fI\e@title_formats\fR," 10
.IX Item "tformats => @title_formats,"
.PD
An array of \s-1HTML\s0 formatting elements for the column titles, one for each
column.  Each array element is a list of one or more \s-1HTML\s0 elements,
given as \f(CW\*(C`\e<ELEMENT\e\*(C'\fR> or plainly, \f(CW\*(C`ELEMENT\*(C'\fR, and separated by a comma
\&\f(CW\*(C`','\*(C'\fR, semi-colon \f(CW\*(C`';'\*(C'\fR, or vertical bar \f(CW\*(C`'|'\*(C'\fR.  Each given \s-1HTML\s0
element is prepended to the corresponding column title, in the order
given.  The corresponding \s-1HTML\s0 closing elements are appended in the
opposite order.
.Sp
For example, if \fI\e@title_formats\fR contains the two elements:
.Sp
.Vb 1
\&    [ 'FONT SIZE=+2,BOLD', 'FONT COLOR=red,EM' ]
.Ve
then the text output for the title of the first column would be:
.Sp
.Vb 1
\&    <FONT SIZE=+2><BOLD>I<column_1_title></BOLD></FONT>
.Ve
If \f(CW\*(C`title_formats\*(C'\fR is omitted, the global variable \fB@Title_Formats\fR
is used by default.
.if n .Ip "\f(CW""""data_formats""""\fR => \fI\e@data_formats\fR," 10
.el .Ip "\f(CWdata_formats\fR => \fI\e@data_formats\fR," 10
.IX Item "data_formats => @data_formats,"
.PD 0
.if n .Ip "\f(CW""""dformats""""\fR => \fI\e@data_formats\fR," 10
.el .Ip "\f(CWdformats\fR => \fI\e@data_formats\fR," 10
.IX Item "dformats => @data_formats,"
.PD
Similar to \f(CW\*(C`title_formats\*(C'\fR, this array provides \s-1HTML\s0 formatting for
the columns of each row of data.  If \f(CW\*(C`data_formats\*(C'\fR is omitted or
null, then the global variable \fB\e@Data_Formats\fR is used by default.
.if n .Ip "\f(CW""""table_attrs""""\fR => \fI$table_attrs\fR," 10
.el .Ip "\f(CWtable_attrs\fR => \fI$table_attrs\fR," 10
.IX Item "table_attrs => $table_attrs,"
This variable defines a string of attributes to be inserted within the
\&\f(CW\*(C`\e<TABLE\e\*(C'\fR> token.  For example, if the user wishes to have no table
border:
.Sp
.Vb 5
\&    ShowHTMLTable { 
\&        ...
\&        table_attrs => 'BORDER=0', 
\&        ...
\&    };
.Ve
.SH "ShowListTable"
.IX Header "ShowListTable"
Display a table of data using a list format.
.PP
\&\ \fBShowListTable\fR { \fIparameter\fR => \fIvalue\fR, ... };
.PP
\&\ \fBShowListTable\fR \fI\e@titles\fR, \fI\e@types\fR, \fI\e@widths\fR, \fI\e&row_sub\fR 
[, \fI\e&fmt_sub\fR [, \fI$max_width\fR [, \fI$wrap_margin\fR ] ] ];
.PP
The arguments for \fBShowListTable\fR are the same as for the section on "ShowTable",
except for those described next.
.if n .Ip "\f(CW""""max_width""""\fR = \fInumber\fR," 10
.el .Ip "\f(CWmax_width\fR = \fInumber\fR," 10
.IX Item "max_width = number,"
.PD 0
.if n .Ip "\f(CW""""wrap_margin""""\fR = \fInumber\fR," 10
.el .Ip "\f(CWwrap_margin\fR = \fInumber\fR," 10
.IX Item "wrap_margin = number,"
.PD
Lines are truncated, and wrapped when their length exceeds
\&\fI$max_width\fR.  Wrapping is done on a word-basis, unless the resulting
right margin exceeds \fI$wrap_margin\fR, in which case the line is simply
truncated at the \fI$max_width\fR limit.
.Sp
The \fI$max_width\fR variable defaults to \fB$Max_List_Width\fR.  The
\&\fI$wrap_margin\fR defaults to \fB$List_Wrap_Margin\fR.
.PP
In \fIList\fR mode, columns (called \*(L"fields\*(R" in List mode) are displayed
wth a field name and value pair per line, with records being one or
more fields .  In other words, the output of a table would
look something like this:
.PP
.Vb 18
\&    Field1_1: Value1_1
\&    Field1_2: Value1_2
\&    Field1_3: Value1_3
\&    ...
\&    Field1-N: Value1_M
\&    <empty line>
\&    Field2_1: Value2_1
\&    Field2_2: Value2_2
\&    Field2_3: Value2_3
\&    ...
\&    Field2_N: Value2_N
\&    ...
\&    FieldM_1: ValueM_1
\&    FieldM_2: ValueM_2
\&    ...
\&    FieldM_N: ValueM_N
\&    <empty line>
\&    <empty line>
.Ve
Characteristics of \fIList\fR mode:
.Ip "\(bu" 10
two empty lines indicate the end of data.
.Ip "\(bu" 10
An empty field (column) may be omitted, or may have a label, but no
data.
.Ip "\(bu" 10
A long line can be continue by a null field (column):
.Sp
.Vb 2
\&    Field2: blah blah blah
\&          : blah blah blah
.Ve
.Ip "\(bu" 10
On a continuation, the null field is an arbitrary number of leading
white space, a colon ':', a single blank or tab, followed by the
continued text.
.Ip "\(bu" 10
Embedded newlines are indicated by the escape mechanism \*(L"\en\*(R".
Similarly, embedded tabs are indicated with \*(L"\et\*(R", returns with \*(L"\er\*(R". 
.Ip "\(bu" 10
If the \fI@titles\fR array is empty, the field names "\f(CW\*(C`Field_\*(C'\fR\fI\s-1NN\s0\fR" are used
instead.
.SH "ShowRow"
.IX Header "ShowRow"
Fetch rows successively from one or more columns of data.
.PP
\&\ \fBShowRow\fR \fI$rewindflag\fR, \fI\e$index\fR, \fI$col_array_1\fR [, \fI$col_array_2\fR, ...;]
.PP
The \fBShowRow\fR subroutine returns a row of data from one or more
columns of data.  It is designed to be used as a \fIcallback\fR routine,
within the \fBShowTable\fR routine.   It can be used to select elements
from one or more array reference arguments.
.PP
If passed two or more array references as arguments, elements of the
arrays selected by \fI$index\fR are returned as the \*(L"row\*(R" of data.
.PP
If a single array argument is passed, and each element of the array is
itself an array, the subarray is returned as the \*(L"row\*(R" of data.
.PP
If the \fI$rewindflag\fR flag is set, then the \fI$index\fR pointer is reset
to zero, and \*(L"true\*(R" is returned (a scalar 1).  This indicates that the
data is rewindable to the \fBShowTable\fR routines.
.PP
When the \fI$rewindflag\fR is not set, then the current row of data, as
determined by \fI$index\fR is returned, and \fI$index\fR will
have been incremented.
.PP
An actual invocation (from \fBShowColumns\fR) is:
.PP
.Vb 3
\&  ShowTable \e@titles, \e@types, \e@lengths, 
\&      sub { &ShowRow( $_[0], \e$current_row, $col_names, $col_types,
\&                      $col_lengths, \e@col_attrs); };
.Ve
In the example above, after each invocation, the \fI$current_row\fR argument 
will have been incremented.
.SH "ShowTableValue"
.IX Header "ShowTableValue"
Prepare and return a formatted representation of a value.  A value
argument, using its corresponding type, effective width, and precision
is formatted into a field of a given maximum width. 
.PP
\&\ \fI$fmt\fR = \fBShowTableValue\fR \fI$value\fR, \fI$type\fR, \fI$max_width\fR, \fI$width\fR, \fI$precision\fR, \fI$showmode\fR;
.if n .Ip "\f(CW""""width""""\fR => \fI$width\fR" 10
.el .Ip "\f(CWwidth\fR => \fI$width\fR" 10
.IX Item "width => $width"
.PD 0
.Ip "\fI$width\fR" 10
.IX Item "$width"
.PD
The width of the current value.  If omittied, \fI$max_width\fR is assumed.
.if n .Ip "\f(CW""""precision""""\fR => \fI$precision\fR" 10
.el .Ip "\f(CWprecision\fR => \fI$precision\fR" 10
.IX Item "precision => $precision"
.PD 0
.Ip "\fI$precision\fR" 10
.IX Item "$precision"
.PD
The number of decimal digits; zero is assumed if omittied.
.if n .Ip "\f(CW""""value""""\fR => \fI$value\fR" 10
.el .Ip "\f(CWvalue\fR => \fI$value\fR" 10
.IX Item "value => $value"
.PD 0
.Ip "\fI$value\fR" 10
.IX Item "$value"
.PD
The value to be formatted.
.Ip "\fI$type\fR" 10
.IX Item "$type"
The type name of the value; eg: \f(CW\*(C`char\*(C'\fR, \f(CW\*(C`varchar\*(C'\fR, \f(CW\*(C`int\*(C'\fR, etc.
.if n .Ip "\f(CW""""maxwidth""""\fR => \fI$max_width\fR" 10
.el .Ip "\f(CWmaxwidth\fR => \fI$max_width\fR" 10
.IX Item "maxwidth => $max_width"
.PD 0
.Ip "\fI$max_width\fR" 10
.IX Item "$max_width"
.PD
The maximum width of any value in the current value's column.  If \fI$width\fR
is zero or null, \fI$max_width\fR is used by default.  \fI$max_width\fR is also
used as a \fIminimum\fR width, in case \fI$width\fR is a smaller value.
.Ip "\fI$width\fR" 10
.IX Item "$width"
The default width of the value, obtained from the width specification of the
column in which this value occurs.
.Ip "\fI$precision\fR" 10
.IX Item "$precision"
The precision specification, if any, from the column width specification.
.Ip "\fI$showmode\fR" 10
.IX Item "$showmode"
The mode of the output: one of \*(L"table\*(R", \*(L"list\*(R", \*(L"box\*(R", or \*(L"html\*(R".  Currently,
only the \*(L"html\*(R" mode is significant: it is used to avoid using \s-1HTML\s0 tokens
as part of the formatted text and length calculations.
.SH "PlainText"
.IX Header "PlainText"
\&\ \fI$plaintext\fR = \fB&PlainText\fR(\fI$htmltext\fR);
.PP
\&\ \fB&PlainText\fR
.PP
This function removes any \s-1HTML\s0 formatting sequences from the input argument,
or from \f(CW\*(C`$_\*(C'\fR if no argument is given.  The resulting plain text is returned
as the result.
.SH "VARIABLES"
.IX Header "VARIABLES"
The following variables may be set by the user to affect the display (with
the defaults enclosed in square brackets [..]):
.Ip "\fB$Show_Mode\fR [Box]" 10
.IX Item "$Show_Mode [Box]"
This is the default display mode when using \fBShowTable\fR.  The
environment variable, \f(CW\*(C`$ENV{'SHOW_MODE'}\*(C'\fR, is used when this variable is
null or the empty string.  The possible values for this variable are:
\&\f(CW\*(C`"Box"\*(C'\fR, \f(CW\*(C`"List"\*(C'\fR, \f(CW\*(C`"Table"\*(C'\fR, and \f(CW\*(C`"HTML"\*(C'\fR.  Case is insignificant.
.Ip "\fB$List_Wrap_Margin\fR [2]" 10
.IX Item "$List_Wrap_Margin [2]"
This variable's value determines how large a margin to keep before wrarpping a
long value's display in a column.  This value is only used in \*(L"List\*(R" mode.
.Ip "\fB$Max_List_Width\fR [80]" 10
.IX Item "$Max_List_Width [80]"
This variable, used in \*(L"List\*(R" mode, is used to determine how long an output line
may be before wrapping it.  The environment variable, \f(CW\*(C`$ENV{'COLUMNS'}\*(C'\fR, is
used to define this value when it is null.
.Ip "\fB$Max_Table_Width\fR ['']" 10
.IX Item "$Max_Table_Width ['']"
This variable, when set, causes all tables to have their columns scaled
such that their total combined width does not exceed this value.  When
this variable is not set, which is the default case, there is no maximum
table width, and no scaling will be done.
.Ip "\fB$No_Escape\fR ['']" 10
.IX Item "$No_Escape ['']"
If set, allows embedded \s-1HTML\s0 text to be included in the data displayed
in an HTML-formatted table.  By default, the \s-1HTML\s0 formatting characters
(\*(L"<\*(R", \*(L">\*(R", and \*(L"&\*(R") occuring in values are escaped.
.Ip "\fB%URL_Keys\fR" 10
.IX Item "%URL_Keys"
In \s-1HTML\s0 mode, this variable is used to recognize which columns are to be 
displayed with a corresponding hypertext anchor.  See the section on "ShowHTMLTable" 
for more details.
.Ip "\fB@HTML_Elements\fR" 10
.IX Item "@HTML_Elements"
An array of \s-1HTML\s0 elements (as of \s-1HTML\s0 3.0) used to recognize and strip for 
width calculations.
.Ip "\fB$HTML_Elements\fR" 10
.IX Item "$HTML_Elements"
A regular expression string formed from the elements of \fB@HTML_Elements\fR.
.SH "INTERNAL SUBROUTINES"
.IX Header "INTERNAL SUBROUTINES"
.SH "get_params"
.IX Header "get_params"
\&\ my \fI$args\fR = \fB&get_params\fR \fI\e@argv\fR, \fI\e%params\fR, \fI\e@arglist\fR;
.PP
Given the \fI@argv\fR originally passed to the calling sub, and the hash of
named parameters as \fI%params\fR, and the array of parameter names in the
order expected for a pass-by-value invocation, set the values of each of
the variables named in \fI@vars\fR.  
.PP
If the only element of the \fI@argv\fR is a hash array, then set the
variables to the values of their corresponding parameters used as keys
to the hash array.  If the parameter is not a key of the \fI%params\fR
hash, and is not a key in the global hash \fB%ShowTableParams\fR, then an
error is noted.
.PP
When \fI@argv\fR has multiple elements, or is not a hash array, set each
variable, in the order given within \fI@arglist\fR, to the values from the
\&\fI@argv\fR, setting the variables named by each value in \fI%params\fR.
.PP
Variables may given either by name or by reference.
.PP
The result is a \s-1HASH\s0 array reference, either corresponding directly to
the \s-1HASH\s0 array passed as the single argument, or one created by
associating the resulting variable values to the parameter names
associated with the variable names.
.SH "html_formats"
.IX Header "html_formats"
\&\ (\fI$prefixes\fR,\fI$suffixes\fR) = \fBhtml_formats\fR \fI\e@html_formats\fR;
.PP
The \fBhtml_format\fR function takes an array reference of \s-1HTML\s0 formatting
elements \fI\e@html_formats\fR, and builds two arrays of strings: the first:
\&\fI$prefixes\fR, is an array of prefixes containing the corresponding \s-1HTML\s0
formatting elements from \fI\e@html_formats\fR, and the second,
\&\fI$suffixes\fR, containing the appropriate \s-1HTML\s0 closing elements, in the
opposite order.
.PP
The result is designed to be used as prefixes and suffixes for the
corresponding titles and column values.
.PP
The array \fI\e@html_formats\fR contains lists of \s-1HTML\s0 formatting elements,
one for each column (either title or data).  Each array element is a
list of one or more \s-1HTML\s0 elements, either given in \s-1HTML\s0 syntax, or as a
\&\*(L"plain\*(R" name (ie: given as \f(CW\*(C`\e<ELEMENT\e\*(C'\fR> or plainly, \f(CW\*(C`ELEMENT\*(C'\fR).
Multiple elements are separated by a comma \f(CW\*(C`','\*(C'\fR.
.PP
The resulting array of \fI$prefixes\fR contains the corresponding opening
elements, in the order given, with the proper \s-1HTML\s0 element syntax.  The
resulting array of \fI$suffixes\fR contains the closing elements, in the
opposite order given, with the proper \s-1HTML\s0 element syntax.
.PP
For example, if \fI\e@html_formats\fR contains the two elements:
.PP
.Vb 1
\&    [ 'FONT SIZE=+2,BOLD', 'FONT COLOR=red,EM' ]
.Ve
then the resulting two arrays will be returned as:
.PP
.Vb 2
\&    [ [ '<FONT SIZE=+2><BOLD>', '<FONT COLOR=red><EM>' ],
\&      [ '</FONT></BOLD>',       '</FONT></EM>' ] ]
.Ve
.SH "calc_widths"
.IX Header "calc_widths"
\&\ (\fI$num_cols\fR, \fI$widths\fR, \fI$precision\fR, \fI$max_widths\fR) =
\&\ \fB&calc_widths\fR( \fI$widthspec\fR, \fI$titles\fR, \fI$rewindable\fR,
\&\ \fI$row_sub\fR, \fI$fmt_sub\fR, \fI$types\fR, \fI$showmode\fR, 
\&\ \fI$max_width\fR);
.Sh "\fB\s-1DESCRIPTION\s0\fP"
.IX Subsection "DESCRIPTION"
\&\fBcalc_widths\fR is a generalized subroutine used by all the \fBShowTable\fR
variant subroutines to setup internal variables prior to formatting for
display.  \fBCalc_widths\fR handles the column width and precision
analysis, including scanning the data (if rewindable) for appropriate
default values.
.PP
The number of columns in the data is returned, as well as three arrays:
the declared column widths, the column precision values, and the maximum
column widths.
.Sh "\fB\s-1RETURN\s0 \s-1VALUES\s0\fP"
.IX Subsection "RETURN VALUES"
.Ip "\fI$num_cols\fR" 10
.IX Item "$num_cols"
is the number of columns in the data.  If the data is not rewindable,
this is computed as the maximum of the number of elements in the
\&\fI$widthspec\fR array and the number of elements in the \fI$titles\fR
array.  When the data is rewindable, this is the maximum of the number
of columns of each row of data.
.Ip "\fI$widths\fR" 10
.IX Item "$widths"
is the column widths array ref, without the precision specs (if any).
Each column's width value is determined by the original \fI$widthspec\fR
value and/or the maximum length of the formatted data for the column.
.Ip "\fI$precision\fR" 10
.IX Item "$precision"
is the precision component (if any) of the original \fI$widthspec\fR
array ref.  If there was no original precision component from the \fI$widthspec\fR,
and the data is rewindable, then the data is examined to determine the
maximum default precision.
.Ip "\fI$max_widths\fR" 10
.IX Item "$max_widths"
is the ref to the array of maximum widths for the given columns.
.Sh "\fB\s-1ARGUMENTS\s0\fP"
.IX Subsection "ARGUMENTS"
.Ip "\fI$widthspec\fR" 10
.IX Item "$widthspec"
A reference to an array of column width (or length) values, each given
as an integer, real number, or a string value of
"\fIwidth\fR.\fIprecision\fR".  If a value is zero or null, the length of the
corresponding formatted data (if rewindable) and column title length are
used to determine a reasonable default.
.Sp
If a column's \fIwidth\fR portion is a positive, non-zero number, then the
column will be this wide, regardless of the values lengths of the data
in the column.
.Sp
If the column's \fIwidth\fR portion is given as a negative number, then the
positive value is used as a minimum column width, with no limit on the
maximum column width.  In other words, the column will be at least
\&\fIwidth\fR characters wide.
.Sp
If the data is not rewindable, and a column's width value is null or
zero, then the length of the column title is used.  This may cause severe
wrapping of data in the column, if the column data lengths are much
greater than the column title widths.
.Ip "\fI$titles\fR" 10
.IX Item "$titles"
The array ref to the column titles; used to determine the minimum
acceptable width, as well as the default number of columns.  If the
\&\f(CW\*(C`$titles\*(C'\fR array is empty, then the \f(CW\*(C`$widthspec\*(C'\fR array is used to
determine the default number of columns.
.Ip "\fI$rewindable\fR" 10
.IX Item "$rewindable"
A flag indicating whether or not the data being formatted is rewindable.
If this is true, a pass over the data will be done in order to calculate
the maximum lengths of the actual formatted data, using \fI$fmt_sub\fR
(below), rather than just rely on the declared column lengths.  This
allows for optimal column width adjustments (ie: the actual column
widths may be less than the declared column widths).
.Sp
If it is not desired to have the column widths dynamically adjusted,
then set the \fI$rewindable\fR argument to 0, even if the data is
rewindable.
.Ip "\fI$row_sub\fR" 10
.IX Item "$row_sub"
The code reference to the subroutine which returns the data; invoked
only if \fI$rewindable\fR is non-null.
.Ip "\fI$fmt_sub\fR" 10
.IX Item "$fmt_sub"
The subroutine used to determine the length of the data when formatted;
if this is omitted or null, the length of the data is used by default.
The \fI$fmt_sub\fR is used only when the data is rewindable.
.Ip "\fI$types\fR" 10
.IX Item "$types"
An array reference to the types of each of the value columns; used only 
when \fI$fmt_sub\fR is invoked.
.Ip "\fI$showmode\fR" 10
.IX Item "$showmode"
A string indicating the mode of the eventual display; one of four strings:
"\f(CW\*(C`box\*(C'\fR\*(L", \*(R"\f(CW\*(C`table\*(C'\fR\*(L", \*(R"\f(CW\*(C`list\*(C'\fR\*(L", and \*(R"\f(CW\*(C`html\*(C'\fR".  Used to adjust widths
for formatting requirements.
.Ip "\fI$max_width\fR" 10
.IX Item "$max_width"
The maximum width of the table being formatted.  If set, and the total
sum of the individual columns exceeds this value, the column widths are
scaled down uniformly.  If not set (null), no column width scaling is done.
.SH "putcell"
.IX Header "putcell"
\&\ \fI$wrapped\fR = \fB&putcell\fR( \fI\e@cells\fR, \fI$c\fR, \fI$cell_width\fR, \fI\e@prefix\fR, \fI\e@suffix\fR, \fI$wrap_flag\fR );
.PP
Output the contents of an array cell at \fI$cell\fR[\fI$c\fR], causing text
longer than \fI$cell_width\fR to be saved for output on subsequent calls.
Prefixing the output of each cell's value is a string from the
two-element array \fI@prefix\fR.  Suffixing each cell's value is a string
from the two-element array \fI@suffix\fR.  The first element of either 
array is selected when \fI$wrap_flag\fR is zero or null, or when there is
no more text in the current to be output.  The second element
is selected when \fI$wrap_flag\fR is non-zero, and when there is more text in
the current cell to be output.
.PP
In the case of text longer than \fI$cell_width\fR, a non-zero value is
returned. 
.PP
Cells with undefined data are not output, nor are the prefix or suffix
strings. 
.SH "center"
.IX Header "center"
Center a string within a given width.
.PP
\&\ \fI$field\fR = \fBcenter\fR \fI$string\fR, \fI$width\fR;
.SH "max"
.IX Header "max"
Compute the maximum value from a list of values.
.PP
\&\ \fI$max\fR = \fB&max\fR( \fI@values\fR );
.SH "min"
.IX Header "min"
Compute the minum value from a list of values.
.PP
\&\ \fI$min\fR = \fB&min\fR( \fI@values\fR );
.SH "max_length"
.IX Header "max_length"
Compute the maximum length of a set of strings in an array reference.
.PP
\&\ \fI$maxlength\fR = \fB&max_length\fR( \fI\e@array_ref\fR );
.SH "htmltext"
.IX Header "htmltext"
Translate regular text for output into an \s-1HTML\s0 document.  This means
certain characters, such as \*(L"&\*(R", \*(L">\*(R", and \*(L"<\*(R" must be escaped. 
.PP
\&\ \fI$output\fR = \fB&htmltext\fR( \fI$input\fR [, \fI$allflag\fR ] );
.PP
If \fI$allflag\fR is non-zero, then all characters are escaped.  Normally,
only the four \s-1HTML\s0 syntactic break characters are escaped.
.SH "out"
.IX Header "out"
Print text followed by a newline.
.PP
\&\ \fBout\fR \fI$fmt\fR [, \fI@text\fR ];
.SH "put"
.IX Header "put"
Print text (without a trailing newline).
.PP
\&\ \fBout\fR \fI$fmt\fR [, \fI@text\fR ];
.SH "AUTHOR"
.IX Header "AUTHOR"
Alan K. Stebbens <aks@sgi.com>
.SH "BUGS"
.IX Header "BUGS"
.Ip "\(bu" 10
Embedded \s-1HTML\s0 is how the user can insert formatting overrides.  However,
the \s-1HTML\s0 formatting techniques have not been given much consideration \-\-
feel free to provide constructive feedback.
