.\" Automatically generated by Pod::Man version 1.15
.\" Mon Apr 23 12:01:36 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "ADMIN 1"
.TH ADMIN 1 "perl v5.6.1" "2001-01-05" "User Contributed Perl Documentation"
.UC
.SH "NAME"
\&\s-1HTML:\s0:Mason::Admin \- Mason Administrator's Guide
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This guide is intended for the sys admin/web master in charge of
installing, configuring, or tuning a Mason system.
.SH "PIECES OF AN INSTALLATION"
.IX Header "PIECES OF AN INSTALLATION"
This section discusses the various files and directories that play a
part in Mason's configuration.
.Sh "Config.pm"
.IX Subsection "Config.pm"
Config.pm contains global configuration options for Mason.
Makefile.PL will initially create the file based on your environment,
placing it in the \f(CW\*(C`lib/HTML/Mason\*(C'\fR subdirectory of the distribution.
After that, you can edit it by hand, following the comments inside.
.PP
\&\*(L"make install\*(R" copies Config.pm to your Perl library directory
(e.g. \f(CW\*(C`/usr/lib/perl5/site_perl/HTML/Mason\*(C'\fR) along with the other module
files. This allows Mason internally to grab the configuration data
with "\f(CW\*(C`use HTML::Mason::Config\*(C'\fR".
.PP
When upgrading from a previous version, \*(L"make install\*(R" will
maintain the previous Config.pm values.
.PP
Currently this file controls:
.PP
o Whether or not certain optional modules, such as Time::HiRes,
should be loaded for enhanced features.
.PP
o The type of \s-1DBM\s0 and the serialization method used for Mason's data
caching. If you plan to use data caching, make sure that the \s-1DBM\s0
package is a good-quality one (\fBDB_File\fR or \fBGDBM_File\fR).
.Sh "httpd.conf, srm.conf"
.IX Subsection "httpd.conf, srm.conf"
Directives must be added to Apache's configuration files to specify
which requests should be handled through Mason, and the handler
used for those requests. As described in \fB\s-1HTML:\s0:Mason\fR, a simple
configuration looks like:
.PP
.Vb 7
\&    DocumentRoot /usr/local/www/htdocs
\&    PerlRequire /usr/local/mason/handler.pl
\&    DefaultType text/html
\&    <Location />
\&        SetHandler perl-script
\&        PerlHandler HTML::Mason
\&    </Location>
.Ve
.Sh "handler.pl"
.IX Subsection "handler.pl"
This file contains startup code that initializes the parent Apache
process. It also defines the handler used by each child process to
field Mason requests. See the synopsis in \fB\s-1HTML:\s0:Mason\fR for a
simple example. The next section discusses in detail how to configure
this file.
.SH "CONFIGURING THE HANDLER SCRIPT"
.IX Header "CONFIGURING THE HANDLER SCRIPT"
Handler.pl is the most important file in your Mason configuration.  It
is responsible for creating the three Mason objects and supplying the
many parameters that control how your components are parsed and
executed. It also provides the opportunity to execute arbitrary code
at three important junctures: the server initialization, the beginning
of a request, and the end of a request.  A wide set of behaviors can
be implemented with a mere few lines of well-placed Perl in your
handler.pl.  In this section we present the basics of setting up
handler.pl as well as some ideas for more advanced applications.
.Sh "Creating the Mason objects"
.IX Subsection "Creating the Mason objects"
\&\f(CW\*(C`handler.pl\*(C'\fR creates three Mason objects: the Parser, Interpreter,
and ApacheHandler. The Parser compiles components into Perl
subroutines; the Interpreter executes those compiled components; and
the Apache handler routes mod_perl requests to Mason.  These objects
are created once in the parent httpd and then copied to each child
process.
.PP
These objects have a fair number of possible parameters. Only two of
them are required, \fIcomp_root\fR and \fIdata_dir\fR; these are discussed
in the next two subsections. The various parameters are documented in
the individual reference manuals for each object:
\&\fB\s-1HTML:\s0:Mason::Parser\fR, \fB\s-1HTML:\s0:Mason::Interp\fR, and
\&\fB\s-1HTML:\s0:Mason::ApacheHandler\fR.
.PP
The advantage of embedding these parameters in objects is that
advanced configurations can create more than one set of objects,
choosing which set to use at request time.  For example, suppose you
have a staging site and a production site running on the same web
server, distinguishing between them with a configuration variable
called \f(CW\*(C`version\*(C'\fR:
.PP
.Vb 4
\&    # Create Mason objects for staging site
\&    my $parser1 = new HTML::Mason::Parser;
\&    my $interp1 = new HTML::Mason::Interp (parser=>$parser1, ...);
\&    my $ah1 = new HTML::Mason::ApacheHandler (interp=>$interp1);
.Ve
.Vb 4
\&    # Create Mason objects for production site
\&    my $parser2 = new HTML::Mason::Parser;
\&    my $interp2 = new HTML::Mason::Interp (parser=>$parser2, ...);
\&    my $ah2 = new HTML::Mason::ApacheHandler (interp=>$interp2);
.Ve
.Vb 2
\&    sub handler {
\&        ...
.Ve
.Vb 7
\&        # Choose the right ApacheHandler
\&        if ($r->dir_config('version') eq ' staging') {
\&            $ah1->handle_request($r);
\&        } else {
\&            $ah2->handle_request($r);
\&        }
\&    }
.Ve
.Sh "Component root"
.IX Subsection "Component root"
Given a tree of component source files, the top of the tree is called
the component root and is set via the \f(CW\*(C`comp_root\*(C'\fR parameter. In
simple Mason configurations the component root is the same as the
server's DocumentRoot.  More complex configurations may specify
several different document roots under a single component root.
.PP
When Mason handles a request, the request filename (\f(CW\*(C`$r\->filename\*(C'\fR) must
be underneath your component root \*(-- that way Mason has a legitimate
component to start with.  If the filename is not under the component
root, Mason will place a warning in the error logs and return a 404.
Unfortunately if your component root or document root goes through a
soft link, Mason will have trouble comparing the paths and will return
404. To fix this, set your document root to the true path.
.Sh "Component roots (multiple)"
.IX Subsection "Component roots (multiple)"
If you are just starting out it is probably safe to skip this section initially.
.PP
Starting in Mason 0.8 it is now possible to specify multiple component
roots to be searched in the spirit of Perl's \f(CW\*(C`@INC\*(C'\fR. To do so you must
specify a list of lists:
.PP
.Vb 1
\&    comp_root => [[key1, root1], [key2, root2], ...]
.Ve
Each pair consists of a key and root.  The key is a string that
identifies the root mnemonically to a component developer. Keys
are case-insensitive and must be distinct.
.PP
For example:
.PP
.Vb 1
\&    comp_root => [[private=>'/usr/home/joe/comps'], [main=>'/usr/local/www/htdocs']]
.Ve
This specifies two component roots, a main component tree and a
private tree which overrides certain components.  The order is
respected ala \f(CW\*(C`@INC\*(C'\fR, so \fIprivate\fR is searched first and \fImain\fR second.
(I chose the \f(CW\*(C`=>\*(C'\fR notation here because it looks cleaner, but note that
this is a list of lists, not a hash.)
.PP
The key has several purposes. Object and data cache filenames use the
(uppercased) key to make sure different components sharing the same path have
different cache and object files. For example, if a component /foo/bar
is found in 'private', then the object file will be
.PP
.Vb 1
\&    <data_dir>/obj/PRIVATE/foo/bar
.Ve
and the cache file
.PP
.Vb 1
\&    <data_dir>/cache/PRIVATE+2ffoo+2fbar
.Ve
The key is also included whenever Mason prints the component title, as
in an error message:
.PP
.Vb 2
\&    error while executing /foo/bar [private]:
\&    ...
.Ve
This lets you know which version of the component was running.
.Sh "Data directory"
.IX Subsection "Data directory"
The data directory is where Mason keeps various files to help
implement caching, debugging, etc. You specify a single data directory
via the \f(CW\*(C`data_dir\*(C'\fR parameter and Mason creates subdirectories underneath
it as needed:
.PP
.Vb 5
\& cache:    data cache files
\& debug:    debug files
\& etc:      miscellaneous files
\& obj:      compiled components
\& preview:  preview settings files
.Ve
These directories will be discussed in appropriate sections throughout
this manual.
.Sh "External modules"
.IX Subsection "External modules"
Components will often need access to external Perl modules. Any such
modules that export symbols should be listed in handler.pl, rather
than the standard practice of using a PerlModule configuration
directive. This is because components are executed inside the
\&\fB\s-1HTML:\s0:Mason::Commands\fR package, and can only access symbols exported
to that package. Here's sample module list:
.PP
.Vb 4
\&    { package HTML::Mason::Commands;
\&      use CGI ':standard';
\&      use LWP::UserAgent;
\&      ... }
.Ve
In any case, for optimal memory utilization, make sure all Perl
modules are used in the parent process, and \fInot\fR in
components. Otherwise, each child allocates its own copy and you lose
the benefit of shared memory between parent processes and their
children. See Vivek Khera's mod_perl tuning \s-1FAQ\s0 (perl.apache.org/tuning)
for details.
.Sh "File ownership"
.IX Subsection "File ownership"
Unix web servers that run on privileged ports like 80 start with a root
parent process, then spawn children running as the 'User' and 'Group'
specified in httpd.conf. This difference leads to permission errors
when child processes try to write files or directories created by the
parent process.
.PP
To work around this conflict, Mason remembers all directories and
files created at startup, returning them in response to
\&\f(CW\*(C`interp\->files_written\*(C'\fR. This list can be fed to a \fIchown()\fR at the
end of the startup code in \f(CW\*(C`handler.pl\*(C'\fR:
.PP
.Vb 2
\&    chown (scalar(getpwnam "nobody"), scalar(getgrnam "nobody"),
\&            $interp->files_written);
.Ve
.Sh "Persistent user sessions"
.IX Subsection "Persistent user sessions"
With just a few lines in handler.pl you can make a global hash
(e.g. \fI%session\fR) available to all components containing persistent user
session data.  If you set a value in the hash, you will see the change
in future visits by the same user.  The key piece is Jeffrey Baker's
\&\fBApache::Session\fR module, available from \s-1CPAN\s0.
.PP
The file \fIeg/session_handler.pl\fR in the distribution contains the
lines to activate cookie-based sessions using Apache::Session and
\&\s-1CGI:\s0:Cookie. You can use \fIeg/session_handler.pl\fR as your new handler.pl
base, or just copy out the appropriate pieces to your existing handler.pl.
.PP
The session code is customizable; you can change the user \s-1ID\s0 location
(e.g. \s-1URL\s0 instead of cookie), the user data storage mechanism
(e.g. \s-1DBI\s0 database), and the name of the global hash.
.Sh "Using global variables"
.IX Subsection "Using global variables"
Global variables generally make programs harder to read, maintain, and
debug, and this is no less true for Mason.  Due to the persistent
mod_perl environment, globals require extra initialization and cleanup
care. And the highly modular nature of Mason pages does not mix well
with globals: it is no fun trying to track down which of twenty
components is stepping on your variable. With the ability to pass
parameters and declare lexical (\f(CW\*(C`my\*(C'\fR) variables in components, there
is very little need for globals at all.
.PP
That said, there are times when it is very useful to make a value
available to all Mason components: a \s-1DBI\s0 database handler, a hash of
user session information, the server root for forming absolute URLs.
Usually you initialize the global in your handler.pl, either outside
the \fIhandler()\fR subroutine (if you only need to set it once) or inside
(if you need to set it every request).
.PP
Mason by default parses components in \f(CW\*(C`strict\*(C'\fR mode, so you can't
simply start referring to a new global or you'll get a fatal
warning. The solution is to invoke \f(CW\*(C`use vars\*(C'\fR inside the
package that components execute in, by default \fB\s-1HTML:\s0:Mason::Commands\fR:
.PP
.Vb 3
\&    { package HTML::Mason::Commands;
\&      use vars qw($dbh %session);
\&    }
.Ve
Alternatively you can use the Parser/allow_globals parameter or method:
.PP
.Vb 2
\&    my $parser = new HTML::Mason::Parser (..., allow_globals => [qw($dbh %session)]);
\&    $parser->allow_globals(qw($foo @bar))
.Ve
The only advantage to \f(CW\*(C`allow_globals\*(C'\fR is that it will do
the right thing if you've chosen a different package for components
to run in (via the Parser/in_package Parser parameter.)
.PP
Similarly, to initialize the variable in handler.pl, you need to
set it in the component package:
.PP
.Vb 1
\&   $HTML::Mason::Commands::dbh = DBI->connect(...);
.Ve
Alternatively you can use the Interp/set_global Interp method:
.PP
.Vb 1
\&    $interp->set_global(dbh => DBI->connect(...));
.Ve
Again, \f(CW\*(C`set_global\*(C'\fR will do the right thing if you've chosen a
different package for components.
.PP
Now when referring to these globals inside components, you can use the
plain variable name:
.PP
.Vb 1
\&    $dbh->prepare...
.Ve
.Sh "Declining image requests"
.IX Subsection "Declining image requests"
Mason should be prevented from serving images, tarballs, and other
binary files as regular components. Such a file may inadvertently
contain a Mason character sequence such as \*(L"<%\*(R", causing an error.
.PP
There are several ways to restrict which file types are handled by Mason.
One way is with a line at the top of \fIhandler()\fR, e.g.:
.PP
.Vb 1
\&    return -1 if $r->content_type && $r->content_type !~ m|^text/|i;
.Ve
This line allows text/html and text/plain to pass through but not much
else.  It is included (commented out) in the default handler.pl.
.PP
Another way is specifying a filename pattern in the Apache
configuration, e.g.:
.PP
.Vb 4
\&    <FilesMatch "(\e.html|\e.txt|^[^\e.]+)$>
\&    SetHandler perl-script
\&    PerlHandler HTML::Mason
\&    </FilesMatch>
.Ve
This directs Mason to handle only files with .html, .txt, or no extension.
.Sh "Securing top-level components"
.IX Subsection "Securing top-level components"
Users may exploit a server-side scripting environment by invoking
scripts with malicious or unintended arguments. Mason administrators
need to be particularly wary of this because of the tendency to break
out \*(L"subroutines\*(R" into individually accessible file components.
.PP
For example, a Mason developer might create a helpful shared component
for performing sql queries:
.PP
.Vb 1
\&    $m->comp('sql_select', table=>'employee', where=>'id=315');
.Ve
This is a perfectly reasonable component to create and call internally,
but clearly presents a security risk if accessible via \s-1URL:\s0
.PP
.Vb 1
\&    http://www.foo.com/sql_select?table=credit_cards&where=*
.Ve
Of course a web user would have to obtain the name of this component
through guesswork or other means, but obscurity alone does not
properly secure a system.  Rather, you should choose a site-wide
policy for distinguishing top-level components from private
components, and make sure your developers stick to this policy. You
can then prevent private components from being served.
.PP
One solution is to place all private components inside a directory,
say /private, that lies under the component root but outside the
document root.
.PP
Another solution is to decide on a naming convention, for example,
that all private components begin with \*(L"_\*(R", or that all top-level
components must end in \*(L".html\*(R". Then turn all private requests away
with a 404 \s-1NOT_FOUND\s0 (rather than, say, a 403 \s-1FORBIDDEN\s0 which would
provide more information than necessary). Use either an Apache directive
.PP
.Vb 4
\&    <FilesMatch "^_">
\&    SetHandler perl-script
\&    PerlHandler "sub { return 404 }"
\&    </FilesMatch>
.Ve
or a handler.pl directive:
.PP
.Vb 1
\&    return 404 if $r->filename =~ m{_[^/]+$};
.Ve
Even after you've safely protected internal components, top-level
components that process arguments (such as form handlers) still
present a risk. Users can invoke such a component with arbitrary
argument values via a handcrafted query string. Always check incoming
arguments for validity and never place argument values directly into
\&\s-1SQL\s0, shell commands, etc. Unfortunately, Mason does not yet work with
with Perl's taint checking which would help ensure these principles.
.Sh "Allowing directory requests"
.IX Subsection "Allowing directory requests"
By default Mason will decline requests for directories, leaving Apache
to serve up a directory index or a \s-1FORBIDDEN\s0 as appropriate.
Unfortunately this rule applies even if there is a dhandler in the
directory: /foo/bar/dhandler does not get a chance to
handle a request for /foo/bar.
.PP
If you would like Mason to handle directory requests, do the
following:
.PP
1. Set the ApacheHandler/decline_dirs ApacheHandler parameter to 0.
.PP
2. If your handler.pl contains the standard \*(L"return \-1\*(R" line to
decline non-text requests (as given in the previous section), add a
clause allowing directory types:
.PP
.Vb 2
\&    return -1 if $r->content_type && $r->content_type !~ m|^text/|i
\&                 && $r->content_type !~ m|directory$|i;
.Ve
The dhandler that catches a directory request is responsible for
setting a reasonable content type.
.SH "STANDARD FEATURES"
.IX Header "STANDARD FEATURES"
This section explains how standard Mason features work and how to
administer them.
.Sh "Data caching"
.IX Subsection "Data caching"
.Ip "Setup" 4
.IX Item "Setup"
Cache files are implemented using \fB\s-1MLDBM\s0\fR, an interface for storing
persistent multi-level data structures. \fB\s-1MLDBM\s0\fR, in turn, uses one of
several \s-1DBM\s0 packages (\fBDB_File\fR, \fB\s-1GDBM\s0\fR) and one of several
serialization mechanisms (\fBData::Dumper\fR, \fBFreezeThaw\fR or
\&\fBStorable\fR). Mason's Config.pm controls which packages are used.
.Sp
The most important task is selecting a good \s-1DBM\s0 package.  Most
standard \s-1DBM\s0 packages (\fB\s-1SDBM\s0\fR, \fB\s-1ODBM\s0\fR, \fB\s-1NDBM\s0\fR) are unsuitable for
data caching due to significant limitations on the size of keys and
values. Perl only comes with \fB\s-1SDBM\s0\fR, so you'll need to obtain a
good-quality package if you haven't already. At this time the best
options are Berkeley \s-1DB\s0 (\fBDB_File\fR) version 2.x, available at
www.sleepycat.com, and \s-1GNU\s0's gdbm (\fB\s-1GDBM\s0\fR), available at \s-1GNU\s0 mirror
sites everywhere. Stay away from Berkeley \s-1DB\s0 version 1.x on Linux
which has a serious memory leak (and is unfortunately pre-installed on
many distributions).
.Sp
As far as the serialization methods, all of them should work
fine. \fBData::Dumper\fR is probably simplest: it comes with the latest
versions of Perl, is required by Mason anyway, and produces readable
output (possibly useful for debugging cache files).  On the other hand
\&\fBStorable\fR is significantly faster than the other options according
to the \s-1MLDBM\s0 documentation.
.Sp
Data caching will not work on systems lacking \fIflock()\fR, such as Windows
95 and 98.
.Ip "Administration" 4
.IX Item "Administration"
Once set up, data caching requires little administration. When a
component calls \f(CW\*(C`$m\->cache\*(C'\fR or \f(CW\*(C`$m\->cache_self\*(C'\fR for the first time,
Mason automatically creates a new cache file under \f(CW\*(C`data_dir/cache\*(C'\fR.
The name of the file is determined by encoding the path as follows:
.Sp
.Vb 1
\&    s/([^\ew\e.\e-\e~])/sprintf('+%02x', ord $1)/eg;
.Ve
like \s-1URL\s0 encoding with a '+' escape character. For example, the
cache file for component \f(CW\*(C`/foo/bar\*(C'\fR is \f(CW\*(C`data_dir/cache/foo+2fbar\*(C'\fR.
.Sp
Currently Mason never deletes cache files, not even when the
associated component file is modified.  (This may change in the near future.)
Thus cache files hang around and grow indefinitely.  You may want to
use a cron job or similar mechanism to delete cache files that get too
large or too old.  For example:
.Sp
.Vb 4
\&    # Shoot cache files more than 30 days old
\&    foreach (<data_dir/cache>) {    # path to cache directory
\&        unlink $_ if (-M >= 30);
\&    }
.Ve
In general you can feel free to delete cache files periodically and
without warning, because the data cache mechanism is explicitly not
guaranteed \*(-- developers are warned that cached data may disappear
anytime and components must still function.
.Sp
If some reason you want to disable data caching, specify
\&\f(CW\*(C`use_data_cache\*(C'\fR=>0 to the Interp object. This will cause all \f(CW\*(C`$m\->cache\*(C'\fR
calls to return undef without doing anything.
.Sh "Debugging"
.IX Subsection "Debugging"
A debug file is a Perl script that creates a fake Apache request
object (\f(CW\*(C`$r\*(C'\fR) and calls the same PerlHandler that Apache called.
Debug files are created under \f(CW\*(C`data_dir/debug/<username>\*(C'\fR for
authenticated users, otherwise they are placed in
\&\f(CW\*(C`data_dir/debug/anon\*(C'\fR.  Several ApacheHandler parameters are required
to activate and configure debug files:
.Ip "debug_mode" 4
.IX Item "debug_mode"
The debug_mode parameter indicates which requests should produce a
debug file: \*(L"all\*(R", \*(L"none\*(R", or \*(L"error\*(R" (only if a error occurs).
.Ip "debug_perl_binary" 4
.IX Item "debug_perl_binary"
The full path to your Perl binary \*(-- e.g. \f(CW\*(C`/usr/bin/perl\*(C'\fR. This is
used in the Unix \*(L"shebang\*(R" line at the top of each debug file.
.Ip "debug_handler_script" 4
.IX Item "debug_handler_script"
The full path to your \f(CW\*(C`handler.pl\*(C'\fR script. Debug files invoke
\&\f(CW\*(C`handler.pl\*(C'\fR just as Apache does as startup, to load needed modules
and create Mason objects.
.Ip "debug_handler_proc" 4
.IX Item "debug_handler_proc"
The name of the request handler defined in \f(CW\*(C`handler.pl\*(C'\fR. This routine
is called with the saved Apache request object.
.PP
Here's a sample \f(CW\*(C`ApacheHandler\*(C'\fR constructor with all debug options:
.PP
.Vb 5
\&    my $ah = new HTML::Mason::ApacheHandler (interp=>$interp,
\&               debug_mode=>'all',
\&               debug_perl_binary=>'/usr/local/bin/perl',
\&               debug_handler_script=>'/usr/local/mason/eg/handler.pl',
\&               debug_handler_proc=>'HTML::Mason::handler');
.Ve
When replaying a request through a debug file, the global variable
\&\f(CW\*(C`$HTML::Mason::IN_DEBUG_FILE\*(C'\fR will be set to 1.  This is useful if you
want to omit certain flags (like preloading) in handler.pl when
running under debug.  For example:
.PP
.Vb 2
\&    my %extra_flags = ($HTML::Mason::IN_DEBUG_FILE) ? () : (preloads=>[...]);
\&    my $interp = new HTML::Mason::Interp (..., %extra_flags);
.Ve
.Sh "Previewer"
.IX Subsection "Previewer"
The previewer is a web based utility that allows site developers to:
.Ip "1." 4
View a site under a variety of simulated client conditions: browser,
operating system, date, time of day, referer, etc.
.Ip "2." 4
View a debug trace of a page, showing the component call tree and
indicating which parts of the page are generated by which components.
.PP
The web-based previewer interface (a single component, actually)
allows the developer to select a variety of options such as time,
browser, and display mode.  The set of these options together is
called a previewer configuration. Configurations can be saved under
one of several preview ports. For more information on how the
previewer is used, see \fB\s-1HTML:\s0:Mason::Devel\fR.
.PP
Follow these steps to activate the Previewer:
.Ip "1." 4
Choose a set of preview ports, for example, 3001 to 3005.
.Ip "2." 4
In httpd.conf, put a Listen in for each port.  E.g.
.Sp
.Vb 3
\&  Listen your.site.ip.address:3001
\&  ...
\&  Listen your.site.ip.address:3005
.Ve
You'll also probably want to restrict access to these ports in your
access.conf. If you have multiple site developers, it is helpful to
use username/password access control, since the previewer will use the
username to keep configurations separate.
.Ip "3." 4
In your \f(CW\*(C`handler.pl\*(C'\fR, add the line
.Sp
.Vb 1
\&    use HTML::Mason::Preview;
.Ve
somewhere underneath \*(L"use \s-1HTML:\s0:Mason\*(R". Then add code to your handler
routine to intercept Previewer requests on the ports defined
above. Your handler should end up looking like this:
.Sp
.Vb 2
\&    sub handler {
\&        my ($r) = @_;
.Ve
.Vb 4
\&        # Compute port number from Host header
\&        my $host = $r->header_in('Host');
\&        my ($port) = ($host =~ /:([0-9]+)$/);
\&        $port = 80 if (!defined($port));
.Ve
.Vb 10
\&        # Handle previewer request on special ports
\&        if ($port >= 3001 && $port <= 3005) {
\&            my $parser = new HTML::Mason::Parser(...);
\&            my $interp = new HTML::Mason::Interp(...);
\&            my $ah = new HTML::Mason::ApacheHandler (...);
\&            return HTML::Mason::Preview::handle_preview_request($r,$ah);
\&        } else {
\&            $ah->handle_request($r);    # else, normal request handler
\&        }
\&    }
.Ve
The three \*(L"new\*(R" lines inside the if block should look exactly the same
as the lines at the top of \f(CW\*(C`handler.pl\*(C'\fR. Note that these separate
Mason objects are created for a single request and discarded. The
reason is that the previewer may alter the objects' settings, so it is
safer to create new ones every time.
.Ip "4." 4
Copy the Previewer component (\*(L"samples/preview\*(R") to your component
root (you may want to place it at the top level so that
http://www.yoursite.com/preview calls up the previewer interface).
Edit the \*(L"\s-1CONFIGURATION\s0\*(R" block at the top to conform to your own Mason
setup.
.PP
To test whether the previewer is working: restart your server, go to the
previewer interface, and click \*(L"View\*(R".  You should see your site's home page.
.Sh "System logs"
.IX Subsection "System logs"
Mason will log various events to a system log file if you so desire.
This can be useful for performance monitoring and debugging.
.PP
The format of the system log was designed to be easy to parse by
programs, although it is not unduly hard to read for humans.  Every
event is logged on one line. Each line consists of multiple fields
delimited by a common separator, by default ctrl-A. The first three
fields are always the same: time, the name of the event, and the
current pid ($$).  These are followed by one or more fields specific
to the event.
.PP
The events are:
.PP
.Vb 1
\& EVENT NAME     DESCRIPTION                     EXTRA FIELDS
.Ve
.Vb 8
\& REQ_START      start of HTTP request           request number, URL + query string
\& REQ_END        end of HTTP request             request number, error flag (1 if
\&                                                error occurred, 0 otherwise)
\& CACHE_READ     attempt to read from            component path, cache key, success
\&                data cache (C<$m-E<gt>cache>)   flag (1 if item found, 0 otherwise)
\& CACHE_STORE    store to data cache             component path, cache key
\& COMP_LOAD      component loaded into memory    component path
\&                for first time
.Ve
The request number is an incremental value that uniquely identifies
each request for a given child process. Use it to match up
\&\s-1REQ_START/REQ_END\s0 pairs.
.PP
To turn on logging, specify a string value to \f(CW\*(C`system_log_events\*(C'\fR
containing one or more event names separated by '|'. In additional to
individual event names, the following names can be used to specify
multiple events:
.PP
.Vb 3
\& REQUEST = REQ_START | REQ_END
\& CACHE = CACHE_READ | CACHE_STORE
\& ALL = All events
.Ve
For example, to log \s-1REQ_START\s0, \s-1REQ_END\s0, and \s-1COMP_LOAD\s0 events, you could use
    system_log_events => \*(L"REQUEST|COMP_LOAD\*(R"
Note that this is a string, not a set of constants or'd together.
.PP
\&\fBConfiguration Options\fR
.PP
By default, the system log will be placed in
data_dir/etc/system.log. You can change this with \f(CW\*(C`system_log_file\*(C'\fR.
.PP
The default line separator is ctrl-A. The advantage of this separator
is that it is very unlikely to appear in any of the fields, making it
easy to \fIsplit()\fR the line.  The disadvantage is that it will not always
display, e.g. from a Unix shell, making the log harder to read
casually.  You can change the separator to any sequence of characters
with \f(CW\*(C`system_log_separator\*(C'\fR.
.PP
The time on each log line will be of the form \*(L"seconds.microseconds\*(R"
if you are using Time::HiRes, and simply \*(L"seconds\*(R" otherwise.  See
\&\f(CW\*(C`Config.pm\*(C'\fR section.
.PP
\&\fBSample Log Parser\fR
.PP
Here is a code skeleton for parsing the various events in a log.  You
can also find this in \fIeg/parselog.pl\fR in the Mason distribution.
.PP
.Vb 24
\&   open(LOG,"mason.log");
\&   while (<LOG>) {
\&       chomp;
\&       my (@fields) = split("\ecA");
\&       my ($time,$event,$pid) = splice(@fields,0,3);
\&       if ($event eq 'REQ_START') {
\&           my ($reqnum,$url) = @fields;
\&           ...
\&       } elsif ($event eq 'REQ_END') {
\&           my ($reqnum,$errflag) = @fields;
\&           ...
\&       } elsif ($event eq 'CACHE_READ') {  
\&           my ($comp,$key,$hitflag) = @fields;
\&           ...
\&       } elsif ($event eq 'CACHE_STORE') { 
\&           my ($comp,$key) = @fields;
\&           ...
\&       } elsif ($event eq 'COMP_LOAD') {
\&           my ($comp) = @fields;
\&           ...
\&       } else {
\&           warn "unrecognized event type: $event\en";
\&       }
\&   }
.Ve
\&\fBSuggested Uses\fR
.PP
Performance: \s-1REQUEST\s0 events are useful for analyzing the performance
of all Mason requests occurring on your site, and identifying the
slowest requests. \fIeg/perflog.pl\fR in the Mason distribution is a log
parser that outputs the average compute time of each unique \s-1URL\s0, in
order from slowest to quickest.
.PP
Server activity: \s-1REQUEST\s0 events are useful for determining what
your web server children are working on, especially when you have a
runaway.  For a given process, simply tail the log and find the last
\&\s-1REQ_START\s0 event with that process id. (You can also use the Apache
status page for this.)
.PP
Cache efficiency: \s-1CACHE\s0 events are useful for monitoring cache \*(L"hit
rates\*(R" (number of successful reads over total number of reads) over
all components that use a data cache.  Because stores to a cache are
more expensive than reads, a high hit rate is essential for the cache
to have a beneficial effect. If a particular cache hit rate is too
low, you may want to consider changing how frequently it is expired or
whether to use it at all.
.PP
Load frequency: \s-1COMP_LOAD\s0 events are useful for monitoring your code
cache. Too many loads may indicate that your code cache is too small.
Also, if you can turn off the code cache for a short time, \s-1COMP_LOAD\s0
events will tell you which components are loaded most often and thus
good candidates for preloading.
.SH "PERFORMANCE TUNING"
.IX Header "PERFORMANCE TUNING"
This section explains Mason's various performance enhancements and how
to administer them.
.Sh "Code cache"
.IX Subsection "Code cache"
When Mason loads a component, it places it in a memory cache.
.PP
The maximum size of the cache is specified with the
Interp/code_cache_max_size Interp parameter; default is 10MB.
When the cache fills up, Mason frees up space by discarding a
number of components. The discard algorithm is least frequently used
(\s-1LFU\s0), with a periodic decay to gradually eliminate old frequency
information. In a nutshell, the components called most often in recent
history should remain in the cache.  Very large components (over 20%
of the maximum cache size) never get cached, on the theory that they
would force out too many other components.
.PP
Note that the \*(L"size\*(R" of a component in memory cannot literally be
measured.  It is estimated by the length of the source text plus some
overhead.  Your process growth will not match the code cache
size exactly.
.PP
You can monitor the performance of the memory cache by turning on
system logs and counting the \s-1COMP_LOAD\s0 events. If these are
occurring frequently even for a long-running process, you may want to
increase the size of your code cache.
.PP
You can prepopulate the cache with components that you know will be
accessed often; see Preloading. Note that preloaded components
possess no special status in the cache and can be discarded like any
others.
.PP
Naturally, a cache entry is invalidated if the corresponding component
source file changes.
.PP
To turn off code caching completely, set Interp/code_cache_max_size to
0.
.Sh "Object files"
.IX Subsection "Object files"
The in-memory code cache is only useful on a per-process basis.  Each
process must build and maintain its own cache. Shared memory caches
are conceivable in the future, but even those will not survive between
web server restarts.
.PP
As a secondary, longer-term cache mechanism, Mason stores a compiled
form of each component in an object file under
\&\f(CW\*(C`data_dir/obj/\f(CIcomponent-path\f(CW\*(C'\fR. Any server process can eval the
object file and save time on parsing the component source file.  The
object file is recreated whenever the source file changes.
.PP
Besides improving performance, object files are essential for
debugging and interpretation of errors.  Line numbers in error
messages are given in terms of the object file. The curious-minded can
peek inside an object file to see exactly how Mason converted
a given component to a Perl object.
.PP
If you change any Parser options, you must remove object files
previously created under that parser for the changes to take effect.
.PP
If for some reason you don't want Mason to create object files, set
the Interp/use_object_files Interp parameter to 0.
.Sh "Preloading"
.IX Subsection "Preloading"
You can tell Mason to preload a set of components in the parent
process, rather than loading them on demand, using the
Interp/preloads Interp parameter.  Each child server will start
with those components loaded in the memory cache. The trade-offs are:
.Ip "time" 4
.IX Item "time"
a small one-time startup cost, but children save time by not
having to load the components
.Ip "memory" 4
.IX Item "memory"
a fatter initial server, but the memory for preloaded components are
shared by all children.  This is similar to the advantage of using
modules only in the parent process.
.PP
Try to preload components that are used frequently and do not change
often.  (If a preloaded component changes, all the children will have
to reload it from scratch.)
.Sh "Reload file"
.IX Subsection "Reload file"
Normally, every time Mason executes a component, it checks the last
modified time of its source file to see if it needs to be reloaded.
These file checks are convenient for development, but for a production
site they degrade performance unnecessarily.
.PP
To remedy this, Mason has an accelerated mode that changes its
behavior in two ways:
.PP
1.  Does not check component source files at all, relying solely on
object files.  This means the developer or an automated system is
responsible for recompiling any components that change and recreating
object files, using the Parser/make_component Parser method.
.PP
2.  Rather than continuously checking whether object files have
changed, Mason monitors a \*(L"reload file\*(R" containing an ever-growing
list of components that have changed.  Whenever a component changes,
the developer or an automated system is responsible for appending the
component path to the reload file. The reload file is kept in
\&\f(CW\*(C`data_dir/etc/reload.lst\*(C'\fR.
.PP
You can activate this mode with the Interp/use_reload_file
Interp method.
.PP
The advantage of using this mode is that Mason stats one file per
request instead of ten or twenty.  The disadvantage is a
increase in maintenance costs as the object and reload files have to
be kept up-to-date.  Automated editorial tools, and cron jobs that
periodically scan the component hierarchy for changes, are two
possible solutions.  The Mason content management system automatically
handles this task.
.SH "STAGING vs. PRODUCTION"
.IX Header "STAGING vs. PRODUCTION"
Site builders often maintain two versions of their sites: the
production (published) version visible to the world, and the
development (staging) version visible internally.  Developers try out
changes on the staging site and push the pages to production once they
are satisfied.
.PP
The priorities for the staging site are rapid development and easy
debugging, while the main priority for the production site is
performance. This section describes various ways to adapt Mason for
each case.
.Sh "Out mode"
.IX Subsection "Out mode"
Mason can spew data in two modes. In \*(L"batch\*(R" mode Mason computes the
entire page in a memory buffer and then transmits it all at once. In
\&\*(L"stream\*(R" mode Mason outputs data as soon as it is computed. (This does
not take into account buffering done by Apache or the O/S.) The default
mode is \*(L"batch\*(R".
.PP
Batch mode has the advantage of better error handling.  Suppose an
error occurs in the middle of a page. In stream mode, the error
message interrupts existing output, often appearing in an awkward \s-1HTML\s0
context such as the middle of a table which never gets closed. In batch
mode, the error message is output neatly and alone.
.PP
Batch mode also offers more flexibility in controlling \s-1HTTP\s0
headers (see Devel/sending_http_headers) and in handling
mid-request error conditions (see Request/clear_buffer).
.PP
Stream mode may help get data to the browser more quickly, allowing
server and browser to work in parallel. It also prevents memory
buildup for very large responses.
.PP
Since Apache does its own buffering, stream mode does not entail
immediate delivery of output to the client. You must set $|=1 to turn
off Apache buffering completely (generally not a good idea) or call
\&\f(CW\*(C`$m\->flush_buffer\*(C'\fR to flush the buffer selectively.
.PP
In terms of making your server seem responsive, the initial bytes are
most important.  You can send these early by calling \f(CW\*(C`$m\->flush_buffer\*(C'\fR
in key locations such as the common page header. However, this dilutes
the advantages of batch mode mentioned above. Tradeoffs...
.PP
You control output mode by setting \f(CW\*(C`interp\->out_mode\*(C'\fR to \*(L"batch\*(R"
or \*(L"stream\*(R".
.Sh "Error mode"
.IX Subsection "Error mode"
When an error occurs, Mason can respond by:
.Ip "\(bu" 4
showing a detailed error message in the browser
.Ip "\(bu" 4
die'ing, which sends a 501 to the browser and lets the error message go to the
error logs.
.PP
The first option is ideal for development, where you want
immediate feedback on the error.  The second option is usually desired
for production so that users are not exposed to messy error messages.
You control this option by setting ah->error_mode to \*(L"html\*(R" or \*(L"fatal\*(R"
respectively.
.Sh "Debug mode"
.IX Subsection "Debug mode"
As discussed in the debugging section, you can control when Mason
creates a debug file.  While creating a debug file is not incredibly
expensive, it does involves a bit of work and the creation of a new
file, so you probably want to avoid doing it on every request to a
frequently visited site.  I recommend setting debug_mode to 'all' in
development, and 'error' or 'none' in production.
.Sh "Reload files"
.IX Subsection "Reload files"
Consider reload files only for frequently visited production sites.
.SH "CONFIGURING VIRTUAL SITES"
.IX Header "CONFIGURING VIRTUAL SITES"
These examples extend the Mason/single site configuration
example in \fB\s-1HTML:\s0:Mason\fR.
.Sh "Multiple sites, one component root"
.IX Subsection "Multiple sites, one component root"
If you want to share some components between your sites, arrange your
httpd.conf so that all DocumentRoots live under a single component space:
.PP
.Vb 2
\&    # httpd.conf
\&    PerlRequire /usr/local/mason/handler.pl
.Ve
.Vb 8
\&    # Web site #1
\&    <VirtualHost www.site1.com>
\&        DocumentRoot /usr/local/www/htdocs/site1
\&        <Location />
\&            SetHandler perl-script
\&            PerlHandler HTML::Mason
\&        </Location>
\&    </VirtualHost>
.Ve
.Vb 8
\&    # Web site #2
\&    <VirtualHost www.site2.com>
\&        DocumentRoot /usr/local/www/htdocs/site2
\&        <Location />
\&            SetHandler perl-script
\&            PerlHandler HTML::Mason
\&        </Location>
\&    </VirtualHost>
.Ve
In handler.pl:
.PP
.Vb 3
\&    my $interp = new HTML::Mason::Interp (parser=>$parser,
\&                    comp_root=>'/usr/local/www/htdocs'
\&                    data_dir=>'/usr/local/mason/');
.Ve
The directory structure for this scenario might look like:
.PP
.Vb 4
\&    /usr/local/www/htdocs/  # component root
\&        +- shared/          # shared components
\&        +- site1/           # DocumentRoot for first site
\&        +- site2/           # DocumentRoot for second site
.Ve
Incoming URLs for each site can only request components in their
respective DocumentRoots, while components internally can call other
components anywhere in the component space. The shared/ directory
is a private directory for use by components, inaccessible from
the Web.
.Sh "Multiple sites, multiple component roots"
.IX Subsection "Multiple sites, multiple component roots"
Sometimes your sites need to have completely distinct component
hierarchies, e.g. if you are providing Mason \s-1ISP\s0 services for multiple
users. In this case the component root must change depending on the
site requested. Since you can't change an interpreter's component root
dynamically, you need to maintain separate Mason objects for each
site in the handler.pl:
.PP
.Vb 5
\&    my (%interp,%ah);
\&    foreach my $site qw(...) {
\&        $interp{$site} = new HTML::Mason::Interp  (comp_root=>"/usr/local/www/$site",...);
\&        $ah{$site} = new HTML::Mason::ApacheHandler (interp=>$interp{$site},...);
\&    }
.Ve
.Vb 1
\&    ...
.Ve
.Vb 4
\&    sub handler {
\&        my $site = $r->dir_config('site');
\&        $ah{$site}->handle_request($r);
\&    }
.Ve
We assume each virtual server configuration section has a
.PP
.Vb 1
\&    PerlSetVar site <site_name>
.Ve
Above we pre-create all Mason objects in the parent. Another scheme is to
create objects on demand in the child:
.PP
.Vb 1
\&    my (%interp,%ah);
.Ve
.Vb 1
\&    ...
.Ve
.Vb 9
\&    sub handler {
\&        my $site = $r->dir_config('site');
\&        unless exists($interp{$site}) {
\&            # get comp_root from PerlSetVar as well
\&            my $comp_root = $r->dir_config('comp_root');
\&            $interp{$site} = new HTML::Mason::Interp(comp_root=>$comp_root,...);
\&            $ah{$site} = new HTML::Mason::ApacheHandler(interp=>$interp{$site},...);
\&        }
\&    }
.Ve
The advantage of the second scheme is that you don't have to hardcode
as much information in the handler.pl. The disadvantage is a slight
memory and performance impact. On development servers this shouldn't
matter; on production servers you may wish to profile the two schemes.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jonathan Swartz, swartz@pobox.com
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1HTML:\s0:Mason,
\&\s-1HTML:\s0:Mason::Parser,
\&\s-1HTML:\s0:Mason::Interp,
\&\s-1HTML:\s0:Mason::ApacheHandler
