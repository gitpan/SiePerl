.\" Automatically generated by Pod::Man version 1.15
.\" Mon Apr 23 08:19:54 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "Carp::Assert 3"
.TH Carp::Assert 3 "perl v5.6.1" "2001-02-09" "User Contributed Perl Documentation"
.UC
.SH "NAME"
Carp::Assert \- executable comments
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    # Assertions are on.
\&    use Carp::Assert;
.Ve
.Vb 1
\&    $next_sunrise_time = sunrise();
.Ve
.Vb 2
\&    # Assert that the sun must rise in the next 24 hours.
\&    assert(($next_sunrise_time - time) < 24*60*60) if DEBUG;
.Ve
.Vb 2
\&    # Assertions are off.
\&    no Carp::Assert;
.Ve
.Vb 1
\&    $next_pres = divine_next_president();
.Ve
.Vb 4
\&    # Assert that if you predict Dan Quayle will be the next president
\&    # your crystal ball might need some polishing.  However, since
\&    # assertions are off, IT COULD HAPPEN!
\&    shouldnt($next_pres, 'Dan Quayle') if DEBUG;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.Vb 3
\&    "We are ready for any unforseen event that may or may not 
\&    occur."
\&        - Dan Quayle
.Ve
Carp::Assert is intended for a purpose like the \s-1ANSI\s0 C library
assert.h.  If you're already familiar with assert.h, then you can
probably skip this and go straight to the \s-1FUNCTIONS\s0 section.
.PP
Assertions are the explict expressions of your assumptions about the
reality your program is expected to deal with, and a declaration of
those which it is not.  They are used to prevent your program from
blissfully processing garbage inputs (garbage in, garbage out becomes
garbage in, error out) and to tell you when you've produced garbage
output.  (If I was going to be a cynic about Perl and the user nature,
I'd say there are no user inputs but garbage, and Perl produces
nothing but...)
.PP
An assertion is used to prevent the impossible from being asked of
your code, or at least tell you when it does.  For example:
.PP
.Vb 3
\&    # Take the square root of a number.
\&    sub my_sqrt {
\&        my($num) = shift;
.Ve
.Vb 2
\&        # the square root of a negative number is imaginary.
\&        assert($num >= 0);
.Ve
.Vb 2
\&        return sqrt $num;
\&    }
.Ve
The assertion will warn you if a negative number was handed to your
subroutine, a reality the routine has no intention of dealing with.
.PP
An assertion should also be used a something of a reality check, to
make sure what your code just did really did happen:
.PP
.Vb 3
\&    open(FILE, $filename) || die $!;
\&    @stuff = <FILE>;
\&    @stuff = do_something(@stuff);
.Ve
.Vb 2
\&    # I should have some stuff.
\&    assert(scalar(@stuff) > 0);
.Ve
The assertion makes sure you have some \f(CW@stuff\fR at the end.  Maybe the
file was empty, maybe \fIdo_something()\fR returned an empty list... either
way, the \fIassert()\fR will give you a clue as to where the problem lies,
rather than 50 lines down when you print out \f(CW@stuff\fR and discover it to
be empty.
.PP
Since assertions are designed for debugging and will remove themelves
from production code, your assertions should be carefully crafted so
as to not have any side-effects, change any variables or otherwise
have any effect on your program.  Here is an example of a bad
assertation:
.PP
.Vb 1
\&    assert($error = 1 if $king ne 'Henry');  # Bad!
.Ve
It sets an error flag which may then be used somewhere else in your
program. When you shut off your assertions with the \f(CW$DEBUG\fR flag,
\&\f(CW$error\fR will no longer be set.
.PP
Here's another bad example:
.PP
.Vb 1
\&    assert($next_pres ne 'Dan Quayle' or goto Canada);  # Bad!
.Ve
This assertion has the side effect of moving to Canada should it fail.
This is a very bad assertion since error handling should not be
placed in an assertion, nor should it have side-effects.
.PP
In short, an assertion is an executable comment.  For instance, instead
of writing this
.PP
.Vb 2
\&    # $life ends with a '!'
\&    $life = begin_life();
.Ve
you'd replace the comment with an assertion which \fBenforces\fR the comment.
.PP
.Vb 2
\&    $life = begin_life();
\&    assert( $life =~ /!$/ );
.Ve
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.Ip "\fBassert\fR" 4
.IX Item "assert"
.Vb 1
\&    assert(STATEMENT) if DEBUG;
.Ve
assert's functionality is effected by compile time value of the \s-1DEBUG\s0
constant.  If \s-1DEBUG\s0 is true, assert will function as below.  If \s-1DEBUG\s0
is false the assert function will compile itself out of the program.
See the Debugging vs Production entry elsewhere in this document for details.
.Sp
Give assert an expression, assert will \fICarp::confess()\fR if that
expression is false, otherwise it does nothing.  (\s-1DO\s0 \s-1NOT\s0 use the
return value of assert for anything, I mean it... really!).
.Sp
The error from assert will look something like this:
.Sp
.Vb 3
\&    Assert failed
\&            Carp::Assert::assert(0) called at prog line 23
\&            main::foo called at prog line 50
.Ve
Indicating that in the file \*(L"prog\*(R" an assert failed inside the
function \fImain::foo()\fR on line 23 and that \fIfoo()\fR was in turn called from
line 50 in the same file.
.Ip "\fBshould\fR" 4
.IX Item "should"
.PD 0
.Ip "\fBshouldnt\fR" 4
.IX Item "shouldnt"
.PD
.Vb 2
\&    should  ($this, $shouldbe)   if DEBUG;
\&    shouldnt($this, $shouldntbe) if DEBUG;
.Ve
Similar to \fIassert()\fR, it is specially for simple \*(L"this should be that\*(R"
or \*(L"this should be anything but that\*(R" style of assertions.
.Sp
Due to Perl's lack of a good macro system, \fIassert()\fR can only report
where something failed, but it can't report \fIwhat\fR failed or \fIhow\fR.
\&\fIshould()\fR and \fIshouldnt()\fR can produce more informative error messages:
.Sp
.Vb 3
\&    Assert failed:  'this' should be 'that'!
\&            Carp::Assert::should('this', 'that') called at moof line 29
\&            main::foo() called at moof line 58
.Ve
So this:
.Sp
.Vb 1
\&    should($this, $that) if DEBUG;
.Ve
is similar to this:
.Sp
.Vb 1
\&    assert($this eq $that) if DEBUG;
.Ve
except for the better error message.
.Sp
Currently, \fIshould()\fR and \fIshouldnt()\fR can only do simple eq and ne tests
(respectively).  Future versions may allow regexes.
.SH "Debugging vs Production"
.IX Header "Debugging vs Production"
Because assertions are extra code and because it is sometimes necessary to
place them in 'hot' portions of your code where speed is paramount,
Carp::Assert provides the option to remove its \fIassert()\fR calls from your
program.
.Sp
So, we provide a way to force Perl to inline the switched off \fIassert()\fR
routine, thereby removing almost all performance impact on your production
code.
.Sp
.Vb 2
\&    no Carp::Assert;  # assertions are off.
\&    assert(1==1) if DEBUG;
.Ve
\&\s-1DEBUG\s0 is a constant set to 0.  Adding the 'if \s-1DEBUG\s0' condition on your
\&\fIassert()\fR call gives perl the cue to go ahead and remove \fIassert()\fR call from
your program entirely, since the if conditional will always be false.
.Sp
(This is the best I can do without requiring Filter::cpp)
.Sp
Another way to switch off all asserts, system wide, is to define the
\&\s-1NDEBUG\s0 or the \s-1PERL_NDEBUG\s0 environment variable.
.Sp
You can safely leave out the \*(L"if \s-1DEBUG\s0\*(R" part, but then your \fIassert()\fR function
will always execute (and its arguments evaluated).  Oh well.
.SH "Differences from ANSI C"
.IX Header "Differences from ANSI C"
\&\fIassert()\fR is intended to act like the function from \s-1ANSI\s0 C fame. 
Unfortunately, due to perl's lack of macros or strong inlining, it's not
nearly as unobtrusive.
.Sp
Well, the obvious one is the \*(L"if \s-1DEBUG\s0\*(R" part.  This is cleanest way I could
think of to cause each \fIassert()\fR call and its arguments to be removed from
the program at compile-time, like the \s-1ANSI\s0 C macro does.
.Sp
Also, this version of assert does not report the statement which
failed, just the line number and call frame via Carp::confess.  You
can't do \f(CW\*(C`assert('$a == $b')\*(C'\fR because \f(CW$a\fR and \f(CW$b\fR will probably be
lexical, and thus unavailable to \fIassert()\fR.  But with Perl, unlike C,
you always have the source to look through, so the need isn't as
great.
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
.RS 4
.Ip "\s-1NDEBUG\s0" 4
.IX Item "NDEBUG"
Defining \s-1NDEBUG\s0 switches off all assertions.  It has the same effect
as changing \*(L"use Carp::Assert\*(R" to \*(L"no Carp::Assert\*(R" but it effects all
code.
.Ip "\s-1PERL_NDEBUG\s0" 4
.IX Item "PERL_NDEBUG"
Same as \s-1NDEBUG\s0 and will override it.  Its provided to give you
something which won't conflict with any C programs you might be
working on at the same time.
.RE
.RS 4
.SH "BUGS, CAVETS and other MUSINGS"
.IX Header "BUGS, CAVETS and other MUSINGS"
Someday, Perl will have an inline pragma, and the \f(CW\*(C`if DEBUG\*(C'\fR
bletcherousness will go away.
.Sp
I really need to figure a way to get it to return the given statement
in the assertion.  \fIshould()\fR and \fIshouldnt()\fR is a start.  Maybe
B::Deparse... would assert({$this eq \f(CW$that\fR}) be too annoying?
.Sp
Yes, there is a \f(CW\*(C`shouldn't\*(C'\fR routine.  It mostly works, but you \fBmust\fR
put the \f(CW\*(C`if DEBUG\*(C'\fR after it.
.SH "AUTHOR"
.IX Header "AUTHOR"
Michael G Schwern <schwern@pobox.com>
