.\" Automatically generated by Pod::Man version 1.15
.\" Mon Apr 23 12:59:30 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "AddressParse 3"
.TH AddressParse 3 "perl v5.6.1" "2000-05-13" "User Contributed Perl Documentation"
.UC
.SH "NAME"
Lingua::EN::AddressParse \-  manipulate geographical addresses
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use Lingua::EN::AddressParse;
.Ve
.Vb 6
\&   my %args = 
\&   (
\&        country     => 'Australia',
\&      auto_clean  => 1,
\&      force_case  => 1
\&   );
.Ve
.Vb 1
\&   my $address = new Lingua::EN::AddressParse(%args);
.Ve
.Vb 1
\&   $error = $address->parse("14A MAIN RD. ST JOHNS WOOD NSW 2000");
.Ve
.Vb 2
\&   %my_address = $address->components;
\&   $suburb = $my_address{suuburb};
.Ve
.Vb 1
\&   $correct_casing = $address->case_all;
.Ve
.SH "REQUIRES"
.IX Header "REQUIRES"
Perl, version 5.001 or higher, Lingua::EN::NameParse and Parse::RecDescent
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module takes as input an address or post box in free format text 
such as,
.PP
.Vb 4
\&        12/3-5 AUBREY ST VERMONT VIC 3133
\&        "OLD REGRET" WENTWORTH FALLS NSW 2782 AUSTRALIA
\&        2A LOW ST. KEW NSW 2123
\&   GPO Box K318, HAYMARKET, NSW 2000
.Ve
and attempts to parse it. If successful, the address is broken
down into components and useful functions can be performed such as :
.PP
.Vb 3
\&   converting upper or lower case values to name case (2 Low St. Kew NSW 2123 )
\&   extracting the addresses individual components     (2,Low St.,KEW,NSW,2123 )
\&   determining the type of format the address is in   ('suburban')
.Ve
If the address cannot be parsed you have the option of cleaning the address
of bad characters, or extracting any portion that was parsed and the 
portion that failed.
.PP
This module can be used for analysing and improving the quality of
lists of addresses.
.SH "DEFINITIONS"
.IX Header "DEFINITIONS"
The following terms are used by AddressParse to define the components 
that can make up an address or post box.
.PP
.Vb 1
\&        Post Box -      GP0 Box K123, LPO 2345, RMS 23 ...
.Ve
.Vb 3
\&   Property Identifier
\&        Sub property description  -  Level, Unit, Apartment, Lot ...
\&           Property number           - 12/66A, 24-34, 2A, 23B/12C, 12/42-44
.Ve
.Vb 1
\&   Property name - "Old Regret"
.Ve
.Vb 3
\&   Street
\&           Street name   - O'Hare, New South Head, The Causeway
\&           Street type   - Road, Rd., St, Lane, Highway, Crescent, Circuit ...
.Ve
.Vb 4
\&   Suburb            - Dee Why, St. John's Wood ...
\&   State                          - NSW, ACT, NY, AZ ...
\&   Post code      - 2062, 34532, SG12A 9ET 
\&   Country                - Australia, UK, Papua New Guinea ....
.Ve
Refer to the component grammar defined within the code for a complete
list of combinations. 
.PP
The following address formats are currently supported :
.PP
.Vb 3
\& 'suburban' - property_identifier street suburb state post_code country(?) 
\& 'post_box' - post_box suburb_subcountry post_code country(?) 
\& 'rural'    - property_name suburb_subcountry post_code country(?)
.Ve
.SH "METHODS"
.IX Header "METHODS"
.Sh "new"
.IX Subsection "new"
The \f(CW\*(C`new\*(C'\fR method creates an instance of an address object and sets up
the grammar used to parse addresses. This must be called before any of the
following methods are invoked. Note that the object only needs to be
created once, and can be reused with new input data.
.PP
Various setup options may be defined in a hash that is passed as an 
optional argument to the \f(CW\*(C`new\*(C'\fR method.
.PP
.Vb 6
\&   my %args = 
\&   (
\&        country     => 'Australia',
\&      auto_clean  => 1,
\&      force_case  => 1
\&   );
.Ve
.Vb 1
\&   my $address = new Lingua::EN::AddressParse(%args);
.Ve
.I "country"
.IX Subsection "country"
.PP
The country argument must be specified. It determines the possible list of
valid subcountries (states, counties etc, defined in the Locale::SubCountry 
module) and post code formats.The current list of coutries is
.PP
.Vb 6
\&   Australia
\&   Brazil
\&   Canada
\&   Netherlands
\&   UK
\&   USA
.Ve
All forms of upper/lower case are acceptable in the country's spelling. If a 
country name is supplied that the module doesn't recognise, it will die.   
.PP
.I "force_case"
.IX Subsection "force_case"
.PP
This option will force the \f(CW\*(C`case_all\*(C'\fR method to address case the entire input
string, including any unmatched sections that failed parsing.   This option is 
useful when you know you data has invalid addresses, but you cannot filter out 
or reject them.
.PP
.I "auto_clean"
.IX Subsection "auto_clean"
.PP
When this option is set to a positive value, any call to the \f(CW\*(C`parse\*(C'\fR method 
that fails will attempt to 'clean' the address and then reparse it. See the 
\&\f(CW\*(C`clean\*(C'\fR method for  details. This is useful for dirty data with embedded 
unprintable or non alphabetic characters. 
.Sh "parse"
.IX Subsection "parse"
.Vb 1
\&    $error = $address->parse("12/3-5 AUBREY ST VERMONT VIC 3133");
.Ve
The \f(CW\*(C`parse\*(C'\fR method takes a single parameter of a text string containing a 
address. It attempts to parse the address and break it down into the components 
described above. If the address was parsed successfully, a 0 is returned, 
otherwise a 1. This step is a prerequisite for the following functions.
.Sh "case_all"
.IX Subsection "case_all"
.Vb 1
\&    $correct_casing = $address->case_all;
.Ve
The \f(CW\*(C`case_all\*(C'\fR method converts the first letter of each component to
capitals and the remainder to lower case, with the following exceptions-
.PP
.Vb 1
\&   Proper names capitalisation such  as MacNay and O'Brien are observed
.Ve
The method returns the entire cased address as text.
.Sh "case_components"
.IX Subsection "case_components"
.Vb 2
\&   %my_address = $address->components;
\&   $cased_suburb = $my_address{suburb};
.Ve
The \f(CW\*(C`case_components\*(C'\fR method  does the same thing as the \f(CW\*(C`case_all\*(C'\fR method,
but returns the addresses cased components in a hash. The following keys are 
used for each component-
.PP
.Vb 7
\&        post_box
\&        property_identifier
\&   property_name
\&   street
\&   suburb
\&   post_code
\&   country
.Ve
Entries only occur in the hash for each component that the currently parsed
address contains, meaning there are no keys with undefined values.
.Sh "components"
.IX Subsection "components"
.Vb 2
\&   %address = $address->components;
\&   $surburb = $address{suburb};
.Ve
The \f(CW\*(C`components\*(C'\fR method  does the same thing as the \f(CW\*(C`case_components\*(C'\fR method,
but each component is returned as it appears in the input string, with no case
conversion.
.Sh "properties"
.IX Subsection "properties"
The \f(CW\*(C`properties\*(C'\fR method return several properties of the address as a hash.
.PP
.I "type"
.IX Subsection "type"
.PP
The type of format a name is in, as one of the following strings: 
.PP
.Vb 4
\&   suburban
\&   rural
\&   post_box
\&   unknown
.Ve
.I "non_matching"
.IX Subsection "non_matching"
.PP
Returns any unmatched section that was found.
.SH "LIMITATIONS"
.IX Header "LIMITATIONS"
The huge number of character combinations that can form a valid address makes
it is impossible to correctly identify them all.
.PP
Valid addresses must contain a suburb, subcountry (state) and post code, 
in that order. This format is widely accepted in Australia and the \s-1US\s0. \s-1UK\s0
addresses will often include suburb, town, city and county, formats that
are very difficult to parse.
.PP
Subcountries must be in abbreviated form such as \s-1NSW\s0, \s-1VIC\s0, \s-1NY\s0, \s-1CA\s0, \s-1LEICS\s0.
I could add a pre-parse step to detect and abbreivate subcountry names,
so data sych as \*(L"New South Wales\*(R" can be parsed.
.PP
Property names must be enclosed in quotes like \*(L"Old Regret\*(R"
.PP
Because of the large combination of possible addresses defined in the grammar, 
the program is not very fast.
.SH "REFERENCES"
.IX Header "REFERENCES"
\&\*(L"The Wordsworth Dictionary of Abbreviations & Acronyms\*(R" (1997)
.PP
Australian Standard \s-1AS4212\-1994\s0 \*(L"Geographic Information Systems \- 
Data Dictionary for transfer of street addressing information\*(R"
.SH "FUTURE DIRECTIONS"
.IX Header "FUTURE DIRECTIONS"
Define grammar for other languages. Hopefully, all that would be needed is
to specify a new module with its own grammar, and inherit all the existing
methods. I don't have the knowledge of the naming conventions for non-english 
languages.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Locale::Subcountry
Lingua::EN::NameParse
Parse::RecDescent
.SH "TO DO"
.IX Header "TO DO"
.SH "BUGS"
.IX Header "BUGS"
.SH "CHANGES"
.IX Header "CHANGES"
0.01 28 Dec 1999: First Release
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2000 Kim Ryan. All rights reserved.
This program is free software; you can redistribute it 
and/or modify it under the terms of the Perl Artistic License
(see http://www.perl.com/perl/misc/Artistic.html).
.SH "AUTHOR"
.IX Header "AUTHOR"
AddressParse was written by Kim Ryan <kimaryan@ozemail.com.au> in 2000.
