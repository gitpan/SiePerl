.\" Automatically generated by Pod::Man version 1.15
.\" Mon Apr 23 13:53:01 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "DOM 3"
.TH DOM 3 "perl v5.6.1" "2000-12-12" "User Contributed Perl Documentation"
.UC
.SH "NAME XML::Generator::DOM"
.IX Header "NAME XML::Generator::DOM"
\&\s-1XML:\s0:Generator subclass for producing \s-1DOM\s0 trees instead of strings.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use XML::Generator::DOM;
.Ve
.Vb 4
\&        my $dg  = XML::Generator::DOM->new();
\&        my $doc = $dg->xml($dg->xmlcmnt("Test document."),
\&                           $dg->foo({'baz' => 'bam'}, 42));
\&        print $doc->toString;
.Ve
yields:
.PP
.Vb 3
\&        <?xml version="1.0" standalone="yes"?>
\&        <!--Test document-->
\&        <foo baz="bam">42</foo>
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1XML:\s0:Generator::DOM subclasses \s-1XML:\s0:Generator in order to produce \s-1DOM\s0
trees instead of strings (see the XML::Generator manpage and the XML::DOM manpage).  This
module is still experimental and its semantics might change.
.PP
Essentially, tag methods return \s-1XML::DOM:\s0:DocumentFragment objects,
constructed either from a \s-1DOM\s0 document passed into the constructor or
a default document that \s-1XML:\s0:Generator::DOM will automatically construct.
.PP
Calling the \fIxml()\fR method will return this automatically constructed
document and cause a fresh one to be constructed for future tag method
calls.  If you passed in your own document, you may not call the \fIxml()\fR
method.
.PP
Below, we just note the remaining differences in semantics between
\&\s-1XML:\s0:Generator methods and \s-1XML:\s0:Generator::DOM methods.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
These configuration options are accepted but have no effect on the
semantics of the returned object: escape, pretty, conformance and
empty.
.SH "TAG METHODS"
.IX Header "TAG METHODS"
Subsequently, tag method semantics are somewhat different for
this module compared to \s-1XML:\s0:Generator.  The primary difference is
that tag method return \s-1XML::DOM:\s0:DocumentFragment objects.  Namespace
and attribute processing remains the same, but remaining arguments to
tag methods must either be text or other \s-1XML::DOM:\s0:DocumentFragment
objects.  No escape processing, syntax checking, or output control is
done; this is all left up to \s-1XML::DOM\s0.
.SH "SPECIAL TAGS"
.IX Header "SPECIAL TAGS"
All special tags are available by default with \s-1XML:\s0:Generator::DOM; you don't
need to use 'conformance' => 'strict'.
.Sh "xmlpi(@args)"
.IX Subsection "xmlpi(@args)"
Arguments will simply be concatenated and passed as the data to
the \s-1XML::DOM:\s0:ProcessingInstruction object that is returned.
.Sh "xmlcmnt"
.IX Subsection "xmlcmnt"
Escaping of '\-\-' is done by \s-1XML::DOM:\s0:Comment, which replaces both
hyphens with '&#45;'.  An \s-1XML::DOM:\s0:Comment object is returned.
.Sh "xmldecl"
.IX Subsection "xmldecl"
Returns an \s-1XML::DOM:\s0:XMLDecl object.  Respects 'version', 'encoding'
and 'dtd' settings in the object.
.Sh "xmldecl"
.IX Subsection "xmldecl"
Returns an \s-1XML::DOM:\s0:DocumentType object.
.Sh "xmlcdata"
.IX Subsection "xmlcdata"
Returns an \s-1XML::DOM:\s0:CDATASection object.
.Sh "xml"
.IX Subsection "xml"
As described above, \fIxml()\fR can only be used when dom_document was not
set in the object.  The automatically created document will have its \s-1XML\s0
Declaration set and the arguments to \fIxml()\fR will be appended to it.  Then
a new \s-1DOM\s0 document is automatically generated and the old one is
returned.  This is the only way to get a \s-1DOM\s0 document from this module.
