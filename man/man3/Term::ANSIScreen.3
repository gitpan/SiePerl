.\" Automatically generated by Pod::Man version 1.15
.\" Mon Apr 23 08:12:33 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "ANSIScreen 3"
.TH ANSIScreen 3 "perl v5.6.1" "2001-01-30" "User Contributed Perl Documentation"
.UC
.SH "NAME"
Term::ANSIScreen \- Terminal control using \s-1ANSI\s0 escape sequences.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    # qw/:color/ is exported by default, i.e. color() & colored()
.Ve
.Vb 1
\&    use Term::ANSIScreen qw/:color :cursor :screen :keyboard/;
.Ve
.Vb 3
\&    print setmode(1), setkey('a','b');
\&    print "40x25 mode now, with 'a' mapped to 'b'.";
\&    <STDIN>; resetkey; setmode 3; cls;
.Ve
.Vb 3
\&    locate 1, 1; print "@ This is (1,1)", savepos;
\&    print locate(24,60), "@ This is (24,60)"; loadpos;
\&    print down(2), clline, "@ This is (3,15)\en";
.Ve
.Vb 3
\&    color 'black on white'; clline;
\&    print "This line is black on white.\en";
\&    print color 'reset'; print "This text is normal.\en";
.Ve
.Vb 4
\&    print colored ("This text is bold blue.\en", 'bold blue');
\&    print "This text is normal.\en";
\&    print colored ['bold blue'], "This text is bold blue.\en";
\&    print "This text is normal.\en";
.Ve
.Vb 1
\&    use Term::ANSIScreen qw/:constants/; # constants mode
.Ve
.Vb 1
\&    print BLUE ON GREEN . "Blue on green.\en";
.Ve
.Vb 3
\&    $Term::ANSIScreen::AUTORESET = 1;
\&    print BOLD GREEN . ON_BLUE "Bold green on blue.", CLEAR;
\&    print "\enThis text is normal.\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Term::ANSIScreen is a superset of Term::ANSIColor.  In addition
to color-sequence generating subroutines exported by \f(CW\*(C`:color\*(C'\fR
and \f(CW\*(C`:constants\*(C'\fR, this module also features \f(CW\*(C`:cursor\*(C'\fR for
cursor positioning, \f(CW\*(C`:screen\*(C'\fR for screen control, as well
as \f(CW\*(C`:keyboard\*(C'\fR for key mapping.
.Sh "\s-1NOTES\s0"
.IX Subsection "NOTES"
.Ip "\(bu"
All subroutines in Term::ANSIScreen will print its return value
if called under a void context.
.Ip "\(bu"
The cursor position, current color, screen mode and keyboard
mappings affected by Term::ANSIScreen will last after the program
terminates. You might want to reset them before the end of
your program.
.if n .Sh "The \f(CW"":color""\fP function set (exported by default)"
.el .Sh "The \f(CW:color\fP function set (exported by default)"
.IX Subsection "The :color function set (exported by default)"
Term::ANSIScreen recognizes (case-insensitively) following color
attributes: clear, reset, bold, underline, underscore, blink,
reverse, concealed, black, red, green, yellow, blue, magenta,
on_black, on_red, on_green, on_yellow, on_blue, on_magenta,
on_cyan, and on_white.
.PP
The color alone sets the foreground color, and on_color sets
the background color. You may also use on_color without the
underscore, e.g. \*(L"black on white\*(R".
.Ip "color \s-1LIST\s0"
.IX Item "color LIST"
Takes any number of strings as arguments and considers them
to be space-separated lists of attributes.  It then forms
and returns the escape sequence to set those attributes.
.Ip "colored \s-1EXPR\s0, \s-1LIST\s0"
.IX Item "colored EXPR, LIST"
Takes a scalar as the first argument and any number of
attribute strings as the second argument, then returns the
scalar wrapped in escape codes so that the attributes will
be set as requested before the string and reset to normal
after the string.
.PP
Alternately, you can pass a reference to an array as the
first argument, and then the contents of that array will
be taken as attributes and color codes and the remainder
of the arguments as text to colorize.
.PP
Normally, this function just puts attribute codes at the
beginning and end of the string, but if you set
\&\f(CW$Term::ANSIScreen::EACHLINE\fR to some string, that string will
be considered the line delimiter and the attribute will be set
at the beginning of each line of the passed string and reset
at the end of each line.  This is often desirable if the
output is being sent to a program like a pager, which can
be confused by attributes that span lines.
.PP
Normally you'll want to set \f(CW$Term::ANSIColor::EACHLINE\fR to
\&\f(CW\*(C`"\en"\*(C'\fR to use this feature.
.if n .Sh "The \f(CW"":constants""\fP function set"
.el .Sh "The \f(CW:constants\fP function set"
.IX Subsection "The :constants function set"
If you import \f(CW\*(C`:constants\*(C'\fR you can use the constants \s-1CLEAR\s0,
\&\s-1RESET\s0, \s-1BOLD\s0, \s-1UNDERLINE\s0, \s-1UNDERSCORE\s0, \s-1BLINK\s0, \s-1REVERSE\s0, \s-1CONCEALED\s0,
\&\s-1BLACK\s0, \s-1RED\s0, \s-1GREEN\s0, \s-1YELLOW\s0, \s-1BLUE\s0, \s-1MAGENTA\s0, \s-1ON_BLACK\s0, \s-1ON_RED\s0,
\&\s-1ON_GREEN\s0, \s-1ON_YELLOW\s0, \s-1ON_BLUE\s0, \s-1ON_MAGENTA\s0, \s-1ON_CYAN\s0, and \s-1ON_WHITE\s0
directly.  These are the same as color('attribute') and can be
used if you prefer typing:
.PP
.Vb 2
\&    print BOLD BLUE ON_WHITE "Text\en", RESET;
\&    print BOLD BLUE ON WHITE "Text\en", RESET; # _ is optional
.Ve
to
    print colored (\*(L"Text\en\*(R", 'bold blue on_white');
.PP
When using the constants, if you don't want to have to remember
to add the \f(CW\*(C`, RESET\*(C'\fR at the end of each print line, you can set
\&\f(CW$Term::ANSIColor::AUTORESET\fR to a true value.  Then, the display
mode will automatically be reset if there is no comma after the
constant.  In other words, with that variable set:
.PP
.Vb 1
\&    print BOLD BLUE "Text\en";
.Ve
will reset the display mode afterwards, whereas:
.PP
.Vb 1
\&    print BOLD, BLUE, "Text\en";
.Ve
will not.
.if n .Sh "The \f(CW"":cursor""\fP function set"
.el .Sh "The \f(CW:cursor\fP function set"
.IX Subsection "The :cursor function set"
.Ip "locate [\s-1EXPR\s0, \s-1EXPR\s0]"
.IX Item "locate [EXPR, EXPR]"
Sets the cursor position. The first argument is its row number,
and the second one its column number.  If omitted, the cursor
will be located at (1,1).
.Ip "up    [\s-1EXPR\s0] =item down  [\s-1EXPR\s0] =item left  [\s-1EXPR\s0] =item right [\s-1EXPR\s0]"
.IX Item "up    [EXPR] =item down  [EXPR] =item left  [EXPR] =item right [EXPR]"
Moves the cursor toward any direction for \s-1EXPR\s0 characters. If
omitted, \s-1EXPR\s0 is 1.
.Ip "savepos =item loadpos"
.IX Item "savepos =item loadpos"
Saves/restores the current cursor position.
.if n .Sh "The \f(CW"":screen""\fP function set"
.el .Sh "The \f(CW:screen\fP function set"
.IX Subsection "The :screen function set"
.Ip "cls"
.IX Item "cls"
Clears the screen with the current background color, and set
cursor to (1,1).
.Ip "clline"
.IX Item "clline"
Clears the current row with the current background color, and
set cursor to the 1st column.
.Ip "setmode \s-1EXPR\s0"
.IX Item "setmode EXPR"
Sets the screen mode to \s-1EXPR\s0. Under \s-1DOS\s0, \s-1ANSI\s0.SYS recognizes
following values:
.PP
.Vb 8
\&   0:  40 x  25 x   2 (text)   1:  40 x  25 x 16 (text)
\&   2:  80 x  25 x   2 (text)   3:  80 x  25 x 16 (text)
\&   4: 320 x 200 x   4          5: 320 x 200 x  2
\&   6: 640 x 200 x   2          7: Enables line wrapping
\&  13: 320 x 200 x   4         14: 640 x 200 x 16
\&  15: 640 x 350 x   2         16: 640 x 350 x 16
\&  17: 640 x 480 x   2         18: 640 x 480 x 16
\&  19: 320 x 200 x 256
.Ve
.Ip "wrapon =item wrapoff"
.IX Item "wrapon =item wrapoff"
Enables/disables the line-wraping mode.
.if n .Sh "The \f(CW"":keyboard""\fP function set"
.el .Sh "The \f(CW:keyboard\fP function set"
.IX Subsection "The :keyboard function set"
.Ip "setkey \s-1EXPR\s0, \s-1EXPR\s0"
.IX Item "setkey EXPR, EXPR"
Takes a scalar representing a single keystroke as the first
argument (either a character or an escape sequence in the
form of \*(L"num1;num2\*(R"), and maps it to a string defined by
the second argument.  Afterwards, when the user presses the
mapped key, the string will get outputed instead.
.Ip "resetkey [\s-1LIST\s0]"
.IX Item "resetkey [LIST]"
Resets each keys in the argument list to its original mapping.
If called without an argument, resets all previously mapped
keys.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.Ip "Invalid attribute name \f(CW%s\fR" 4
.IX Item "Invalid attribute name %s"
You passed an invalid attribute name to either \fIcolor()\fR or
\&\fIcolored()\fR.
.Ip "Identifier \f(CW%s\fR used only once: possible typo" 4
.IX Item "Identifier %s used only once: possible typo"
You probably mistyped a constant color name such as:
.Sp
.Vb 1
\&    print FOOBAR "This text is color FOOBAR\en";
.Ve
It's probably better to always use commas after constant names
in order to force the next error.
.Ip "No comma allowed after filehandle" 4
.IX Item "No comma allowed after filehandle"
You probably mistyped a constant color name such as:
.Sp
.Vb 1
\&    print FOOBAR, "This text is color FOOBAR\en";
.Ve
Generating this fatal compile error is one of the main advantages
of using the constants interface, since you'll immediately know
if you mistype a color name.
.if n .Ip "Bareword \f(CW%s\fR not allowed while """"strict subs"""" in use" 4
.el .Ip "Bareword \f(CW%s\fR not allowed while ``strict subs'' in use" 4
.IX Item "Bareword %s not allowed while "strict subs in use"
You probably mistyped a constant color name such as:
.Sp
.Vb 1
\&    $Foobar = FOOBAR . "This line should be blue\en";
.Ve
or:
.Sp
.Vb 1
\&    @Foobar = FOOBAR, "This line should be blue\en";
.Ve
This will only show up under use strict (another good reason
to run under use strict).
.SH "AUTHORS"
.IX Header "AUTHORS"
Original idea (using constants) by Zenin (zenin@best.com),
reimplemented using subs by Russ Allbery (rra@stanford.edu),
and then combined with the original idea by Russ with input
from Zenin to Term::ANSIColor. Screen mode and keyboard mapping
codes were added by Autrijus Tang, along with revised code
and documentation.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2001 by Autrijus Tang <autrijus@autrijus.org>.
Based on works of Zenin (zenin@best.com),
                  Russ Allbery (rra@stanford.edu).
.PP
All rights reserved.  This module is free software; you can
redistribute it and/or modify it under the same terms as Perl
itself.
