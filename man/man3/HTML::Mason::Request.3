.\" Automatically generated by Pod::Man version 1.15
.\" Mon Apr 23 12:02:06 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "REQUEST 1"
.TH REQUEST 1 "perl v5.6.1" "2000-12-13" "User Contributed Perl Documentation"
.UC
.SH "NAME"
\&\s-1HTML:\s0:Mason::Request \- Mason Request Class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    $m->abort (...)
\&    $m->comp (...)
\&    etc.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Request \s-1API\s0 is your gateway to all Mason features not provided by
syntactic tags. Mason creates a new Request object for every web
request. Inside a component you
access the current request object via the global \f(CW\*(C`$m\*(C'\fR.
.SH "COMPONENT PATHS"
.IX Header "COMPONENT PATHS"
The methods the comp entry in the Request manpage, the comp_exists entry in the Request manpage, the fetch_comp entry in the Request manpage, and
the process_comp_path entry in the Request manpage take a component path as argument.
.Ip "\(bu" 4
If the path is absolute (starting with a '/'), then the component is
found relative to the component root.
.Ip "\(bu" 4
If the path is relative (no leading '/'), then the component is found
relative to the current component directory.
.Ip "\(bu" 4
If the path matches both a subcomponent and file-based component, the
subcomponent takes precedence.
.SH "METHODS"
.IX Header "METHODS"
.Ip "abort ([return value])" 4
.IX Item "abort ([return value])"
Ends the current request, finishing the page without returning
through components. The optional argument specifies the return
value from \f(CW\*(C`Interp::exec\*(C'\fR; in a web environment, this ultimately
becomes the \s-1HTTP\s0 status code.
.Sp
\&\fIabort()\fR is implemented via \fIdie()\fR and can thus be caught by \fIeval()\fR. 
.Sp
Under the current implementation, any pending \f(CW\*(C`<%filter>\*(C'\fR sections will
not be applied to the output after an abort.  This is a known bug but
there is no easy workaround.
.Sp
The methods \f(CW\*(C`aborted\*(C'\fR and \f(CW\*(C`aborted_value\*(C'\fR return a boolean
indicating whether the current request was aborted and the argument
with which it was aborted, respectively. These would be used,
for example, after an \fIeval()\fR returned with a non-empty \f(CW\*(C`$@\*(C'\fR.
.Ip "aborted" 4
.IX Item "aborted"
Returns true or undef indicating whether the current request was aborted
with \f(CW\*(C`abort\*(C'\fR.
.Ip "aborted_value" 4
.IX Item "aborted_value"
Returns the argument passed to \f(CW\*(C`abort\*(C'\fR when the request was
aborted. Returns undef if the request was not aborted or was aborted
without an argument.
.Ip "base_comp" 4
.IX Item "base_comp"
Returns the current base component for method and attributes.
Generally set to the original page component; however, if you invoke
call_method on a component, \f(CW\*(C`base_comp\*(C'\fR is dynamically set to that
component until call_method exits. See the Object-Oriented Techniques entry in the Devel manpage for examples of usage.
.Ip "cache ([action=>'retrieve|store|expire|keys'], [key=>name], [value=>data], [keep_in_memory=>0|1], [expire options...])" 4
.IX Item "cache ([action=>'retrieve|store|expire|keys'], [key=>name], [value=>data], [keep_in_memory=>0|1], [expire options...])"
\&\f(CW\*(C`$m\->cache\*(C'\fR lets you store and retrieve the results
of computation for improved performance. Each component has its own
data cache for storing one or more key/value pairs. The cache is
implemented as a \s-1DBM\s0 database. See the the data caching entry in the Devel manpage
section of the \fIComponent Developer's Guide\fR for examples
and caching strategies.
.Sp
The argument to \fIaction\fR is one of:
.Sp
o \fIretrieve\fR: returns the cache value if successful, or \f(CW\*(C`undef\*(C'\fR
if there was no value or if it has expired.
.Sp
o \fIstore\fR: stores a new cache value under the given key.  Default key
is 'main'.  Returns the value being stored if successful.
.Sp
o \fIexpire\fR: expires a given cache value or values.
key may be a single key or a list reference. Default key is 'main'.
.Sp
o \fIkeys\fR: returns a list of all the keys in the cache.
.Sp
\&\fIvalue\fR defines what to store. It can be a scalar or a reference to
an arbitrary data structure. The allowable size depends on your \s-1DBM\s0
implementation.
.Sp
\&\fIkeep_in_memory\fR indicates whether to save the value in memory once it is
retrieved. Default is 0, meaning that the value will be retrieved from
the cache file each time. If 1, each child server that retrieves this
value will save its own copy, which can result in substantial memory
usage for larger values. Use sparingly.
.Sp
The various expiration options are:
.Sp
o \fIexpire_at\fR: takes an absolute expiration time, in Perl \fItime()\fR format
(number of seconds since the epoch)
.Sp
o \fIexpire_in\fR: takes a relative expiration time of the form
\&\*(L"<num><unit>\*(R", where <num> is a positive number and <unit> is one of
seconds, minutes, hours, days, or weeks, or any abbreviation thereof.
E.g. \*(L"10min\*(R", \*(L"30m\*(R", \*(L"1hour\*(R".
.Sp
o \fIexpire_next\fR: takes a string, either 'hour' or 'day'. It indicates
an expiration time at the top of the next hour or day.
.Sp
o \fIexpire_if\fR: calls a given anonymous subroutine and expires if the
subroutine returns a non-zero value. The subroutine is called with one
parameter, the time when the cache value was last written.
.Ip "cache_self (... same as cache options...)" 4
.IX Item "cache_self (... same as cache options...)"
Uses \f(CW\*(C`$m\->cache\*(C'\fR to cache the entire output and/or the return value of
the current component.  It is typically used right at the top of an
\&\f(CW\*(C`<%init%>\*(C'\fR section.
.Sp
To cache the component's output:
.Sp
.Vb 4
\&    <%init>
\&        return if $m->cache_self(expire_in=>'3 hours'[, key=>'fookey']);
\&        ... <rest of init> ...
\&    </%init>
.Ve
To cache the component's return value:
.Sp
.Vb 5
\&    <%init>
\&        my ($retval,$cached) = $m->cache_self(expire_in=>'3 hours'[, key=>'fookey']);
\&        return $retval if $cached;
\&        ... <rest of init> ...
\&    </%init>
.Ve
This only works with scalar and reference return values.
.Sp
\&\f(CW\*(C`$m\->cache_self\*(C'\fR handles both the retrieve and store, so you can pass
both kinds of options to it. See \f(CW\*(C`$m\->cache\*(C'\fR for an explanation of
options.
.Sp
\&\f(CW\*(C`$m\->cache_self\*(C'\fR uses a bit of magic to accomplish everything in one
line.  You can use it without understanding it, but if you're
curious, here's how it works:
.Sp
o A component foo calls \f(CW\*(C`$m\->cache_self\*(C'\fR for the first time.
.Sp
o \f(CW\*(C`$m\->cache_self\*(C'\fR sees that the cache is empty and calls foo again
recursively, with a \s-1STORE\s0 option to capture its content into a buffer.
.Sp
o foo again calls \f(CW\*(C`$m\->cache_self\*(C'\fR which immediately returns 0 this time.
.Sp
o foo goes about its business and generates content into the \f(CW\*(C`$m\->cache_self\*(C'\fR buffer.
.Sp
o When control is returned to \f(CW\*(C`$m\->cache_self\*(C'\fR, it stores the content and
return value in the cache and also outputs the content normally.
Finally \f(CW\*(C`$m\->cache_self\*(C'\fR returns the list (retval,1) which in turn
causes foo to return immediately.
.Ip "caller_args" 4
.IX Item "caller_args"
Returns the arguments passed by the component at the specified stack
level. Use a positive argument to count from the current component and
a negative argument to count from the component at the bottom of the
stack. e.g.
.Sp
.Vb 3
\&    $m->caller_args(0)   # arguments passed to current component
\&    $m->caller_args(1)   # arguments passed to component that called us
\&    $m->caller_args(-1)  # arguments passed to first component executed
.Ve
When called in scalar context, a hash reference is returned.  When
called in list context, a list of arguments (which may be assigned to
a hash) is returned.
.Ip "callers" 4
.IX Item "callers"
With no arguments, returns the current component stack as a list of
component objects, starting with the current component and ending with
the top-level component. With one numeric argument, returns the
component object at that index in the list. Use a positive argument to
count from the current component and a negative argument to count from
the component at the bottom of the stack. e.g.
.Sp
.Vb 4
\&    my @comps = $m->callers   # all components
\&    $m->callers(0)            # current component
\&    $m->callers(1)            # component that called us
\&    $m->callers(-1)           # first component executed
.Ve
.Ip "call_next ([args...])" 4
.IX Item "call_next ([args...])"
Calls the next component in the content wrapping chain; usually called
from an autohandler. With no arguments, the original arguments are
passed to the component.  Any arguments specified here serve to
augment and override (in case of conflict) the original
arguments. Works like \f(CW\*(C`$m\->comp\*(C'\fR in terms of return value and
scalar/list context.  See the the autohandlers entry in the Devel manpage section of the
\&\fIComponent Developer's Guide\fR for examples.
.Ip "clear_buffer" 4
.IX Item "clear_buffer"
Clears the Mason output buffer. Any output sent before this line is
discarded. Useful for handling error conditions that can only be
detected in the middle of a request.
.Sp
clear_buffer only works in batch output mode, and is thwarted by
\&\f(CW\*(C`flush_buffer\*(C'\fR.
.Ip "comp (comp, args...)" 4
.IX Item "comp (comp, args...)"
Calls the component designated by \fIcomp\fR with the specified
option/value pairs. \fIcomp\fR may be a component path or a component
object. 
.Sp
Components work exactly like Perl subroutines in terms of return
values and context. A component can return any type of value, which is
then returned from the \f(CW\*(C`$m\->comp\*(C'\fR call.
.Sp
The <& &> tag provides a convenient shortcut for \f(CW\*(C`$m\->comp\*(C'\fR.
.Ip "comp_exists (comp_path)" 4
.IX Item "comp_exists (comp_path)"
Returns 1 if \fIcomp_path\fR is the path of an existing component, 0 otherwise. 
.Ip "count" 4
.IX Item "count"
Returns the number of this request, which is unique for a given
request and interpreter.
.Ip "current_comp" 4
.IX Item "current_comp"
Returns the current component object.
.Ip "decline" 4
.IX Item "decline"
Used from a top-level component or dhandler, this method aborts the
current request and restarts with the next applicable dhandler
up the tree. If no dhandler is available, an error occurs.
This method bears no relation to the Apache \s-1DECLINED\s0 status
except in name.
.Ip "depth" 4
.IX Item "depth"
Returns the current size of the component stack.  The lowest possible
value is 1, which indicates we are in the top-level component.
.Ip "dhandler_arg" 4
.IX Item "dhandler_arg"
If the request has been handled by a dhandler, this method returns the
remainder of the \s-1URI\s0 or \f(CW\*(C`Interp::exec\*(C'\fR path when the dhandler directory is
removed. Otherwise returns undef.
.Sp
\&\f(CW\*(C`dhandler_arg\*(C'\fR may be called from any component in the request, not just
the dhandler.
.Ip "fetch_comp (comp_path)" 4
.IX Item "fetch_comp (comp_path)"
Given a \fIcomp_path\fR, returns the corresponding component object or
undef if no such component exists.
.Ip "fetch_next" 4
.IX Item "fetch_next"
Returns the next component in the content wrapping chain, or undef if
there is no next component. Usually called from an autohandler.  See
the the autohandlers entry in the Devel manpage section of the \fIComponent Developer's
Guide\fR for usage and examples.
.Ip "fetch_next_all" 4
.IX Item "fetch_next_all"
Returns a list of the remaining components in the content wrapping
chain. Usually called from an autohandler.  See the
the autohandlers entry in the Devel manpage section of the \fIComponent Developer's Guide\fR
for usage and examples.
.Ip "file (filename)" 4
.IX Item "file (filename)"
Returns the contents of filename as a string. \fIfilename\fR may be an
absolute filesystem path (starting with a '/') or relative (no leading
\&'/'). If relative, Mason prepends the static file root, or the current
component directory if no static file root is defined.
.Ip "file_root" 4
.IX Item "file_root"
Returns the static file root, used by \f(CW\*(C`$m\->file\*(C'\fR to resolve relative
filenames.
.Ip "flush_buffer" 4
.IX Item "flush_buffer"
Flushes the Mason output buffer. Under mod_perl, also sends \s-1HTTP\s0
headers if they haven't been sent and calls \f(CW$r\fR->rflush to flush the
Apache buffer. Flushing the initial bytes of output can make your
servers appear more responsive.
.Ip "interp" 4
.IX Item "interp"
Returns the Interp object associated with this request.
.Ip "out (string)" 4
.IX Item "out (string)"
Print the given \fIstring\fR. Rarely needed, since normally all \s-1HTML\s0 is just
placed in the component body and output implicitly. \f(CW\*(C`$m\->out\*(C'\fR is useful
if you need to output something in the middle of a Perl block.
.Sp
\&\f(CW\*(C`$m\->out\*(C'\fR should be used instead of \f(CW\*(C`print\*(C'\fR or \f(CW\*(C`$r\->print\*(C'\fR,
since \f(CW\*(C`$m\->out\*(C'\fR may be redirected or buffered depending on the
current state of the interpreter.
.Ip "parser" 4
.IX Item "parser"
Returns the Parser object associated with this request.
.Ip "process_comp_path (comp_path)" 4
.IX Item "process_comp_path (comp_path)"
Given a \fIcomp_path\fR, returns the corresponding absolute component path.
.Ip "scomp (comp, args...)" 4
.IX Item "scomp (comp, args...)"
Like \f(CW\*(C`$m\->comp\*(C'\fR, but returns the component output as a string
instead of printing it. (Think sprintf versus printf.) The
component's return value is discarded.
.Ip "time" 4
.IX Item "time"
Returns the interpreter's notion of the current time in Perl \fItime()\fR
format (number of seconds since the epoch).
.Sp
By using \f(CW\*(C`$m\->time\*(C'\fR rather than calling \fItime()\fR directly, you enable
the option of previewer or port-based time/date simulations. e.g.
a port that looks one day into the future.
.Ip "top_args" 4
.IX Item "top_args"
Returns the arguments originally passed to the top level component.
When called in scalar context, a hash reference is returned. When
called in list context, a list of arguments (which may be assigned to
a hash) is returned.
.Ip "top_comp" 4
.IX Item "top_comp"
Returns the component originally called in the request. Note: because
of autohandlers this may or may not be the first component executed.
.SH "APACHE-ONLY METHODS"
.IX Header "APACHE-ONLY METHODS"
These additional methods are available when running Mason with mod_perl
and the ApacheHandler.
.Ip "ah" 4
.IX Item "ah"
Returns the ApacheHandler object associated with this request.
.Ip "apache_req" 4
.IX Item "apache_req"
Returns the Apache request object.  This is also available in the
global \f(CW$r\fR.
.Ip "cgi_object" 4
.IX Item "cgi_object"
Returns the \s-1CGI\s0 object used to parse any \s-1CGI\s0 parameters submitted to
the component, assuming that you have not changed the default value of
the ApacheHandler \f(CW\*(C`args_method\*(C'\fR parameter.  If you are using the
\&'mod_perl' args method, then calling this method is a fatal error.
See the the HTML::Mason::ApacheHandler manpage documentation for more details.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jonathan Swartz, swartz@pobox.com
.SH "SEE ALSO"
.IX Header "SEE ALSO"
the HTML::Mason::Component manpage
the HTML::Mason::ApacheHandler manpage
