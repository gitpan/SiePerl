.\" Automatically generated by Pod::Man version 1.15
.\" Tue Jun 12 10:49:51 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "Template 3"
.TH Template 3 "perl v5.6.1" "2001-02-05" "User Contributed Perl Documentation"
.UC
.SH "NAME"
Text::Template \- Expand template text with embedded Perl
.SH "VERSION"
.IX Header "VERSION"
This file documents \f(CW\*(C`Text::Template\*(C'\fR version \fB1.30\fR
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Text::Template;
.Ve
.Vb 5
\& $template = new Text::Template (TYPE => FILE,  SOURCE => 'filename.tmpl');
\& $template = new Text::Template (TYPE => ARRAY, SOURCE => [ ... ] );
\& $template = new Text::Template (TYPE => FILEHANDLE, SOURCE => $fh );
\& $template = new Text::Template (TYPE => STRING, SOURCE => '...' );
\& $template = new Text::Template (PREPEND => q{use strict;}, ...);
.Ve
.Vb 2
\& # Use a different template file syntax:
\& $template = new Text::Template (DELIMITERS => [$open, $close], ...);
.Ve
.Vb 3
\& $recipient = 'King';
\& $text = $template->fill_in();  # Replaces `{$recipient}' with `King'
\& print $text;
.Ve
.Vb 2
\& $T::recipient = 'Josh';
\& $text = $template->fill_in(PACKAGE => T);
.Ve
.Vb 2
\& $hash = { recipient => 'Abed-Nego' };
\& $text = $template->fill_in(HASH => $hash, ...); # Recipient is Abed-Nego
.Ve
.Vb 2
\& # Call &callback in case of programming errors in template
\& $text = $template->fill_in(BROKEN => \e&callback, BROKEN_ARG => [...]);
.Ve
.Vb 2
\& # Evaluate program fragments in Safe compartment with restricted permissions
\& $text = $template->fill_in(SAFE => $compartment, ...);
.Ve
.Vb 2
\& # Print result text instead of returning it
\& $success = $template->fill_in(OUTPUT => \e*FILEHANDLE, ...);
.Ve
.Vb 3
\& # Parse template with different template file syntax:
\& $text = $template->fill_in(DELIMITERS => [$open, $close], ...);
\& # Note that this is *faster* than using the default delimiters
.Ve
.Vb 2
\& # Prepend specified perl code to each fragment before evaluating:
\& $text = $template->fill_in(PREPEND => q{use strict 'vars';}, ...);
.Ve
.Vb 7
\& use Text::Template 'fill_in_string';
\& $text = fill_in_string( <<EOM, PACKAGE => 'T', ...);
\& Dear {$recipient},
\& Pay me at once.
\&        Love, 
\&         G.V.
\& EOM
.Ve
.Vb 2
\& use Text::Template 'fill_in_file';
\& $text = fill_in_file($filename, ...);
.Ve
.Vb 2
\& # All templates will always have `use strict vars' attached to all fragments
\& Text::Template->always_prepend(q{use strict 'vars';});
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a library for generating form letters, building \s-1HTML\s0 pages, or
filling in templates generally.  A `template' is a piece of text that
has little Perl programs embedded in it here and there.  When you
`fill in' a template, you evaluate the little programs and replace
them with their values.  
.PP
You can store a template in a file outside your program.  People can
modify the template without modifying the program.  You can separate
the formatting details from the main code, and put the formatting
parts of the program into the template.  That prevents code bloat and
encourages functional separation.
.Sh "Example"
.IX Subsection "Example"
Here's an example of a template, which we'll suppose is stored in the
file \f(CW\*(C`formletter.tmpl\*(C'\fR:
.PP
.Vb 1
\&        Dear {$title} {$lastname},
.Ve
.Vb 4
\&        It has come to our attention that you are delinquent in your
\&        {$monthname[$last_paid_month]} payment.  Please remit
\&        ${sprintf("%.2f", $amount)} immediately, or your patellae may
\&        be needlessly endangered.
.Ve
.Vb 1
\&                        Love,
.Ve
.Vb 1
\&                        Mark "Vizopteryx" Dominus
.Ve
The result of filling in this template is a string, which might look
something like this:
.PP
.Vb 1
\&        Dear Mr. Gates,
.Ve
.Vb 4
\&        It has come to our attention that you are delinquent in your
\&        February payment.  Please remit
\&        $392.12 immediately, or your patellae may
\&        be needlessly endangered.
.Ve
.Vb 1
\&                        Love,
.Ve
.Vb 1
\&                        Mark "Vizopteryx" Dominus
.Ve
Here is a complete program that transforms the example
template into the example result, and prints it out:
.PP
.Vb 1
\&        use Text::Template;
.Ve
.Vb 2
\&        my $template = new Text::Template (SOURCE => 'formletter.tmpl')
\&          or die "Couldn't construct template: $Text::Template::ERROR";
.Ve
.Vb 9
\&        my @monthname = qw(January February March April May June
\&                           July August September October November December);
\&        my %vars = (title => 'Mr.',
\&                    firstname => 'Bill',
\&                    lastname => 'Gates',
\&                    last_paid_month => 1,   # February
\&                    amount => 392.12,
\&                    monthname => \e@monthname,
\&                   );
.Ve
.Vb 1
\&        my $result = $template->fill_in(HASH => \e%vars);
.Ve
.Vb 2
\&        if (defined $result) { print $result }
\&        else { die "Couldn't fill in template: $Text::Template::ERROR" }
.Ve
.Sh "Philosophy"
.IX Subsection "Philosophy"
When people make a template module like this one, they almost always
start by inventing a special syntax for substitutions.  For example,
they build it so that a string like \f(CW\*(C`%%VAR%%\*(C'\fR is replaced with the
value of \f(CW\*(C`$VAR\*(C'\fR.  Then they realize the need extra formatting, so
they put in some special syntax for formatting.  Then they need a
loop, so they invent a loop syntax.  Pretty soon they have a new
little template language.
.PP
This approach has two problems: First, their little language is
crippled. If you need to do something the author hasn't thought of,
you lose.  Second: Who wants to learn another language?  You already
know Perl, so why not use it?
.PP
\&\f(CW\*(C`Text::Template\*(C'\fR templates are programmed in \fIPerl\fR.  You embed Perl
code in your template, with \f(CW\*(C`{\*(C'\fR at the beginning and \f(CW\*(C`}\*(C'\fR at the end.
If you want a variable interpolated, you write it the way you would in
Perl.  If you need to make a loop, you can use any of the Perl loop
constructions.  All the Perl built-in functions are available.
.SH "Details"
.IX Header "Details"
.Sh "Template Parsing"
.IX Subsection "Template Parsing"
The \f(CW\*(C`Text::Template\*(C'\fR module scans the template source.  An open brace
\&\f(CW\*(C`{\*(C'\fR begins a program fragment, which continues until the matching
close brace \f(CW\*(C`}\*(C'\fR.  When the template is filled in, the program
fragments are evaluated, and each one is replaced with the resulting
value to yield the text that is returned.
.PP
A backslash \f(CW\*(C`\e\*(C'\fR in front of a brace (or another backslash that is in
front of a brace) escapes its special meaning.  The result of filling
out this template:
.PP
.Vb 1
\&        \e{ The sum of 1 and 2 is {1+2}  \e}
.Ve
is
.PP
.Vb 1
\&        { The sum of 1 and 2 is 3  }
.Ve
If you have an unmatched brace, \f(CW\*(C`Text::Template\*(C'\fR will return a
failure code and a warning about where the problem is.  Backslashes
that do not precede a brace are passed through unchanged.  If you have
a template like this:
.PP
.Vb 1
\&        { "String that ends in a newline.\en" }
.Ve
The backslash inside the string is passed through to Perl unchanged,
so the \f(CW\*(C`\en\*(C'\fR really does turn into a newline.  See the note at the end
for details about the way backslashes work.  Backslash processing is
\&\fInot\fR done when you specify alternative delimiters with the
\&\f(CW\*(C`DELIMITERS\*(C'\fR option.  (See the section on "Alternative Delimiters", below.)
.PP
Each program fragment should be a sequence of Perl statements, which
are evaluated the usual way.  The result of the last statement
executed will be evaluted in scalar context; the result of this
statement is a string, which is interpolated into the template in
place of the program fragment itself.
.PP
The fragments are evaluated in order, and side effects from earlier
fragments will persist into later fragments:
.PP
.Vb 12
\&        {$x = @things; ''}The Lord High Chamberlain has gotten {$x}
\&        things for me this year.  
\&        { $diff = $x - 17; 
\&          $more = 'more'
\&          if ($diff == 0) {
\&            $diff = 'no';
\&          } elsif ($diff < 0) {
\&            $more = 'fewer';
\&          } 
\&          '';
\&        } 
\&        That is {$diff} {$more} than he gave me last year.
.Ve
The value of \f(CW\*(C`$x\*(C'\fR set in the first line will persist into the next
fragment that begins on the third line, and the values of \f(CW\*(C`$diff\*(C'\fR and
\&\f(CW\*(C`$more\*(C'\fR set in the second fragment will persist and be interpolated
into the last line.  The output will look something like this:
.PP
.Vb 2
\&        The Lord High Chamberlain has gotten 42
\&        things for me this year.
.Ve
.Vb 1
\&        That is 35 more than he gave me last year.
.Ve
That is all the syntax there is.  
.if n .Sh "The \f(CW""$OUT""\fP variable"
.el .Sh "The \f(CW$OUT\fP variable"
.IX Subsection "The $OUT variable"
There is one special trick you can play in a template.  Here is the
motivation for it:  Suppose you are going to pass an array, \f(CW\*(C`@items\*(C'\fR,
into the template, and you want the template to generate a bulleted
list with a header, like this:
.PP
.Vb 5
\&        Here is a list of the things I have got for you since 1907:
\&          * Ivory
\&          * Apes
\&          * Peacocks
\&          * ...
.Ve
One way to do it is with a template like this:
.PP
.Vb 7
\&        Here is a list of the things I have got for you since 1907:
\&        { my $blist = '';
\&          foreach $i (@items) {
\&            $blist .= qq{  * $i\en};
\&          }    
\&          $blist;
\&        }
.Ve
Here we construct the list in a variable called \f(CW\*(C`$blist\*(C'\fR, which we
return at the end.  This is a little cumbersome.  There is a shortcut.
.PP
Inside of templates, there is a special variable called \f(CW\*(C`$OUT\*(C'\fR.
Anything you append to this variable will appear in the output of the
template.  Also, if you use \f(CW\*(C`$OUT\*(C'\fR in a program fragment, the normal
behavior, of replacing the fragment with its return value, is
disabled; instead the fragment is replaced with the value of \f(CW\*(C`$OUT\*(C'\fR.
This means that you can write the template above like this:
.PP
.Vb 5
\&        Here is a list of the things I have got for you since 1907:
\&        { foreach $i (@items) {
\&            $OUT .= "  * $i\en";
\&          }    
\&        }
.Ve
\&\f(CW\*(C`$OUT\*(C'\fR is reinitialized to the empty string at the start of each
program fragment.  It is private to \f(CW\*(C`Text::Template\*(C'\fR, so 
you can't use a variable named \f(CW\*(C`$OUT\*(C'\fR in your template without
invoking the special behavior.
.Sh "General Remarks"
.IX Subsection "General Remarks"
All \f(CW\*(C`Text::Template\*(C'\fR functions return \f(CW\*(C`undef\*(C'\fR on failure, and set the
variable \f(CW\*(C`$Text::Template::ERROR\*(C'\fR to contain an explanation of what
went wrong.  For example, if you try to create a template from a file
that does not exist, \f(CW\*(C`$Text::Template::ERROR\*(C'\fR will contain something like:
.PP
.Vb 1
\&        Couldn't open file xyz.tmpl: No such file or directory
.Ve
.if n .Sh "\f(CW""new""\fP"
.el .Sh "\f(CWnew\fP"
.IX Subsection "new"
.Vb 1
\&        $template = new Text::Template ( TYPE => ..., SOURCE => ... );
.Ve
This creates and returns a new template object.  \f(CW\*(C`new\*(C'\fR returns
\&\f(CW\*(C`undef\*(C'\fR and sets \f(CW\*(C`$Text::Template::ERROR\*(C'\fR if it can't create the
template object.  \f(CW\*(C`SOURCE\*(C'\fR says where the template source code will
come from.  \f(CW\*(C`TYPE\*(C'\fR says what kind of object the source is.
.PP
The most common type of source is a file:
.PP
.Vb 1
\&        new Text::Template ( TYPE => 'FILE', SOURCE => $filename );
.Ve
This reads the template from the specified file.  The filename is
opened with the Perl \f(CW\*(C`open\*(C'\fR command, so it can be a pipe or anything
else that makes sense with \f(CW\*(C`open\*(C'\fR.
.PP
The \f(CW\*(C`TYPE\*(C'\fR can also be \f(CW\*(C`STRING\*(C'\fR, in which case the \f(CW\*(C`SOURCE\*(C'\fR should
be a string:
.PP
.Vb 2
\&        new Text::Template ( TYPE => 'STRING', 
\&                             SOURCE => "This is the actual template!" );
.Ve
The \f(CW\*(C`TYPE\*(C'\fR can be \f(CW\*(C`ARRAY\*(C'\fR, in which case the source should be a
reference to an array of strings.  The concatenation of these strings
is the template:
.PP
.Vb 5
\&        new Text::Template ( TYPE => 'ARRAY', 
\&                             SOURCE => [ "This is ", "the actual", 
\&                                         " template!",
\&                                       ]
\&                           );
.Ve
The \f(CW\*(C`TYPE\*(C'\fR can be \s-1FILEHANDLE\s0, in which case the source should be an
open filehandle (such as you got from the \f(CW\*(C`FileHandle\*(C'\fR or \f(CW\*(C`IO::*\*(C'\fR
packages, or a glob, or a reference to a glob).  In this case
\&\f(CW\*(C`Text::Template\*(C'\fR will read the text from the filehandle up to
end-of-file, and that text is the template:
.PP
.Vb 3
\&        # Read template source code from STDIN:
\&        new Text::Template ( TYPE => 'FILEHANDLE', 
\&                             SOURCE => \e*STDIN  );
.Ve
If you omit the \f(CW\*(C`TYPE\*(C'\fR attribute, it's taken to be \f(CW\*(C`FILE\*(C'\fR.
\&\f(CW\*(C`SOURCE\*(C'\fR is required.  If you omit it, the program will abort.
.PP
The words \f(CW\*(C`TYPE\*(C'\fR and \f(CW\*(C`SOURCE\*(C'\fR can be spelled any of the following ways:
.PP
.Vb 6
\&        TYPE    SOURCE
\&        Type    Source
\&        type    source
\&        -TYPE   -SOURCE
\&        -Type   -Source
\&        -type   -source
.Ve
Pick a style you like and stick with it.
.if n .Ip "\f(CW""""DELIMITERS""""\fR" 4
.el .Ip "\f(CWDELIMITERS\fR" 4
.IX Item "DELIMITERS"
You may also add a \f(CW\*(C`DELIMITERS\*(C'\fR option.  If this option is present,
its value should be a reference to an array of two strings.  The first
string is the string that signals the beginning of each program
fragment, and the second string is the string that signals the end of
each program fragment.  See the section on "Alternative Delimiters", below.
.if n .Sh "\f(CW""compile""\fP"
.el .Sh "\f(CWcompile\fP"
.IX Subsection "compile"
.Vb 1
\&        $template->compile()
.Ve
Loads all the template text from the template's source, parses and
compiles it.  If successful, returns true; otherwise returns false and
sets \f(CW\*(C`$Text::Template::ERROR\*(C'\fR.  If the template is already compiled,
it returns true and does nothing.  
.PP
You don't usually need to invoke this function, because \f(CW\*(C`fill_in\*(C'\fR
(see below) compiles the template if it isn't compiled already.
.PP
If there is an argument to this function, it must be a reference to an
array containing alternative delimiter strings.  See \f(CW\*(C`"Alternative
Delimiters"\*(C'\fR, below.
.if n .Sh "\f(CW""fill_in""\fP"
.el .Sh "\f(CWfill_in\fP"
.IX Subsection "fill_in"
.Vb 1
\&        $template->fill_in(OPTIONS);
.Ve
Fills in a template.  Returns the resulting text if successful.
Otherwise, returns \f(CW\*(C`undef\*(C'\fR  and sets \f(CW\*(C`$Text::Template::ERROR\*(C'\fR.
.PP
The \fI\s-1OPTIONS\s0\fR are a hash, or a list of key-value pairs.  You can
write the key names in any of the six usual styles as above; this
means that where this manual says \f(CW\*(C`PACKAGE\*(C'\fR (for example) you can
actually use any of
.PP
.Vb 1
\&        PACKAGE Package package -PACKAGE -Package -package
.Ve
Pick a style you like and stick with it.  The all-lowercase versions
may yield spurious warnings about
.PP
.Vb 1
\&        Ambiguous use of package => resolved to "package"
.Ve
so you might like to avoid them and use the capitalized versions.
.PP
At present, there are seven legal options:  \f(CW\*(C`PACKAGE\*(C'\fR, \f(CW\*(C`BROKEN\*(C'\fR,
\&\f(CW\*(C`BROKEN_ARG\*(C'\fR, \f(CW\*(C`SAFE\*(C'\fR, \f(CW\*(C`HASH\*(C'\fR, \f(CW\*(C`OUTPUT\*(C'\fR, and \f(CW\*(C`DELIMITERS\*(C'\fR.
.if n .Ip "\f(CW""""PACKAGE""""\fR" 4
.el .Ip "\f(CWPACKAGE\fR" 4
.IX Item "PACKAGE"
\&\f(CW\*(C`PACKAGE\*(C'\fR specifies the name of a package in which the program
fragments should be evaluated.  The default is to use the package from
which \f(CW\*(C`fill_in\*(C'\fR was called.  For example, consider this template:
.Sp
.Vb 1
\&        The value of the variable x is {$x}.
.Ve
If you use \f(CW\*(C`$template\->fill_in(PACKAGE => 'R')\*(C'\fR , then the \f(CW\*(C`$x\*(C'\fR in
the template is actually replaced with the value of \f(CW\*(C`$R::x\*(C'\fR.  If you
omit the \f(CW\*(C`PACKAGE\*(C'\fR option, \f(CW\*(C`$x\*(C'\fR will be replaced with the value of
the \f(CW\*(C`$x\*(C'\fR variable in the package that actually called \f(CW\*(C`fill_in\*(C'\fR.
.Sp
You should almost always use \f(CW\*(C`PACKAGE\*(C'\fR.  If you don't, and your
template makes changes to variables, those changes will be propagated
back into the main program.  Evaluating the template in a private
package helps prevent this.  The template can still modify variables
in your program if it wants to, but it will have to do so explicitly.
See the section at the end on `Security'.
.Sp
Here's an example of using \f(CW\*(C`PACKAGE\*(C'\fR:
.Sp
.Vb 1
\&        Your Royal Highness,
.Ve
.Vb 2
\&        Enclosed please find a list of things I have gotten
\&        for you since 1907:
.Ve
.Vb 5
\&        { foreach $item (@items) {
\&            $item_no++;
\&            $OUT .= " $item_no. \eu$item\en";
\&          }
\&        }
.Ve
.Vb 2
\&        Signed,
\&        Lord High Chamberlain
.Ve
We want to pass in an array which will be assigned to the array
\&\f(CW\*(C`@items\*(C'\fR.  Here's how to do that:
.Sp
.Vb 2
\&        @items = ('ivory', 'apes', 'peacocks', );
\&        $template->fill_in();
.Ve
This is not very safe.  The reason this isn't as safe is that if you
had a variable named \f(CW\*(C`$item_no\*(C'\fR in scope in your program at the point
you called \f(CW\*(C`fill_in\*(C'\fR, its value would be clobbered by the act of
filling out the template.  The problem is the same as if you had
written a subroutine that used those variables in the same way that
the template does.  (\f(CW\*(C`$OUT\*(C'\fR is special in templates and is always
safe.)
.Sp
One solution to this is to make the \f(CW\*(C`$item_no\*(C'\fR variable private to the
template by declaring it with \f(CW\*(C`my\*(C'\fR.  If the template does this, you
are safe.
.Sp
But if you use the \f(CW\*(C`PACKAGE\*(C'\fR option, you will probably be safe even
if the template does \fInot\fR declare its variables with \f(CW\*(C`my\*(C'\fR:
.Sp
.Vb 2
\&        @Q::items = ('ivory', 'apes', 'peacocks', );
\&        $template->fill_in(PACKAGE => 'Q');
.Ve
In this case the template will clobber the variable \f(CW\*(C`$Q::item_no\*(C'\fR,
which is not related to the one your program was using.
.Sp
Templates cannot affect variables in the main program that are
declared with \f(CW\*(C`my\*(C'\fR, unless you give the template references to those
variables.
.if n .Ip "\f(CW""""HASH""""\fR" 4
.el .Ip "\f(CWHASH\fR" 4
.IX Item "HASH"
You may not want to put the template variables into a package.
Packages can be hard to manage:  You can't copy them, for example.
\&\f(CW\*(C`HASH\*(C'\fR provides an alternative.  
.Sp
The value for \f(CW\*(C`HASH\*(C'\fR should be a reference to a hash that maps
variable names to values.  For example, 
.Sp
.Vb 3
\&        $template->fill_in(HASH => { recipient => "The King",
\&                                     items => ['gold', 'frankincense', 'myrrh']
\&                                   });
.Ve
will fill out the template and use \f(CW\*(C`"The King"\*(C'\fR as the value of
\&\f(CW\*(C`$recipient\*(C'\fR and the list of items as the value of \f(CW\*(C`@items\*(C'\fR.
.Sp
The full details of how it works are a little involved, so you might
want to skip to the next section.
.Sp
Suppose the key in the hash is \fIkey\fR and the value is \fIvalue\fR.  
.RS 4
.Ip "\(bu" 4
If the \fIvalue\fR is \f(CW\*(C`undef\*(C'\fR, then any variables named \f(CW\*(C`$key\*(C'\fR,
\&\f(CW\*(C`@key\*(C'\fR, \f(CW\*(C`%key\*(C'\fR, etc., are undefined.  
.Ip "\(bu" 4
If the \fIvalue\fR is a string or a number, then \f(CW\*(C`$key\*(C'\fR is set to that
value in the template.
.Ip "\(bu" 4
If the \fIvalue\fR is a reference to an array, then \f(CW\*(C`@key\*(C'\fR is set to
that array.  If the \fIvalue\fR is a reference to a hash, then \f(CW\*(C`%key\*(C'\fR is
set to that hash.  Similarly if \fIvalue\fR is any other kind of
reference.  This means that
.Sp
.Vb 1
\&        var => "foo"
.Ve
and
.Sp
.Vb 1
\&        var => \e"foo"
.Ve
have almost exactly the same effect.  (The difference is that in the
former case, the value is copied, and in the latter case it is
aliased.)  
.RE
.RS 4
.Sp
Normally, the way this works is by allocating a private package,
loading all the variables into the package, and then filling out the
template as if you had specified that package.  A new package is
allocated each time.  However, if you \fIalso\fR use the \f(CW\*(C`PACKAGE\*(C'\fR
option, \f(CW\*(C`Text::Template\*(C'\fR loads the variables into the package you
specified, and they stay there after the call returns.  Subsequent
calls to \f(CW\*(C`fill_in\*(C'\fR that use the same package will pick up the values
you loaded in.
.Sp
If the argument of \f(CW\*(C`HASH\*(C'\fR is a reference to an array instead of a
reference to a hash, then the array should contain a list of hashes
whose contents are loaded into the template package one after the
other.  You can use this feature if you want to combine several sets
of variables.  For example, one set of variables might be the defaults
for a fill-in form, and the second set might be the user inputs, which
override the defaults when they are present:
.Sp
.Vb 1
\&        $template->fill_in(HASH => [\e%defaults, \e%user_input]);
.Ve
You can also use this to set two variables with the same name:
.Sp
.Vb 4
\&        $template->fill_in(HASH => [{ v => "The King" },
\&                                    { v => [1,2,3] },
\&                                   ]
\&                          );
.Ve
This sets \f(CW\*(C`$v\*(C'\fR to \f(CW\*(C`"The King"\*(C'\fR and \f(CW\*(C`@v\*(C'\fR to \f(CW\*(C`(1,2,3)\*(C'\fR.	
.RE
.if n .Ip "\f(CW""""BROKEN""""\fR" 4
.el .Ip "\f(CWBROKEN\fR" 4
.IX Item "BROKEN"
If any of the program fragments fails to compile or aborts for any
reason, and you have set the \f(CW\*(C`BROKEN\*(C'\fR option to a function reference,
\&\f(CW\*(C`Text::Template\*(C'\fR will invoke the function.  This function is called
the \fI\f(CI\*(C`BROKEN\*(C'\fI function\fR.  The \f(CW\*(C`BROKEN\*(C'\fR function will tell
\&\f(CW\*(C`Text::Template\*(C'\fR what to do next.  
.Sp
If the \f(CW\*(C`BROKEN\*(C'\fR function returns \f(CW\*(C`undef\*(C'\fR, \f(CW\*(C`Text::Template\*(C'\fR will
immediately abort processing the template and return the text that it
has accumulated so far.  If your function does this, it should set a
flag that you can examine after \f(CW\*(C`fill_in\*(C'\fR returns so that you can
tell whether there was a premature return or not. 
.Sp
If the \f(CW\*(C`BROKEN\*(C'\fR function returns any other value, that value will be
interpolated into the template as if that value had been the return
value of the program fragment to begin with.  For example, if the
\&\f(CW\*(C`BROKEN\*(C'\fR function returns an error string, the error string will be
interpolated into the output of the template in place of the program
fragment that cased the error.
.Sp
If you don't specify a \f(CW\*(C`BROKEN\*(C'\fR function, \f(CW\*(C`Text::Template\*(C'\fR supplies
a default one that returns something like
.Sp
.Vb 2
\&        Program fragment at line 17 delivered error ``Illegal
\&        division by 0''
.Ve
Since this is interpolated into the template at the place the error
occurred, a template like this one:
.Sp
.Vb 1
\&        (3+4)*5 = { 3+4)*5 }
.Ve
yields this result:
.Sp
.Vb 2
\&        (3+4)*5 = Program fragment at line 1 delivered error
\&        ``syntax error''
.Ve
If you specify a value for the \f(CW\*(C`BROKEN\*(C'\fR attribute, it should be a
reference to a function that \f(CW\*(C`fill_in\*(C'\fR can call instead of the
default function.
.Sp
\&\f(CW\*(C`fill_in\*(C'\fR will pass a hash to the \f(CW\*(C`broken\*(C'\fR function.
The hash will have at least these three members:
.RS 4
.if n .Ip "\f(CW""""text""""\fR" 4
.el .Ip "\f(CWtext\fR" 4
.IX Item "text"
The source code of the program fragment that failed
.if n .Ip "\f(CW""""error""""\fR" 4
.el .Ip "\f(CWerror\fR" 4
.IX Item "error"
The text of the error message (\f(CW\*(C`$@\*(C'\fR) generated by eval
.if n .Ip "\f(CW""""lineno""""\fR" 4
.el .Ip "\f(CWlineno\fR" 4
.IX Item "lineno"
The line number of the template data at which the  program fragment
began
.RE
.RS 4
.Sp
There may also be an \f(CW\*(C`arg\*(C'\fR member.  See \f(CW\*(C`BROKEN_ARG\*(C'\fR, below
.RE
.if n .Ip "\f(CW""""BROKEN_ARG""""\fR" 4
.el .Ip "\f(CWBROKEN_ARG\fR" 4
.IX Item "BROKEN_ARG"
If you supply the \f(CW\*(C`BROKEN_ARG\*(C'\fR option to \f(CW\*(C`fill_in\*(C'\fR, the value of the
option is passed to the \f(CW\*(C`BROKEN\*(C'\fR function whenever it is called.  The
default \f(CW\*(C`BROKEN\*(C'\fR function ignores the \f(CW\*(C`BROKEN_ARG\*(C'\fR, but you can
write a custom \f(CW\*(C`BROKEN\*(C'\fR function that uses the \f(CW\*(C`BROKEN_ARG\*(C'\fR to get
more information about what went wrong. 
.Sp
The \f(CW\*(C`BROKEN\*(C'\fR function could also use the \f(CW\*(C`BROKEN_ARG\*(C'\fR as a reference
to store an error message or some other information that it wants to
communicate back to the caller.  For example:
.Sp
.Vb 1
\&        $error = '';
.Ve
.Vb 7
\&        sub my_broken { 
\&           my %args = @_;
\&           my $err_ref = $args{arg};
\&           ...
\&           $$err_ref = "Some error message";
\&           return undef;
\&        }
.Ve
.Vb 3
\&        $template->fill_in(BROKEN => \e&my_broken,
\&                           BROKEN_ARG => \e$error,
\&                          );
.Ve
.Vb 3
\&        if ($error) {
\&          die "It didn't work: $error";
\&        }
.Ve
If one of the program fragments in the template fails, it will call
the \f(CW\*(C`BROKEN\*(C'\fR function, \f(CW\*(C`my_broken\*(C'\fR, and pass it the \f(CW\*(C`BROKEN_ARG\*(C'\fR,
which is a reference to \f(CW\*(C`$error\*(C'\fR.  \f(CW\*(C`my_broken\*(C'\fR can store an error
message into \f(CW\*(C`$error\*(C'\fR this way.  Then the function that called
\&\f(CW\*(C`fill_in\*(C'\fR can see if \f(CW\*(C`my_broken\*(C'\fR has left an error message for it
to find, and proceed accordingly.
.if n .Ip "\f(CW""""SAFE""""\fR" 4
.el .Ip "\f(CWSAFE\fR" 4
.IX Item "SAFE"
If you give \f(CW\*(C`fill_in\*(C'\fR a \f(CW\*(C`SAFE\*(C'\fR option, its value should be a safe
compartment object from the \f(CW\*(C`Safe\*(C'\fR package.  All evaluation of
program fragments will be performed in this compartment.  See the Safe manpage
for full details about such compartments and how to restrict the
operations that can be performed in them.
.Sp
If you use the \f(CW\*(C`PACKAGE\*(C'\fR option with \f(CW\*(C`SAFE\*(C'\fR, the package you specify
will be placed into the safe compartment and evaluation will take
place in that package as usual.  
.Sp
If not, \f(CW\*(C`SAFE\*(C'\fR operation is a little different from the default.
Usually, if you don't specify a package, evaluation of program
fragments occurs in the package from which the template was invoked.
But in \f(CW\*(C`SAFE\*(C'\fR mode the evaluation occurs inside the safe compartment
and cannot affect the calling package.  Normally, if you use \f(CW\*(C`HASH\*(C'\fR
without \f(CW\*(C`PACKAGE\*(C'\fR, the hash variables are imported into a private,
one-use-only package.  But if you use \f(CW\*(C`HASH\*(C'\fR and \f(CW\*(C`SAFE\*(C'\fR together
without \f(CW\*(C`PACKAGE\*(C'\fR, the hash variables will just be loaded into the
root namespace of the \f(CW\*(C`Safe\*(C'\fR compartment.
.if n .Ip "\f(CW""""OUTPUT""""\fR" 4
.el .Ip "\f(CWOUTPUT\fR" 4
.IX Item "OUTPUT"
If your template is going to generate a lot of text that you are just
going to print out again anyway,  you can save memory by having
\&\f(CW\*(C`Text::Template\*(C'\fR print out the text as it is generated instead of
making it into a big string and returning the string.  If you supply
the \f(CW\*(C`OUTPUT\*(C'\fR option to \f(CW\*(C`fill_in\*(C'\fR, the value should be a filehandle.
The generated text will be printed to this filehandle as it is
constructed.  For example:
.Sp
.Vb 1
\&        $template->fill_in(OUTPUT => \e*STDOUT, ...);
.Ve
fills in the \f(CW\*(C`$template\*(C'\fR as usual, but the results are immediately
printed to \s-1STDOUT\s0.  This may result in the output appearing more
quickly than it would have otherwise.
.Sp
If you use \f(CW\*(C`OUTPUT\*(C'\fR, the return value from \f(CW\*(C`fill_in\*(C'\fR is still true on
success and false on failure, but the complete text is not returned to
the caller.
.if n .Ip "\f(CW""""PREPEND""""\fR" 4
.el .Ip "\f(CWPREPEND\fR" 4
.IX Item "PREPEND"
You can have some Perl code prepended automatically to the beginning
of every program fragment.  See the section on "\f(CW\*(C`PREPEND\*(C'\fR feature and using \f(CW\*(C`strict\*(C'\fR in templates" below.
.if n .Ip "\f(CW""""DELIMITERS""""\fR" 4
.el .Ip "\f(CWDELIMITERS\fR" 4
.IX Item "DELIMITERS"
If this option is present, its value should be a reference to a list
of two strings.  The first string is the string that signals the
beginning of each program fragment, and the second string is the
string that signals the end of each program fragment.  See
the section on "Alternative Delimiters", below.  
.Sp
If you specify \f(CW\*(C`DELIMITERS\*(C'\fR in the call to \f(CW\*(C`fill_in\*(C'\fR, they override
any delimiters you set when you created the template object with
\&\f(CW\*(C`new\*(C'\fR. 
.SH "Convenience Functions"
.IX Header "Convenience Functions"
.if n .Sh "\f(CW""fill_this_in""\fP"
.el .Sh "\f(CWfill_this_in\fP"
.IX Subsection "fill_this_in"
The basic way to fill in a template is to create a template object and
then call \f(CW\*(C`fill_in\*(C'\fR on it.   This is useful if you want to fill in
the same template more than once.
.PP
In some programs, this can be cumbersome.  \f(CW\*(C`fill_this_in\*(C'\fR accepts a
string, which contains the template, and a list of options, which are
passed to \f(CW\*(C`fill_in\*(C'\fR as above.  It constructs the template object for
you, fills it in as specified, and returns the results.  It returns
\&\f(CW\*(C`undef\*(C'\fR and sets \f(CW\*(C`$Text::Template::ERROR\*(C'\fR if it couldn't generate
any results.
.PP
An example:
.PP
.Vb 3
\&        $Q::name = 'Donald';
\&        $Q::amount = 141.61;
\&        $Q::part = 'hyoid bone';
.Ve
.Vb 7
\&        $text = Text::Template->fill_this_in( <<'EOM', PACKAGE => Q);
\&        Dear {$name},
\&        You owe me \e\e${sprintf('%.2f', $amount)}.  
\&        Pay or I will break your {$part}.
\&                Love,
\&                Grand Vizopteryx of Irkutsk.
\&        EOM
.Ve
Notice how we included the template in-line in the program by using a
`here document' with the \f(CW\*(C`<<\*(C'\fR notation.
.PP
\&\f(CW\*(C`fill_this_in\*(C'\fR is a deprecated feature.  It is only here for
backwards compatibility, and may be removed in some far-future version
in \f(CW\*(C`Text::Template\*(C'\fR.  You should use \f(CW\*(C`fill_in_string\*(C'\fR instead.  It
is described in the next section.
.if n .Sh "\f(CW""fill_in_string""\fP"
.el .Sh "\f(CWfill_in_string\fP"
.IX Subsection "fill_in_string"
It is stupid that \f(CW\*(C`fill_this_in\*(C'\fR is a class method.  It should have
been just an imported function, so that you could omit the
\&\f(CW\*(C`Text::Template\->\*(C'\fR in the example above.  But I made the mistake
four years ago and it is too late to change it.
.PP
\&\f(CW\*(C`fill_in_string\*(C'\fR is exactly like \f(CW\*(C`fill_this_in\*(C'\fR except that it is
not a method and you can omit the \f(CW\*(C`Text::Template\->\*(C'\fR and just say
.PP
.Vb 4
\&        print fill_in_string(<<'EOM', ...);
\&        Dear {$name},
\&          ...
\&        EOM
.Ve
To use \f(CW\*(C`fill_in_string\*(C'\fR, you need to say
.PP
.Vb 1
\&        use Text::Template 'fill_in_string';
.Ve
at the top of your program.   You should probably use
\&\f(CW\*(C`fill_in_string\*(C'\fR instead of \f(CW\*(C`fill_this_in\*(C'\fR.
.if n .Sh "\f(CW""fill_in_file""\fP"
.el .Sh "\f(CWfill_in_file\fP"
.IX Subsection "fill_in_file"
If you import \f(CW\*(C`fill_in_file\*(C'\fR, you can say
.PP
.Vb 1
\&        $text = fill_in_file(filename, ...);
.Ve
The \f(CW\*(C`...\*(C'\fR are passed to \f(CW\*(C`fill_in\*(C'\fR as above.  The filename is the
name of the file that contains the template you want to fill in.  It
returns the result text. or \f(CW\*(C`undef\*(C'\fR, as usual.
.PP
If you are going to fill in the same file more than once in the same
program you should use the longer \f(CW\*(C`new\*(C'\fR / \f(CW\*(C`fill_in\*(C'\fR sequence instead.
It will be a lot faster because it only has to read and parse the file
once.
.Sh "Including files into templates"
.IX Subsection "Including files into templates"
People always ask for this.  ``Why don't you have an include
function?'' they want to know.  The short answer is this is Perl, and
Perl already has an include function.  If you want it, you can just put
.PP
.Vb 1
\&        {qx{cat filename}}
.Ve
into your template.  VoilA\*`.
.PP
If you don't want to use \f(CW\*(C`cat\*(C'\fR, you can write a little four-line
function that opens a file and dumps out its contents, and call it
from the template.  I wrote one for you.  In the template, you can say
.PP
.Vb 1
\&        {Text::Template::_load_text(filename)}
.Ve
If that is too verbose, here is a trick.  Suppose the template package
that you are going to be mentioning in the \f(CW\*(C`fill_in\*(C'\fR call is package
\&\f(CW\*(C`Q\*(C'\fR.  Then in the main program, write
.PP
.Vb 1
\&        *Q::include = \e&Text::Template::_load_text;
.Ve
This imports the \f(CW\*(C`_load_text\*(C'\fR function into package \f(CW\*(C`Q\*(C'\fR with the
name \f(CW\*(C`include\*(C'\fR.  From then on, any template that you fill in with
package \f(CW\*(C`Q\*(C'\fR can say
.PP
.Vb 1
\&        {include(filename)}
.Ve
to insert the text from the named file at that point.  If you are
using the \f(CW\*(C`HASH\*(C'\fR option instead, just put \f(CW\*(C`include =>
\&\e&Text::Template::_load_text\*(C'\fR into the hash instead of importing it
explicitly.
.PP
Suppose you don't want to insert a plain text file, but rather you
want to include one template within another?  Just use \f(CW\*(C`fill_in_file\*(C'\fR
in the template itself:
.PP
.Vb 1
\&        {Text::Template::fill_in_file(filename)}
.Ve
You can do the same importing trick if this is too much to type.
.SH "Miscellaneous"
.IX Header "Miscellaneous"
.if n .Sh "\f(CW""my""\fP variables"
.el .Sh "\f(CWmy\fP variables"
.IX Subsection "my variables"
People are frequently surprised when this doesn't work:
.PP
.Vb 2
\&        my $recipient = 'The King';
\&        my $text = fill_in_file('formletter.tmpl');
.Ve
The text \f(CW\*(C`The King\*(C'\fR doesn't get into the form letter.  Why not?
Because \f(CW\*(C`$recipient\*(C'\fR is a \f(CW\*(C`my\*(C'\fR variable, and the whole point of
\&\f(CW\*(C`my\*(C'\fR variables is that they're private and inaccessible except in the
scope in which they're declared.  The template is not part of that
scope, so the template can't see \f(CW\*(C`$recipient\*(C'\fR.  
.PP
If that's not the behavior you want, don't use \f(CW\*(C`my\*(C'\fR.  \f(CW\*(C`my\*(C'\fR means a
private variable, and in this case you don't want the variable to be
private.  Put the variables into package variables in some other
package, and use the \f(CW\*(C`PACKAGE\*(C'\fR option to \f(CW\*(C`fill_in\*(C'\fR:
.PP
.Vb 2
\&        $Q::recipient = $recipient;
\&        my $text = fill_in_file('formletter.tmpl', PACKAGE => 'Q');
.Ve
or pass the names and values in a hash with the \f(CW\*(C`HASH\*(C'\fR option:
.PP
.Vb 1
\&        my $text = fill_in_file('formletter.tmpl', HASH => { recipient => $recipient });
.Ve
.Sh "Security Matters"
.IX Subsection "Security Matters"
All variables are evaluated in the package you specify with the
\&\f(CW\*(C`PACKAGE\*(C'\fR option of \f(CW\*(C`fill_in\*(C'\fR.  if you use this option, and if your
templates don't do anything egregiously stupid, you won't have to
worry that evaluation of the little programs will creep out into the
rest of your program and wreck something.
.PP
Nevertheless, there's really no way (except with \f(CW\*(C`Safe\*(C'\fR) to protect
against a template that says
.PP
.Vb 3
\&        { $Important::Secret::Security::Enable = 0; 
\&          # Disable security checks in this program 
\&        }
.Ve
or
.PP
.Vb 3
\&        { $/ = "ho ho ho";   # Sabotage future uses of <FH>.
\&          # $/ is always a global variable
\&        }
.Ve
or even
.PP
.Vb 1
\&        { system("rm -rf /") }
.Ve
so \fBdon't\fR go filling in templates unless you're sure you know what's
in them.  If you're worried, or you can't trust the person who wrote
the template, use the \f(CW\*(C`SAFE\*(C'\fR option.
.PP
A final warning: program fragments run a small risk of accidentally
clobbering local variables in the \f(CW\*(C`fill_in\*(C'\fR function itself.  These
variables all have names that begin with \f(CW\*(C`$fi_\*(C'\fR, so if you stay away
from those names you'll be safe.  (Of course, if you're a real wizard
you can tamper with them deliberately for exciting effects; this is
actually how \f(CW\*(C`$OUT\*(C'\fR works.)  I can fix this, but it will make the
package slower to do it, so I would prefer not to.  If you are worried
about this, send me mail and I will show you what to do about it.
.Sh "Alternative Delimiters"
.IX Subsection "Alternative Delimiters"
Lorenzo Valdettaro pointed out that if you are using \f(CW\*(C`Text::Template\*(C'\fR
to generate TeX output, the choice of braces as the program fragment
delimiters makes you suffer suffer suffer.  Starting in version 1.20,
you can change the choice of delimiters to something other than curly
braces.
.PP
In either the \f(CW\*(C`new()\*(C'\fR call or the \f(CW\*(C`fill_in()\*(C'\fR call, you can specify
an alternative set of delimiters with the \f(CW\*(C`DELIMITERS\*(C'\fR option.  For
example, if you would like code fragments to be delimited by \f(CW\*(C`[@\-\-\*(C'\fR
and \f(CW\*(C`\-\-@]\*(C'\fR instead of \f(CW\*(C`{\*(C'\fR and \f(CW\*(C`}\*(C'\fR, use
.PP
.Vb 1
\&        ... DELIMITERS => [ '[@--', '--@]' ], ...
.Ve
Note that these delimiters are \fIliteral strings\fR, not regexes.  (I
tried for regexes, but it complicates the lexical analysis too much.)
Note also that \f(CW\*(C`DELIMITERS\*(C'\fR disables the special meaning of the
backslash, so if you want to include the delimiters in the literal
text of your template file, you are out of luck\-\-\-it is up to you to
choose delimiters that do not conflict with what you are doing.  The
delimiter strings may still appear inside of program fragments as long
as they nest properly.  This means that if for some reason you
absolutely must have a program fragment that mentions one of the
delimiters, like this:
.PP
.Vb 3
\&        [@--
\&                print "Oh no, a delimiter: --@]\en"
\&        --@]
.Ve
you may be able to make it work by doing this instead:
.PP
.Vb 4
\&        [@--
\&                # Fake matching delimiter in a comment: [@--
\&                print "Oh no, a delimiter: --@]\en"
\&        --@]
.Ve
It may be safer to choose delimiters that begin with a newline
character.  
.PP
Because the parsing of templates is simplified by the absence of
backslash escapes, using alternative \f(CW\*(C`DELIMITERS\*(C'\fR \fIspeeds up\fR the
parsing process by 20\-25%.  This shows that my original choice of \f(CW\*(C`{\*(C'\fR
and \f(CW\*(C`}\*(C'\fR was very bad.  I therefore recommend that you use alternative
delimiters whenever possible. 
.if n .Sh "\f(CW""PREPEND""\fP feature and using \f(CW""strict""\fP in templates"
.el .Sh "\f(CWPREPEND\fP feature and using \f(CWstrict\fP in templates"
.IX Subsection "PREPEND feature and using strict in templates"
Suppose you would like to use \f(CW\*(C`strict\*(C'\fR in your templates to detect
undeclared variables and the like.  But each code fragment is a
separate lexical scope, so you have to turn on \f(CW\*(C`strict\*(C'\fR at the top of
each and every code fragment:
.PP
.Vb 5
\&        { use strict;
\&          use vars '$foo';
\&          $foo = 14;
\&          ...
\&        }
.Ve
.Vb 1
\&        ...
.Ve
.Vb 4
\&        { # we forgot to put `use strict' here
\&          my $result = $boo + 12;    # $boo is misspelled and should be $foo
\&          # No error is raised on `$boo'
\&        }
.Ve
Because we didn't put \f(CW\*(C`use strict\*(C'\fR at the top of the second fragment,
it was only active in the first fragment, and we didn't get any
\&\f(CW\*(C`strict\*(C'\fR checking in the second fragment.  Then we mispelled \f(CW\*(C`$foo\*(C'\fR
and the error wasn't caught.  
.PP
\&\f(CW\*(C`Text::Template\*(C'\fR version 1.22 and higher has a new feature to make
this easier.  You can specify that any text at all be automatically
added to the beginning of each program fragment.  
.PP
When you make a call to \f(CW\*(C`fill_in\*(C'\fR, you can specify a
.PP
.Vb 1
\&        PREPEND => 'some perl statements here'
.Ve
option; the statements will be prepended to each program fragment for
that one call only.  Suppose that the \f(CW\*(C`fill_in\*(C'\fR call included a
.PP
.Vb 1
\&        PREPEND => 'use strict;'
.Ve
option, and that the template looked like this:
.PP
.Vb 4
\&        { use vars '$foo';
\&          $foo = 14;
\&          ...
\&        }
.Ve
.Vb 1
\&        ...
.Ve
.Vb 3
\&        { my $result = $boo + 12;    # $boo is misspelled and should be $foo
\&          ...
\&        }
.Ve
The code in the second fragment would fail, because \f(CW\*(C`$boo\*(C'\fR has not
been declared.  \f(CW\*(C`use strict\*(C'\fR was implied, even though you did not
write it explicitly, because the \f(CW\*(C`PREPEND\*(C'\fR option added it for you
automatically.
.PP
There are two other ways to do this.  At the time you create the
template object with \f(CW\*(C`new\*(C'\fR, you can also supply a \f(CW\*(C`PREPEND\*(C'\fR option,
in which case the statements will be prepended each time you fill in
that template.  If the \f(CW\*(C`fill_in\*(C'\fR call has its own \f(CW\*(C`PREPEND\*(C'\fR option,
this overrides the one specified at the time you created the
template.  Finally, you can make the class method call
.PP
.Vb 1
\&        Text::Template->always_prepend('perl statements');
.Ve
If you do this, then call calls to \f(CW\*(C`fill_in\*(C'\fR for \fIany\fR template will
attach the perl statements to the beginning of each program fragment,
except where overridden by \f(CW\*(C`PREPEND\*(C'\fR options to \f(CW\*(C`new\*(C'\fR or \f(CW\*(C`fill_in\*(C'\fR.
.Sh "Prepending in Derived Classes"
.IX Subsection "Prepending in Derived Classes"
This section is technical, and you should skip it on the first few
readings. 
.PP
Normally there are three places that prepended text could come from.
It could come from the \f(CW\*(C`PREPEND\*(C'\fR option in the \f(CW\*(C`fill_in\*(C'\fR call, from
the \f(CW\*(C`PREPEND\*(C'\fR option in the \f(CW\*(C`new\*(C'\fR call that created the template
object, or from the argument of the \f(CW\*(C`always_prepend\*(C'\fR call.
\&\f(CW\*(C`Text::Template\*(C'\fR looks for these three things in order and takes the
first one that it finds.
.PP
In a subclass of \f(CW\*(C`Text::Template\*(C'\fR, this last possibility is
ambiguous.  Suppose \f(CW\*(C`S\*(C'\fR is a subclass of \f(CW\*(C`Text::Template\*(C'\fR.  Should 
.PP
.Vb 1
\&        Text::Template->always_prepend(...);
.Ve
affect objects in class \f(CW\*(C`Derived\*(C'\fR?  The answer is that you can have it
either way.  
.PP
The \f(CW\*(C`always_prepend\*(C'\fR value for \f(CW\*(C`Text::Template\*(C'\fR is normally stored
in  a hash variable named \f(CW\*(C`%GLOBAL_PREPEND\*(C'\fR under the key
\&\f(CW\*(C`Text::Template\*(C'\fR.  When \f(CW\*(C`Text::Template\*(C'\fR looks to see what text to
prepend, it first looks in the template object itself, and if not, it
looks in \f(CW\*(C`$GLOBAL_PREPEND{\f(CIclass\f(CW}\*(C'\fR where \fIclass\fR is the class to
which the template object belongs.  If it doesn't find any value, it
looks in \f(CW\*(C`$GLOBAL_PREPEND{'Text::Template'}\*(C'\fR.  This means that
objects in class \f(CW\*(C`Derived\*(C'\fR \fIwill\fR be affected by
.PP
.Vb 1
\&        Text::Template->always_prepend(...);
.Ve
\&\fIunless\fR there is also a call to
.PP
.Vb 1
\&        Derived->always_prepend(...);
.Ve
So when you're designing your derived class, you can arrange to have
your objects ignore \f(CW\*(C`Text::Template::always_prepend\*(C'\fR calls by simply
putting \f(CW\*(C`Derived\->always_prepend('')\*(C'\fR at the top of your module.
.PP
Of course, there is also a final escape hatch: Templates support a
\&\f(CW\*(C`prepend_text\*(C'\fR that is used to look up the appropriate text to be
prepended at \f(CW\*(C`fill_in\*(C'\fR time.  Your derived class can override this
method to get an arbitrary effect.
.Sh "JavaScript"
.IX Subsection "JavaScript"
Jennifer D. St Clair asks:
.PP
.Vb 2
\&        > Most of my pages contain JavaScript and Stylesheets.
\&        > How do I change the template identifier?
.Ve
Jennifer is worried about the braces in the JavaScript being taken as
the delimiters of the Perl program fragments.  Of course, disaster
will ensue when perl tries to evaluate these as if they were Perl
programs.  The best choice is to find some unambiguous delimiter
strings that you can use in your template instead of curly braces, and
then use the \f(CW\*(C`DELIMITERS\*(C'\fR option.  However, if you can't do this for
some reason, there are  two easy workarounds:
.PP
1. You can put \f(CW\*(C`\e\*(C'\fR in front of \f(CW\*(C`{\*(C'\fR, \f(CW\*(C`}\*(C'\fR, or \f(CW\*(C`\e\*(C'\fR to remove its
special meaning.  So, for example, instead of
.PP
.Vb 3
\&            if (br== "n3") { 
\&                // etc.
\&            }
.Ve
you can put
.PP
.Vb 3
\&            if (br== "n3") \e{ 
\&                // etc.
\&            \e}
.Ve
and it'll come out of the template engine the way you want.
.PP
But here is another method that is probably better.  To see how it
works, first consider what happens if you put this into a template:
.PP
.Vb 1
\&            { 'foo' }
.Ve
Since it's in braces, it gets evaluated, and obviously, this is going
to turn into
.PP
.Vb 1
\&            foo
.Ve
So now here's the trick: In Perl, \f(CW\*(C`q{...}\*(C'\fR is the same as \f(CW\*(C`'...'\*(C'\fR.
So if we wrote
.PP
.Vb 1
\&            {q{foo}}
.Ve
it would turn into 
.PP
.Vb 1
\&            foo
.Ve
So for your JavaScript, just write
.PP
.Vb 4
\&            {q{if (br== "n3") { 
\&                 // etc.
\&               }}
\&            }
.Ve
and it'll come out as
.PP
.Vb 3
\&              if (br== "n3") { 
\&                  // etc.
\&              }
.Ve
which is what you want.
.Sh "Shut Up!"
.IX Subsection "Shut Up!"
People sometimes try to put an initialization section at the top of
their templates, like this:
.PP
.Vb 3
\&        { ...
\&          $var = 17;
\&        }
.Ve
Then they complain because there is a \f(CW\*(C`17\*(C'\fR at the top of the output
that they didn't want to have there.  
.PP
Remember that a program fragment is replaced with its own return
value, and that in Perl the return value of a code block is the value
of the last expression that was evaluated, which in this case is 17.
If it didn't do that, you wouldn't be able to write \f(CW\*(C`{$recipient}\*(C'\fR
and have the recipient filled in.
.PP
To prevent the 17 from appearing in the output is very simple:
.PP
.Vb 4
\&        { ...
\&          $var = 17;
\&          '';
\&        }
.Ve
Now the last expression evaluated yields the empty string, which is
invisible.  If you don't like the way this looks, use
.PP
.Vb 4
\&        { ...
\&          $var = 17;
\&          ($SILENTLY);
\&        }
.Ve
instead.  Presumably, \f(CW\*(C`$SILENTLY\*(C'\fR has no value, so nothing will be
interpolated.  This is what is known as a `trick'.
.Sh "Compatibility"
.IX Subsection "Compatibility"
Every effort has been made to make this module compatible with older
versions.  There are three exceptions.  One is the output format of
the default \f(CW\*(C`BROKEN\*(C'\fR subroutine; I decided that the old format was
too verbose.  If this bothers you, it's easy to supply a custom
subroutine that yields the old behavior.  The second is that the
\&\f(CW\*(C`$OUT\*(C'\fR feature arrogates the \f(CW\*(C`$OUT\*(C'\fR variable for itself.  If you had
templates that happened to use a variable named \f(CW\*(C`$OUT\*(C'\fR, you will have
to change them to use some other variable or all sorts of strangeness
may result.
.PP
The third incompatibility is with the behavior of the \e metacharacter.
In 0.1b, \e\e was special everywhere, and the template processor always
replaced it with a single backslash before passing the code to Perl
for evaluation.  The rule now is more complicated but probably more
convenient.  See the section on backslash processing, below, for a
full discussion.
.PP
With a minor change to fix the format of the default \f(CW\*(C`BROKEN\*(C'\fR
subroutine, this version passes the test suite from the old version.
(It is in \f(CW\*(C`t/01\-basic.t\*(C'\fR.) The old test suite was too small, but it's
a little reassuring.
.Sh "Backslash Processing"
.IX Subsection "Backslash Processing"
In \f(CW\*(C`Text::Template\*(C'\fR beta versions, the backslash was special whenever
it appeared before a brace or another backslash.  That meant that
while \f(CW\*(C`{"\en"}\*(C'\fR did indeed generate a newline, \f(CW\*(C`{"\e\e"}\*(C'\fR did not
generate a backslash, because the code passed to Perl for evaluation
was \f(CW\*(C`"\e"\*(C'\fR which is a syntax error.  If you wanted a backslash, you
would have had to write \f(CW\*(C`{"\e\e\e\e"}\*(C'\fR.
.PP
In \f(CW\*(C`Text::Template\*(C'\fR versions 1.0 through 1.10, there was a bug:
Backslash was special everywhere.  In these versions, \f(CW\*(C`{"\en"}\*(C'\fR
generated the letter \f(CW\*(C`n\*(C'\fR.  
.PP
The bug has been corrected in version 1.11, but I did not go back to
exactly the old rule, because I did not like the idea of having to
write \f(CW\*(C`{"\e\e\e\e"}\*(C'\fR to get one backslash.  The rule is now more
complicated to remember, but probably easier to use.  The rule is now:
Backslashes are always passed to Perl unchanged \fIunless\fR they occur
as part of a sequence like \f(CW\*(C`\e\e\e\e\e\e{\*(C'\fR or \f(CW\*(C`\e\e\e\e\e\e}\*(C'\fR.  In these
contexts, they are special; \f(CW\*(C`\e\e\*(C'\fR is replaced with \f(CW\*(C`\e\*(C'\fR, and \f(CW\*(C`\e{\*(C'\fR and
\&\f(CW\*(C`\e}\*(C'\fR signal a literal brace. 
.PP
Examples:
.PP
.Vb 1
\&        \e{ foo \e}
.Ve
is \fInot\fR evaluated, because the \f(CW\*(C`\e\*(C'\fR before the braces signals that
they should be taken literally.  The result in the output looks like this: 
.PP
.Vb 1
\&        { foo }
.Ve
This is a syntax error:
.PP
.Vb 1
\&        { "foo}" }
.Ve
because \f(CW\*(C`Text::Template\*(C'\fR thinks that the code ends at the first \f(CW\*(C`}\*(C'\fR,
and then gets upset when it sees the second one.  To make this work
correctly, use
.PP
.Vb 1
\&        { "foo\e}" }
.Ve
This passes \f(CW\*(C`"foo}"\*(C'\fR to Perl for evaluation.  Note there's no \f(CW\*(C`\e\*(C'\fR in
the evaluated code.  If you really want a \f(CW\*(C`\e\*(C'\fR in the evaluated code,
use
.PP
.Vb 1
\&        { "foo\e\e\e}" }
.Ve
This passes \f(CW\*(C`"foo\e}"\*(C'\fR to Perl for evaluation.
.PP
Starting with \f(CW\*(C`Text::Template\*(C'\fR version 1.20, backslash processing is
disabled if you use the \f(CW\*(C`DELIMITERS\*(C'\fR option to specify alternative
delimiter strings.
.if n .Sh "A short note about \f(CW""$Text::Template::ERROR""\fP"
.el .Sh "A short note about \f(CW$Text::Template::ERROR\fP"
.IX Subsection "A short note about $Text::Template::ERROR"
In the past some people have fretted about `violating the package
boundary' by examining a variable inside the \f(CW\*(C`Text::Template\*(C'\fR
package.  Don't feel this way.  \f(CW\*(C`$Text::Template::ERROR\*(C'\fR is part of
the published, official interface to this package.  It is perfectly \s-1OK\s0
to inspect this variable.  The interface is not going to change.
.PP
If it really, really bothers you, you can import a function called
\&\f(CW\*(C`TTerror\*(C'\fR that returns the current value of the \f(CW\*(C`$ERROR\*(C'\fR variable.
So you can say:
.PP
.Vb 1
\&        use Text::Template 'TTerror';
.Ve
.Vb 5
\&        my $template = new Text::Template (SOURCE => $filename);
\&        unless ($template) {
\&          my $err = TTerror;
\&          die "Couldn't make template: $err; aborting";
\&        }
.Ve
I don't see what benefit this has over just doing this:
.PP
.Vb 1
\&        use Text::Template;
.Ve
.Vb 2
\&        my $template = new Text::Template (SOURCE => $filename)
\&          or die "Couldn't make template: $Text::Template::ERROR; aborting";
.Ve
But if it makes you happy to do it that way, go ahead.
.Sh "Sticky Widgets in Template Files"
.IX Subsection "Sticky Widgets in Template Files"
The \f(CW\*(C`CGI\*(C'\fR module provides functions for `sticky widgets', which are
form input controls that retain their values from one page to the
next.   Sometimes people want to know how to include these widgets
into their template output.
.PP
It's totally straightforward.  Just call the \f(CW\*(C`CGI\*(C'\fR functions from
inside the template:
.PP
.Vb 6
\&        { $q->checkbox_group(NAME => 'toppings',
\&                             LINEBREAK => true,
\&                             COLUMNS => 3,
\&                             VALUES => \e@toppings,
\&                            );
\&        }
.Ve
.Sh "Author"
.IX Subsection "Author"
Mark-Jason Dominus, Plover Systems
.PP
Please send questions and other remarks about this software to
\&\f(CW\*(C`mjd\-perl\-template@pobox.com\*(C'\fR
.PP
You can join a very low-volume (<10 messages per year) mailing
list for announcements about this package.  Send an empty note to
\&\f(CW\*(C`mjd\-perl\-template\-request@plover.com\*(C'\fR to join.
.PP
For updates, visit \f(CW\*(C`http://www.plover.com/~mjd/perl/Template/\*(C'\fR.
.Sh "Support?"
.IX Subsection "Support?"
This software is version 1.0.  It is a complete rewrite of an older
package, and may have bugs.  Suggestions and bug reports are always
welcome.  Send them to \f(CW\*(C`mjd\-perl\-template@plover.com\*(C'\fR.  (That is my
address, not the address of the mailing list.  The mailing list
address is a secret.)
.Sh "Thanks"
.IX Subsection "Thanks"
Many thanks to the following people for offering support,
encouragement, advice, and all the other good stuff.  
.PP
Klaus Arnhold /
Kevin Atteson /
Chris.Brezil /
Mike Brodhead /
Tom Brown /
Tim Bunce /
Juan E. Camacho /
Joseph Cheek /
San Deng /
Bob Dougherty /
Dan Franklin /
Todd A. Green /
Donald L. Greer Jr. /
Michelangelo Grigni /
Tom Henry /
Matt X. Hunter /
Robert M. Ioffe /
Daniel LaLiberte /
Reuven M. Lerner /
Joel Meulenberg /
Jason Moore /
Bek Oberin /
Ron Pero /
Hans Persson /
Jonathan Roy /
Shabbir J. Safdar /
Jennifer D. St Clair /
Uwe Schneider /
Randal L. Schwartz /
Michael G Schwern /
Brian C. Shensky /
Niklas Skoglund /
Tom Snee /
Hans Stoop /
Michael J. Suzio /
Dennis Taylor /
James H. Thompson /
Shad Todd /
Lorenzo Valdettaro /
Larry Virden /
Andy Wardley /
Matt Womer /
Andrew G Wood /
Michaely Yeung
.PP
Special thanks to:
.Ip "Jonathan Roy" 2
.IX Item "Jonathan Roy"
for telling me how to do the \f(CW\*(C`Safe\*(C'\fR support (I spent two years
worrying about it, and then Jonathan pointed out that it was trivial.)
.Ip "Ranjit Bhatnagar" 2
.IX Item "Ranjit Bhatnagar"
for demanding less verbose fragments like they have in \s-1ASP\s0, for
helping me figure out the Right Thing, and, especially, for talking me
out of adding any new syntax.  These discussions resulted in the
\&\f(CW\*(C`$OUT\*(C'\fR feature.
.Sh "Bugs and Caveats"
.IX Subsection "Bugs and Caveats"
\&\f(CW\*(C`my\*(C'\fR variables in \f(CW\*(C`fill_in\*(C'\fR are still susceptible to being clobbered
by template evaluation.  They all begin with \f(CW\*(C`fi_\*(C'\fR, so avoid those
names in your templates.
.PP
The line number information will be wrong if the template's lines are
not terminated by \f(CW\*(C`"\en"\*(C'\fR.  You should let me know if this is a
problem.  If you do, I will fix it.
.PP
The default format for reporting of broken program fragments has
changed since version 0.1.  
.PP
The \f(CW\*(C`$OUT\*(C'\fR variable has a special meaning in templates, so you cannot
use it as if it were a regular variable.
.PP
There are not quite enough tests in the test suite.
