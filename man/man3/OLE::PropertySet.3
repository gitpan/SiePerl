.\" Automatically generated by Pod::Man version 1.15
.\" Mon Apr 23 12:57:40 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "PropertySet 3"
.TH PropertySet 3 "perl v5.6.1" "1998-02-25" "User Contributed Perl Documentation"
.UC
.SH "NAME"
\&\s-1OLE:\s0:PropertySet \- Handles Property Sets
.PP
$Revision: 1.1.1.1 $ \f(CW$Date:\fR 1998/02/25 21:13:00 $
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& use OLE::Storage();
\& use OLE::PropertySet();
.Ve
.Vb 2
\& $Var = OLE::Storage -> NewVar;
\& $Doc = OLE::Storage -> open ($Startup, $Var, "testfile.doc");
.Ve
.Ip "direct mode" 4
.IX Item "direct mode"
\&\fI$PS\fR = \s-1OLE:\s0:PropertySet->load (\fI$Startup\fR, \fI$Var\fR, \fI$pps\fR, \fI$Doc\fR)
.Sp
\&\fI@list\fR = string { \fI$PS\fR \-> property (2, 5, 6) }
.Ip "tie mode" 4
.IX Item "tie mode"
\&\fI$PS\fR = tie \fI%PS\fR, \s-1OLE:\s0:PropertySet, \fI$Startup\fR, \fI$Var\fR, \fI$pps\fR, \fI$Doc\fR
.Sp
\&\fI@list\fR = string { \fI$PS\fR{2}, \fI$PS\fR{5}, \fI$PS\fR{6} }
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1OLE:\s0:PropertySet gives read access to property sets. These are streams,
that e.g. are residing inside of Structured Storage documents. Because
property set technology is not limited to these documents borders, this
package was designed to connect easily to Structured Storage documents 
and to arbitrary property set streams.
.PP
To understand the use of this package, I recommend highly to study the tool 
\&\*(L"ldat\*(R".
.Ip "dictionary" 4
.IX Item "dictionary"
\&\f(CW\*(C`1\*(C'\fR||\f(CW\*(C`O\*(C'\fR == \fI$PS\fR \-> dictionary (\fI\e%dict\fR [,\f(CW\*(C`1\*(C'\fR])
.Sp
Stores the dictionary of PropertySet \fI$PS\fR in hash \fI%dict\fR. The 
dictionary is a hash array having the property identifier numbers as
keys and the identifier names as values. By default the default dictionaries 
defined in \s-1OLE:\s0:PropertySet are also printed out. To leave them out, 
specify the optional parameter 1.
.Sp
Normally you will not need this method, but use \fIidset()\fR instead.
.Ip "idset" 4
.IX Item "idset"
\&\f(CW\*(C`1\*(C'\fR||\f(CW\*(C`O\*(C'\fR == \fI$PS\fR \-> idset (\fI\e%idset\fR [,\f(CW\*(C`1\*(C'\fR]);
.Sp
Stores the idset of PropertySet \fI$PS\fR in hash \fI%idset\fR. The idset
is a hash array based on the really available property identifiers.
\&\f(CW%idset\fR has property identifier numbers as keys and the identifier
names according to the PropertySets dictionary as values. The optional
parameter spares out the default dictionary (see dictionary).
.Sp
\&\fBNote\fR: Some or all id names can be empty, if they cannot be figured 
out. Nevertheless the ids are valid.
.Ip "idstr" 4
.IX Item "idstr"
\&\fI$idstr\fR||\f(CW\*(C`undef\*(C'\fR = \fI$PS\fR \-> idstr ($id [,\f(CW\*(C`1\*(C'\fR])
.Sp
Returns the property identifier string for property \f(CW$id\fR according to
the PropertySets dictionary. The optional parameter spares out the default
dictionary (see dictionary).
.Ip "load" 4
.IX Item "load"
.RS 4
.PD 0
.if n .Ip "\fI$PS\fR||\f(CW""""0""""\fR ==" 4
.el .Ip "\fI$PS\fR||\f(CW0\fR ==" 4
.IX Item "$PS||0 =="
.PD
1. load (\fI$Startup\fR, \fI$Var\fR, \fI$pps\fR, \fI$Doc\fR [,\f(CW\*(C`filter\*(C'\fR])
.Sp
2. load (\fI$Startup\fR, \fI$Var\fR, \fI$name\fR, \fI\e$buf\fR [,\f(CW\*(C`filter\*(C'\fR])
.RE
.RS 4
.RE
.Ip "" 4
\&\fIload()\fR is the constructor of \s-1OLE:\s0:PropertySet. You can call it
either with a Property Storage id \fI$pps\fR and a Structured Storage 
document handle \fI$Doc\fR as parameters, or with an PropertySetName \fI$name\fR
and a reference to a PropertySetBuffer \fI\e$buf\fR.
.Ip "NewVar" 4
.IX Item "NewVar"
\&\fI$Var\fR == \fI$PS\fR \-> NewVar ()
.Sp
Creates a new Variable handling object and returns it. (see also: open)
.Ip "property" 4
.IX Item "property"
\&\fIProperty\fR||\fIscalar\fR = \fI$PS\fR \-> property (\fI$id1\fR [,\fI$id2\fR [...]])
.Sp
Returns a \fI$Property\fR or a list of \fI@Properties\fR. (See 
\&\s-1OLE:\s0:Storage::Property to look what to do with it / them). If you applied a
filter when loading \fI$PS\fR, property returns a scalar or a list of scalars.
.Ip "type" 4
.IX Item "type"
\&\fI$type\fR||0 = PropertySet \-> type (\fI$Doc\fR, \fI$pps\fR)
.Sp
\&\fI$type\fR||0 = PropertySet \-> type ($name)
.Sp
Returns the type of a PropertySet according to its name. The type is
a \s-1OLE:\s0:PropertySet internal. It can be used to determine, if a property
is a PropertySet or not. Momentarily are existing:
.Sp
.Vb 5
\& type    meaning
\& ---------------------------------------------------
\& 0x01    property is a "\e05" PropertySet
\& 0x10    property is a "\e01CompObj" fake PropertySet
\& 0x00    property is no PropertySet at all
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
the OLE::Storage::Property manpage, demonstration program \*(L"ldat\*(R"
.SH "AUTHOR"
.IX Header "AUTHOR"
Martin Schwartz <\fIschwartz@cs.tu-berlin.de\fR>. 
