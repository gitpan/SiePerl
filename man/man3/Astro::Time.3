.\" Automatically generated by Pod::Man version 1.15
.\" Mon Apr 23 08:15:55 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "Astro::Time 3"
.TH Astro::Time 3 "perl v5.6.1" "1999-11-11" "User Contributed Perl Documentation"
.UC
.SH "NAME"
Astro::Time \- Time based astronomical routines
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Astro::Time;
.Ve
.Vb 5
\&    $dayno = cal2dayno($day, $month, $year);
\&    print "It's a leap year!\en" if (leap($year));
\&    $lmst = mjd2lst($mjd, $longitude, $dUT1);
\&    $turns = str2turn($string, 'H');
\&    $str = turn2str($turn, 'D', $sig);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Astro::Time contains an assorted set Perl routines for time based
conversions, such as conversion between calendar dates and Modified
Julian day and conversion of \s-1UT\s0 to local sidereal time. Include are
routines for conversion between numerical and string representation of
angles.
.SH "AUTHOR"
.IX Header "AUTHOR"
Chris Phillips  phillips@jive.nfra.nl
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.Ip "\fBturn2str\fR"
.IX Item "turn2str"
.Vb 2
\&  $str = turn2str($turn, $mode, $sig);
\&  $str = turn2str($turn, $mode, $sig, $strsep);
.Ve
.Vb 17
\& Convert fraction of a turn into string representation
\&   $turn   Angle in turns
\&   $mode   Mode of string to convert to:
\&            'H' for hours
\&            'D' for degrees
\&   $sig    number of significant figures
\&   $strsep String separator (override for default $Astro::Time::StrSep)
\&Note:
\& The behavior can be modified by the following two variables:
\&  $Astro::Time::ZeroStr   Minimum number of leading digits (zero padded 
\&                          if needed)
\&  $Astro::Time::StrSep    (Overridden by optional fourth argument)
\&    Deliminator used in string (Default ':')
\&    This may also equal one of a number of special values:
\&      'HMS'           12H45M12.3S or 170D34M56.2S
\&      'hms'           12h45m12.3s or 170d34m56.2s
\&      'deg'           170d34'56.2"
.Ve
.Ip "\fBdeg2str\fR"
.IX Item "deg2str"
.Vb 1
\&  $str=deg2str($deg, $mode, $sig);
.Ve
.Vb 7
\& Convert degrees into string representation
\&   $deg   angle in degrees
\&   $mode  mode of string to convert to:
\&           'H' for hours
\&           'D' for degrees
\&   $sig   number of significant figures
\& See note for turn2str
.Ve
.Ip "\fBrad2str\fR"
.IX Item "rad2str"
.Vb 1
\&  $str=rad2str($rad, $mode, $sig);
.Ve
.Vb 7
\& Convert radians into string representation
\&   $rad    angle in radians
\&   $mode   mode of string to convert to:
\&            'H' for hours
\&            'D' for degrees
\&   $sig is number of significant figures
\& See note for turn2str
.Ve
.Ip "\fBstr2turn\fR"
.IX Item "str2turn"
.Vb 1
\&  $turns = str2turn($string,$mode);
.Ve
.Vb 11
\& Convert angle from string representation into fraction of a turn
\&   $string    a : or space delimited angle
\&   $mode      type of angle
\&               'H' if $string is in hours,min,sec
\&               'D' if $string is in deg,arcmin,arcsec
\& The format of $string can be fairly flexible e.g.:
\&    12.2
\&    12:34
\&    12:34:45.1
\&   -23 34 12.3
\&   -34 34.3
.Ve
.Vb 1
\& Note: You cannot mix spaces and :
.Ve
.Ip "\fBstr2deg\fR"
.IX Item "str2deg"
.Vb 1
\&  $degrees=str2deg($string,$mode);
.Ve
.Vb 5
\& Convert angle from string representation into degrees
\&   $string   a : or space delimited angle
\&   $mode     'H' if $string is in hours,min,sec
\&             'D' if $string is in deg,arcmin,arcsec
\& See note for str2turn
.Ve
.Ip "\fBstr2rad\fR"
.IX Item "str2rad"
.Vb 1
\&  $radians=str2rad($string,$mode);
.Ve
.Vb 5
\& Convert angle from string representation into radians
\&   $string   a : or space delimited angle
\&   $mode     'H' if $string is in hours,min,sec
\&             'D' if $string is in deg,arcmin,arcsec
\& See note for str2turn
.Ve
.Ip "\fBhms2time\fR"
.IX Item "hms2time"
.Vb 2
\&  ($time) = hms2time($hour, $minute, $second);
\&  ($time) = hms2time($hour, $minute, $second, $mode);
.Ve
.Vb 7
\& Returns the day fraction given hours minutes and seconds (or degrees)
\&   $time        Day fraction
\&   $hour        Hours
\&   $minutes     Minutes
\&   $second      Seconds
\&   $mode        'H' or 'D' to interpret as hours or degrees (default 
\&                hours)
.Ve
.Ip "\fBtime2hms\fR"
.IX Item "time2hms"
.Vb 1
\&  ($sign, $hour, $minute, $second) = time2hms($time, $mode, $sig);
.Ve
.Vb 10
\& Returns hours (or degrees), minutes and seconds given the day fraction
\&   $sign      Sign of angle ('+' or '-')
\&   $hour      Hours
\&   $minutes   Minutes
\&   $second    Seconds
\&   $time      Day fraction
\&   $mode      Return degrees or Hours?
\&               'H' for hours
\&               'D' for degrees
\&   $sig       Number of significant digits for $second
.Ve
.Ip "\fBdeg2rad\fR"
.IX Item "deg2rad"
.Vb 2
\&  $rad=deg2rad($deg);
\& Convert degrees to radians
.Ve
.Ip "\fBrad2deg\fR"
.IX Item "rad2deg"
.Vb 2
\&  $deg=rad2deg($rad);
\& Convert radians to degrees
.Ve
.Ip "\fBturn2rad\fR"
.IX Item "turn2rad"
.Vb 2
\&  $rad=turn2rad($turn);
\& Convert turns to radians
.Ve
.Ip "\fBrad2turn\fR"
.IX Item "rad2turn"
.Vb 2
\&  $turn=rad2turn($rad);
\& Convert radians to turns
.Ve
.Ip "\fBturn2deg\fR"
.IX Item "turn2deg"
.Vb 2
\&  $deg=turn2deg($turn);
\& Convert turns to radians
.Ve
.Ip "\fBdeg2turn\fR"
.IX Item "deg2turn"
.Vb 2
\&  $turn=deg2turn($deg);
\& Convert degrees to turns
.Ve
.Ip "\fBcal2dayno\fR"
.IX Item "cal2dayno"
.Vb 1
\&  $dayno = cal2dayno($day, $month, $year);
.Ve
.Vb 1
\& Returns the day number corresponding to $day of $month in $year.
.Ve
.Ip "\fBdayno2cal\fR"
.IX Item "dayno2cal"
.Vb 1
\&  ($day, $month) = dayno2cal($dayno, $year);
.Ve
.Vb 1
\& Return the $day and $month corresponding to $dayno of $year.
.Ve
.Ip "\fBleap\fR"
.IX Item "leap"
.Vb 1
\&  $isleapyear = leap($year);
.Ve
.Vb 2
\& Returns true if $year is a leap year.
\&   $year    year in full
.Ve
.Ip "\fByesterday\fR"
.IX Item "yesterday"
.Vb 2
\&  ($dayno, $year) = yesterday($dayno, $year);
\&  ($day, $month, $year) = yesterday($day, $month, $year);
.Ve
.Vb 5
\& Winds back the day number by one, taking account of year wraps.
\&   $dayno       Day number of year
\&   $year        Year
\&   $month       Month
\&   $day         Day of month
.Ve
.Ip "\fBtomorrow\fR"
.IX Item "tomorrow"
.Vb 2
\&  ($dayno, $year) = tomorrow($dayno, $year);
\&  ($day, $month, $year) = tomorrow($day, $month, $year);
.Ve
.Vb 5
\& Advances the day number by one, taking account of year wraps.
\&   $dayno       Day number of year
\&   $year        Year
\&   $month       Month
\&   $day         Day of month
.Ve
.Ip "\fBmjd2cal\fR"
.IX Item "mjd2cal"
.Vb 1
\&  ($day, $month, $year, $ut) = mjd2cal($mjd);
.Ve
.Vb 7
\& Converts a modified Julian day number into calendar date (universal 
\& time). (based on the slalib routine sla_djcl).
\&    $mjd     Modified Julian day (JD-2400000.5)
\&    $day     Day of the month.
\&    $month   Month of the year.
\&    $year    Year
\&    $ut      UT day fraction
.Ve
.Ip "\fBcal2mjd\fR"
.IX Item "cal2mjd"
.Vb 1
\&  $mjd = cal2mjd($day, $month, $year, $ut);
.Ve
.Vb 7
\& Converts a calendar date (universal time) into modified Julian day 
\& number.
\&    $day     Day of the month.
\&    $month   Month of the year.
\&    $year    Year
\&    $ut      UT dayfraction
\&    $mjd     Modified Julian day (JD-2400000.5)
.Ve
.Ip "\fBmjd2dayno\fR"
.IX Item "mjd2dayno"
.Vb 1
\&  ($dayno, $year, $ut) = mjd2dayno($mjd);
.Ve
.Vb 5
\& Converts a modified Julian day number into year and dayno (universal 
\& time).
\&    $mjd     Modified Julian day (JD-2400000.5)
\&    $year    Year
\&    $dayno   Dayno of year
.Ve
.Ip "\fBdayno2mjd\fR"
.IX Item "dayno2mjd"
.Vb 1
\&  $mjd = dayno2mjd($dayno, $year, $ut);
.Ve
.Vb 4
\& Converts a dayno and year to modified Julian day
\&    $mjd     Modified Julian day (JD-2400000.5)
\&    $year    Year
\&    $dayno   Dayno of year
.Ve
.Ip "\fBnow2mjd\fR"
.IX Item "now2mjd"
.Vb 1
\&  $mjd = now2mjd()
.Ve
.Ip "\fBjd2mjd\fR"
.IX Item "jd2mjd"
.Vb 1
\&  $mjd = jd2mjd($jd);
.Ve
.Vb 3
\& Converts a Julian day to Modified Julian day
\&    $jd      Julian day
\&    $mjd     Modified Julian day
.Ve
.Ip "\fBmjd2jd\fR"
.IX Item "mjd2jd"
.Vb 1
\&  $jd = mjd2jd($mjd);
.Ve
.Vb 3
\& Converts a Modified Julian day to Julian day
\&    $mjd     Modified Julian day
\&    $jd      Julian day
.Ve
.Ip "\fBgst\fR"
.IX Item "gst"
.Vb 3
\&  $gst = gmst($mjd);
\&  $gmst = gmst($mjd, $dUT1);
\&  $gtst = gmst($mjd, $dUT1, $eqenx);
.Ve
.Vb 7
\& Converts a modified Julian day number to Greenwich sidereal time
\&   $mjd     modified Julian day (JD-2400000.5)
\&   $dUT1    difference between UTC and UT1 (UT1 = UTC + dUT1) (seconds)
\&   $eqenx   Equation of the equinoxes (not yet supported)
\&   $gst     Greenwich sidereal time (turns)
\&   $gmst    Greenwich mean sidereal time (turns)
\&   $gtst    Greenwich true sidereal time (turns)
.Ve
.Ip "\fBmjd2lst\fR"
.IX Item "mjd2lst"
.Vb 3
\&  $lst = mjd2lst($mjd, $longitude);
\&  $lmst = mjd2lst($mjd, $longitude, $dUT1);
\&  $ltst = mjd2lst($mjd, $longitude, $dUT1, $eqenx);
.Ve
.Vb 11
\& Converts a modified Julian day number into local sidereal time (lst),
\& local mean sidereal time (lmst) or local true sidereal time (ltst).
\& Unless high precisions is required dUT1 can be omitted (it will always 
\& be in the range -0.5 to 0.5 seconds).
\&   $mjd         Modified Julian day (JD-2400000.5)
\&   $longitude   Longitude for which the LST is required (turns)
\&   $dUT1        Difference between UTC and UT1 (UT1 = UTC + dUT1)(seconds)
\&   $eqenx       Equation of the equinoxes (not yet supported)
\&   $lst         Local sidereal time (turns)
\&   $lmst        Local mean sidereal time (turns)
\&   $ltst        Local true sidereal time (turns)
.Ve
.Ip "\fBcal2lst\fR"
.IX Item "cal2lst"
.Vb 3
\&  $lst = cal2lst($day, $month, $year, $ut, $longitude);
\&  $lmst = cal2lst($day, $month, $year, $ut, $longitude, $dUT1);
\&  $ltst = cal2lst($day, $month, $year, $ut, $longitude, $dUT1, $eqenx);
.Ve
.Vb 1
\& Wrapper to mjd2lst using calendar date rather than mjd
.Ve
.Ip "\fBdayno2lst\fR"
.IX Item "dayno2lst"
.Vb 3
\&  $lst = dayno2lst($dayno, $year, $ut, $longitude);
\&  $lmst = dayno2lst($dayno, $year, $ut, $longitude, $dUT1);
\&  $ltst = dayno2lst($dayno, $year, $ut, $longitude, $dUT1, $eqenx);
.Ve
.Vb 1
\& Wrapper to mjd2lst using calendar date rather than mjd
.Ve
.Ip "\fBrise\fR"
.IX Item "rise"
.Vb 1
\&  ($lst_rise, $lst_set) = rise($ra, $dec, $obslat, $el_limit);
.Ve
.Vb 8
\& Return the lst rise and set time of the given source
\&   $lst_rise, $lst_set  Rise and set time (turns)
\&   $ra, $dec            RA and Dec of source (turns)
\&   $obslat              Latitude of observatory (turns)
\&   $el_limit            Elevation limit of observatory
\&                                          (turns, 0 horizontal)
\& Returns 'Circumpolar'  if source circumpolar
\& Returns  undef         if source never rises
.Ve
.Vb 8
\& Uses the formula:
\&   cos $z_limit = sin $obslat * sin $dec + cos $obslat * cos $dec 
\&                  * cos $HA
\&   where:
\&    $z_limit is the zenith angle limit corresponding to $el_limit
\&    $HA is the Hour Angle of the source
\&NOTE: For maximum accuracy source coordinated should be precessed to
\&      the current date.
.Ve
.Ip "\fBlst2mjd\fR"
.IX Item "lst2mjd"
.Vb 2
\&  $mjd = lst2mjd($lmst, $dayno, $year, $longitude);
\&  $mjd = lst2mjd($lmst, $dayno, $year, $longitude, $dUT1);
.Ve
.Vb 4
\&  This routine calculates the modified Julian day number corresponding
\&  to the local mean sidereal time $lmst at $longitude, on a given UT
\&  day number ($dayno).  Unless high precision is required dUT1 can be
\&  omitted.
.Ve
.Vb 8
\&  The required inputs are :
\&    $lmst      - The local mean sidereal time (turns)
\&    $dayno     - The UT day of year for which to do the conversion
\&    $year      - The year for which to do the conversion
\&    $longitude - The longitude of the observatory (turns)
\&    $dUT1      - Difference between UTC and UT1 (UT1 = UTC + dUT1) 
\&                                                                (seconds)
\&    $mjd         The modified Julian day corresponding to $lmst on $dayno
.Ve
