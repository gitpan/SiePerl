.\" Automatically generated by Pod::Man version 1.15
.\" Mon Apr 23 13:45:50 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "DOM 3"
.TH DOM 3 "perl v5.6.1" "1999-08-13" "User Contributed Perl Documentation"
.UC
.SH "NAME"
\&\s-1XML::DOM\s0 \- A perl module for building \s-1DOM\s0 Level 1 compliant document structures
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use XML::DOM;
.Ve
.Vb 2
\& my $parser = new XML::DOM::Parser;
\& my $doc = $parser->parsefile ("file.xml");
.Ve
.Vb 3
\& # print all HREF attributes of all CODEBASE elements
\& my $nodes = $doc->getElementsByTagName ("CODEBASE");
\& my $n = $nodes->getLength;
.Ve
.Vb 6
\& for (my $i = 0; $i < $n; $i++)
\& {
\&     my $node = $nodes->item ($i);
\&     my $href = $node->getAttribute ("HREF");
\&     print $href->getValue . "\en";
\& }
.Ve
.Vb 1
\& $doc->printToFile ("out.xml");
.Ve
.Vb 1
\& print $doc->toString;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module extends the \s-1XML:\s0:Parser module by Clark Cooper. 
The \s-1XML:\s0:Parser module is built on top of \s-1XML:\s0:Parser::Expat, 
which is a lower level interface to James Clark's expat library.
.PP
\&\s-1XML::DOM:\s0:Parser is derived from \s-1XML:\s0:Parser. It parses \s-1XML\s0 strings or files
and builds a data structure that conforms to the \s-1API\s0 of the Document Object 
Model as described at http://www.w3.org/TR/REC-DOM-Level-1.
See the \s-1XML:\s0:Parser manpage for other available features of the 
\&\s-1XML::DOM:\s0:Parser class. 
Note that the 'Style' property should not be used (it is set internally.)
.PP
The \s-1XML:\s0:Parser \fINoExpand\fR option is more or less supported, in that it will
generate EntityReference objects whenever an entity reference is encountered
in character data. I'm not sure how useful this is. Any comments are welcome.
.PP
As described in the synopsis, when you create an \s-1XML::DOM:\s0:Parser object, 
the parse and parsefile methods create an \fI\s-1XML::DOM:\s0:Document\fR object
from the specified input. This Document object can then be examined, modified and
written back out to a file or converted to a string.
.PP
When using \s-1XML::DOM\s0 with \s-1XML:\s0:Parser version 2.19 and up, setting the 
\&\s-1XML::DOM:\s0:Parser option \fIKeepCDATA\fR to 1 will store CDATASections in
CDATASection nodes, instead of converting them to Text nodes.
Subsequent CDATASection nodes will be merged into one. Let me know if this
is a problem.
.PP
A Document has a tree structure consisting of \fINode\fR objects. A Node may contain
other nodes, depending on its type.
A Document may have Element, Text, Comment, and CDATASection nodes. 
Element nodes may have Attr, Element, Text, Comment, and CDATASection nodes. 
The other nodes may not have any child nodes. 
.PP
This module adds several node types that are not part of the \s-1DOM\s0 spec (yet.)
These are: ElementDecl (for <!ELEMENT ...> declarations), AttlistDecl (for
<!ATTLIST ...> declarations), XMLDecl (for <?xml ...?> declarations) and AttDef
(for attribute definitions in an AttlistDecl.)
.SH "DOM API"
.IX Header "DOM API"
.Ip "\s-1XML::DOM\s0" 4
.IX Item "XML::DOM"
.RS 4
.PD 0
.Ip "Constant definitions" 4
.IX Item "Constant definitions"
.PD
The following predefined constants indicate which type of node it is.
.RE
.RS 4
.Sp
.Vb 1
\& UNKNOWN_NODE (0)                The node type is unknown (not part of DOM)
.Ve
.Vb 12
\& ELEMENT_NODE (1)                The node is an Element.
\& ATTRIBUTE_NODE (2)              The node is an Attr.
\& TEXT_NODE (3)                   The node is a Text node.
\& CDATA_SECTION_NODE (4)          The node is a CDATASection.
\& ENTITY_REFERENCE_NODE (5)       The node is an EntityReference.
\& ENTITY_NODE (6)                 The node is an Entity.
\& PROCESSING_INSTRUCTION_NODE (7) The node is a ProcessingInstruction.
\& COMMENT_NODE (8)                The node is a Comment.
\& DOCUMENT_NODE (9)               The node is a Document.
\& DOCUMENT_TYPE_NODE (10)         The node is a DocumentType.
\& DOCUMENT_FRAGMENT_NODE (11)     The node is a DocumentFragment.
\& NOTATION_NODE (12)              The node is a Notation.
.Ve
.Vb 4
\& ELEMENT_DECL_NODE (13)          The node is an ElementDecl (not part of DOM)
\& ATT_DEF_NODE (14)               The node is an AttDef (not part of DOM)
\& XML_DECL_NODE (15)              The node is an XMLDecl (not part of DOM)
\& ATTLIST_DECL_NODE (16)          The node is an AttlistDecl (not part of DOM)
.Ve
.Vb 1
\& Usage:
.Ve
.Vb 4
\&   if ($node->getNodeType == ELEMENT_NODE)
\&   {
\&       print "It's an Element";
\&   }
.Ve
\&\fBNot In \s-1DOM\s0 Spec\fR: The \s-1DOM\s0 Spec does not mention \s-1UNKNOWN_NODE\s0 and, 
quite frankly, you should never encounter it. The last 4 node types were added
to support the 4 added node classes.
.Sh "Global Variables"
.IX Subsection "Global Variables"
.RS 4
.RE
.Ip "$VERSION" 4
.IX Item "$VERSION"
The variable \f(CW$XML::DOM::VERSION\fR contains the version number of this 
implementation, e.g. \*(L"1.07\*(R".
.Sh "Additional methods not in the \s-1DOM\s0 Spec"
.IX Subsection "Additional methods not in the DOM Spec"
.Ip "getIgnoreReadOnly and ignoreReadOnly (readOnly)" 4
.IX Item "getIgnoreReadOnly and ignoreReadOnly (readOnly)"
The \s-1DOM\s0 Level 1 Spec does not allow you to edit certain sections of the document,
e.g. the DocumentType, so by default this implementation throws DOMExceptions
(i.e. \s-1NO_MODIFICATION_ALLOWED_ERR\s0) when you try to edit a readonly node. 
These readonly checks can be disabled by (temporarily) setting the global 
IgnoreReadOnly flag.
.Sp
The ignoreReadOnly method sets the global IgnoreReadOnly flag and returns its
previous value. The getIgnoreReadOnly method simply returns its current value.
.Sp
.Vb 5
\& my $oldIgnore = XML::DOM::ignoreReadOnly (1);
\& eval {
\& ... do whatever you want, catching any other exceptions ...
\& };
\& XML::DOM::ignoreReadOnly ($oldIgnore);     # restore previous value
.Ve
.Ip "isValidName (name)" 4
.IX Item "isValidName (name)"
Whether the specified name is a valid \*(L"Name\*(R" as specified in the \s-1XML\s0 spec.
Characters with Unicode values > 127 are now also supported.
.Ip "getAllowReservedNames and allowReservedNames (boolean)" 4
.IX Item "getAllowReservedNames and allowReservedNames (boolean)"
The first method returns whether reserved names are allowed. 
The second takes a boolean argument and sets whether reserved names are allowed.
The initial value is 1 (i.e. allow reserved names.)
.Sp
The \s-1XML\s0 spec states that \*(L"Names\*(R" starting with (X|x)(M|m)(L|l)
are reserved for future use. (Amusingly enough, the \s-1XML\s0 version of the \s-1XML\s0 spec
(REC-xml-19980210.xml) breaks that very rule by defining an \s-1ENTITY\s0 with the name 
\&'xmlpio'.)
A \*(L"Name\*(R" in this context means the Name token as found in the \s-1BNF\s0 rules in the
\&\s-1XML\s0 spec.
.Sp
\&\s-1XML::DOM\s0 only checks for errors when you modify the \s-1DOM\s0 tree, not when the
\&\s-1DOM\s0 tree is built by the \s-1XML::DOM:\s0:Parser.
.Ip "setTagCompression (funcref)" 4
.IX Item "setTagCompression (funcref)"
There are 3 possible styles for printing empty Element tags:
.RS 4
.Ip "Style 0" 4
.IX Item "Style 0"
.Vb 1
\& <empty/> or <empty attr="val"/>
.Ve
\&\s-1XML::DOM\s0 uses this style by default for all Elements.
.Ip "Style 1" 4
.IX Item "Style 1"
.Vb 1
\&  <empty></empty> or <empty attr="val"></empty>
.Ve
.Ip "Style 2" 4
.IX Item "Style 2"
.Vb 1
\&  <empty /> or <empty attr="val" />
.Ve
This style is sometimes desired when using \s-1XHTML\s0. 
(Note the extra space before the slash \*(L"/\*(R")
See http://www.w3.org/TR/WD-html-in-xml Appendix C for more details.
.RE
.RS 4
.Sp
By default \s-1XML::DOM\s0 compresses all empty Element tags (style 0.)
You can control which style is used for a particular Element by calling
\&\s-1XML::DOM:\s0:setTagCompression with a reference to a function that takes
2 arguments. The first is the tag name of the Element, the second is the
\&\s-1XML::DOM:\s0:Element that is being printed. 
The function should return 0, 1 or 2 to indicate which style should be used to
print the empty tag. E.g.
.Sp
.Vb 1
\& XML::DOM::setTagCompression (\e&my_tag_compression);
.Ve
.Vb 3
\& sub my_tag_compression
\& {
\&    my ($tag, $elem) = @_;
.Ve
.Vb 2
\&    # Print empty br, hr and img tags like this: <br />
\&    return 2 if $tag =~ /^(br|hr|img)$/;
.Ve
.Vb 3
\&    # Print other empty tags like this: <empty></empty>
\&    return 1;
\& }
.Ve
.RE
.RE
.RS 4
.RE
.Ip "\s-1XML::DOM:\s0:Node" 4
.IX Item "XML::DOM::Node"
.Sh "Global Variables"
.IX Subsection "Global Variables"
.RS 4
.PD 0
.Ip "@NodeNames" 4
.IX Item "@NodeNames"
.PD
The variable \f(CW@XML::DOM::Node::NodeNames\fR maps the node type constants to strings.
It is used by \s-1XML::DOM:\s0:Node::getNodeTypeName.
.Sh "Methods"
.IX Subsection "Methods"
.Ip "getNodeType" 4
.IX Item "getNodeType"
Return an integer indicating the node type. See \s-1XML::DOM\s0 constants.
.Ip "getNodeName" 4
.IX Item "getNodeName"
Return a property or a hardcoded string, depending on the node type.
Here are the corresponding functions or values:
.Sp
.Vb 16
\& Attr                   getName
\& AttDef                 getName
\& AttlistDecl            getName
\& CDATASection           "#cdata-section"
\& Comment                "#comment"
\& Document               "#document"
\& DocumentType           getNodeName
\& DocumentFragment       "#document-fragment"
\& Element                getTagName
\& ElementDecl            getName
\& EntityReference        getEntityName
\& Entity                 getNotationName
\& Notation               getName
\& ProcessingInstruction  getTarget
\& Text                   "#text"
\& XMLDecl                "#xml-declaration"
.Ve
\&\fBNot In \s-1DOM\s0 Spec\fR: AttDef, AttlistDecl, ElementDecl and XMLDecl were added for
completeness.
.Ip "getNodeValue and setNodeValue (value)" 4
.IX Item "getNodeValue and setNodeValue (value)"
Returns a string or undef, depending on the node type. This method is provided 
for completeness. In other languages it saves the programmer an upcast.
The value is either available thru some other method defined in the subclass, or
else undef is returned. Here are the corresponding methods: 
Attr::getValue, Text::getData, CDATASection::getData, Comment::getData, 
ProcessingInstruction::getData.
.Ip "getParentNode and setParentNode (parentNode)" 4
.IX Item "getParentNode and setParentNode (parentNode)"
The parent of this node. All nodes, except Document,
DocumentFragment, and Attr may have a parent. However, if a
node has just been created and not yet added to the tree, or
if it has been removed from the tree, this is undef.
.Ip "getChildNodes" 4
.IX Item "getChildNodes"
A NodeList that contains all children of this node. If there
are no children, this is a NodeList containing no nodes. The
content of the returned NodeList is \*(L"live\*(R" in the sense that,
for instance, changes to the children of the node object that
it was created from are immediately reflected in the nodes
returned by the NodeList accessors; it is not a static
snapshot of the content of the node. This is true for every
NodeList, including the ones returned by the
getElementsByTagName method.
.Sp
\&\s-1NOTE:\s0 this implementation does not return a \*(L"live\*(R" NodeList for
getElementsByTagName. See the CAVEATS manpage.
.Sp
When this method is called in a list context, it returns a regular perl list
containing the child nodes. Note that this list is not \*(L"live\*(R". E.g.
.Sp
.Vb 3
\& @list = $node->getChildNodes;        # returns a perl list
\& $nodelist = $node->getChildNodes;    # returns a NodeList (object reference)
\& for my $kid ($node->getChildNodes)   # iterate over the children of $node
.Ve
.Ip "getFirstChild" 4
.IX Item "getFirstChild"
The first child of this node. If there is no such node, this returns undef.
.Ip "getLastChild" 4
.IX Item "getLastChild"
The last child of this node. If there is no such node, this returns undef.
.Ip "getPreviousSibling" 4
.IX Item "getPreviousSibling"
The node immediately preceding this node. If there is no such 
node, this returns undef.
.Ip "getNextSibling" 4
.IX Item "getNextSibling"
The node immediately following this node. If there is no such node, this returns 
undef.
.Ip "getAttributes" 4
.IX Item "getAttributes"
A NamedNodeMap containing the attributes (Attr nodes) of this node 
(if it is an Element) or undef otherwise.
Note that adding/removing attributes from the returned object, also adds/removes
attributes from the Element node that the NamedNodeMap came from.
.Ip "getOwnerDocument" 4
.IX Item "getOwnerDocument"
The Document object associated with this node. This is also
the Document object used to create new nodes. When this node
is a Document this is undef.
.Ip "insertBefore (newChild, refChild)" 4
.IX Item "insertBefore (newChild, refChild)"
Inserts the node newChild before the existing child node
refChild. If refChild is undef, insert newChild at the end of
the list of children.
.Sp
If newChild is a DocumentFragment object, all of its children
are inserted, in the same order, before refChild. If the
newChild is already in the tree, it is first removed.
.Sp
Return Value: The node being inserted.
.Sp
DOMExceptions:
.RS 4
.Ip "\(bu \s-1HIERARCHY_REQUEST_ERR\s0" 4
.IX Item "HIERARCHY_REQUEST_ERR"
Raised if this node is of a type that does not allow children of the type of
the newChild node, or if the node to insert is one of this node's ancestors.
.Ip "\(bu \s-1WRONG_DOCUMENT_ERR\s0" 4
.IX Item "WRONG_DOCUMENT_ERR"
Raised if newChild was created from a different document than the one that 
created this node.
.Ip "\(bu \s-1NO_MODIFICATION_ALLOWED_ERR\s0" 4
.IX Item "NO_MODIFICATION_ALLOWED_ERR"
Raised if this node is readonly.
.Ip "\(bu \s-1NOT_FOUND_ERR\s0" 4
.IX Item "NOT_FOUND_ERR"
Raised if refChild is not a child of this node.
.RE
.RS 4
.RE
.Ip "replaceChild (newChild, oldChild)" 4
.IX Item "replaceChild (newChild, oldChild)"
Replaces the child node oldChild with newChild in the list of
children, and returns the oldChild node. If the newChild is
already in the tree, it is first removed.
.Sp
Return Value: The node replaced.
.Sp
DOMExceptions:
.RS 4
.Ip "\(bu \s-1HIERARCHY_REQUEST_ERR\s0" 4
.IX Item "HIERARCHY_REQUEST_ERR"
Raised if this node is of a type that does not allow children of the type of
the newChild node, or it the node to put in is one of this node's ancestors.
.Ip "\(bu \s-1WRONG_DOCUMENT_ERR\s0" 4
.IX Item "WRONG_DOCUMENT_ERR"
Raised if newChild was created from a different document than the one that 
created this node.
.Ip "\(bu \s-1NO_MODIFICATION_ALLOWED_ERR\s0" 4
.IX Item "NO_MODIFICATION_ALLOWED_ERR"
Raised if this node is readonly.
.Ip "\(bu \s-1NOT_FOUND_ERR\s0" 4
.IX Item "NOT_FOUND_ERR"
Raised if oldChild is not a child of this node.
.RE
.RS 4
.RE
.Ip "removeChild (oldChild)" 4
.IX Item "removeChild (oldChild)"
Removes the child node indicated by oldChild from the list of
children, and returns it.
.Sp
Return Value: The node removed.
.Sp
DOMExceptions:
.RS 4
.Ip "\(bu \s-1NO_MODIFICATION_ALLOWED_ERR\s0" 4
.IX Item "NO_MODIFICATION_ALLOWED_ERR"
Raised if this node is readonly.
.Ip "\(bu \s-1NOT_FOUND_ERR\s0" 4
.IX Item "NOT_FOUND_ERR"
Raised if oldChild is not a child of this node.
.RE
.RS 4
.RE
.Ip "appendChild (newChild)" 4
.IX Item "appendChild (newChild)"
Adds the node newChild to the end of the list of children of
this node. If the newChild is already in the tree, it is
first removed. If it is a DocumentFragment object, the entire contents of 
the document fragment are moved into the child list of this node
.Sp
Return Value: The node added.
.Sp
DOMExceptions:
.RS 4
.Ip "\(bu \s-1HIERARCHY_REQUEST_ERR\s0" 4
.IX Item "HIERARCHY_REQUEST_ERR"
Raised if this node is of a type that does not allow children of the type of
the newChild node, or if the node to append is one of this node's ancestors.
.Ip "\(bu \s-1WRONG_DOCUMENT_ERR\s0" 4
.IX Item "WRONG_DOCUMENT_ERR"
Raised if newChild was created from a different document than the one that 
created this node.
.Ip "\(bu \s-1NO_MODIFICATION_ALLOWED_ERR\s0" 4
.IX Item "NO_MODIFICATION_ALLOWED_ERR"
Raised if this node is readonly.
.RE
.RS 4
.RE
.Ip "hasChildNodes" 4
.IX Item "hasChildNodes"
This is a convenience method to allow easy determination of
whether a node has any children.
.Sp
Return Value: 1 if the node has any children, 0 otherwise.
.Ip "cloneNode (deep)" 4
.IX Item "cloneNode (deep)"
Returns a duplicate of this node, i.e., serves as a generic
copy constructor for nodes. The duplicate node has no parent
(parentNode returns undef.).
.Sp
Cloning an Element copies all attributes and their values,
including those generated by the \s-1XML\s0 processor to represent
defaulted attributes, but this method does not copy any text
it contains unless it is a deep clone, since the text is
contained in a child Text node. Cloning any other type of
node simply returns a copy of this node.
.Sp
Parameters: 
 \fIdeep\fR   If true, recursively clone the subtree under the specified node.
If false, clone only the node itself (and its attributes, if it is an Element).
.Sp
Return Value: The duplicate node.
.Ip "normalize" 4
.IX Item "normalize"
Puts all Text nodes in the full depth of the sub-tree
underneath this Element into a \*(L"normal\*(R" form where only
markup (e.g., tags, comments, processing instructions, \s-1CDATA\s0
sections, and entity references) separates Text nodes, i.e.,
there are no adjacent Text nodes. This can be used to ensure
that the \s-1DOM\s0 view of a document is the same as if it were
saved and re-loaded, and is useful when operations (such as
XPointer lookups) that depend on a particular document tree
structure are to be used.
.Sp
\&\fBNot In \s-1DOM\s0 Spec\fR: In the \s-1DOM\s0 Spec this method is defined in the Element and 
Document class interfaces only, but it doesn't hurt to have it here...
.Ip "getElementsByTagName (name [, recurse])" 4
.IX Item "getElementsByTagName (name [, recurse])"
Returns a NodeList of all descendant elements with a given
tag name, in the order in which they would be encountered in
a preorder traversal of the Element tree.
.Sp
Parameters:
 \fIname\fR  The name of the tag to match on. The special value \*(L"*\*(R" matches all tags.
 \fIrecurse\fR  Whether it should return only direct child nodes (0) or any descendant that matches the tag name (1). This argument is optional and defaults to 1. It is not part of the \s-1DOM\s0 spec.
.Sp
Return Value: A list of matching Element nodes.
.Sp
\&\s-1NOTE:\s0 this implementation does not return a \*(L"live\*(R" NodeList for
getElementsByTagName. See the CAVEATS manpage.
.Sp
When this method is called in a list context, it returns a regular perl list
containing the result nodes. E.g.
.Sp
.Vb 3
\& @list = $node->getElementsByTagName("tag");       # returns a perl list
\& $nodelist = $node->getElementsByTagName("tag");   # returns a NodeList (object ref.)
\& for my $elem ($node->getElementsByTagName("tag")) # iterate over the result nodes
.Ve
.Sh "Additional methods not in the \s-1DOM\s0 Spec"
.IX Subsection "Additional methods not in the DOM Spec"
.Ip "getNodeTypeName" 4
.IX Item "getNodeTypeName"
Return the string describing the node type. 
E.g. returns \*(L"\s-1ELEMENT_NODE\s0\*(R" if getNodeType returns \s-1ELEMENT_NODE\s0.
It uses \f(CW@XML::DOM::Node::NodeNames\fR.
.Ip "toString" 4
.IX Item "toString"
Returns the entire subtree as a string.
.Ip "printToFile (filename)" 4
.IX Item "printToFile (filename)"
Prints the entire subtree to the file with the specified filename.
.Sp
Croaks: if the file could not be opened for writing.
.Ip "printToFileHandle (handle)" 4
.IX Item "printToFileHandle (handle)"
Prints the entire subtree to the file handle.
E.g. to print to \s-1STDOUT:\s0
.Sp
.Vb 1
\& $node->printToFileHandle (\e*STDOUT);
.Ve
.Ip "print (obj)" 4
.IX Item "print (obj)"
Prints the entire subtree using the object's print method. E.g to print to a
FileHandle object:
.Sp
.Vb 2
\& $f = new FileHandle ("file.out", "w");
\& $node->print ($f);
.Ve
.Ip "getChildIndex (child)" 4
.IX Item "getChildIndex (child)"
Returns the index of the child node in the list returned by getChildNodes.
.Sp
Return Value: the index or \-1 if the node is not found.
.Ip "getChildAtIndex (index)" 4
.IX Item "getChildAtIndex (index)"
Returns the child node at the specifed index or undef.
.Ip "addText (text)" 4
.IX Item "addText (text)"
Appends the specified string to the last child if it is a Text node, or else 
appends a new Text node (with the specified text.)
.Sp
Return Value: the last child if it was a Text node or else the new Text node.
.Ip "dispose" 4
.IX Item "dispose"
Removes all circular references in this node and its descendants so the 
objects can be claimed for garbage collection. The objects should not be used
afterwards.
.Ip "setOwnerDocument (doc)" 4
.IX Item "setOwnerDocument (doc)"
Sets the ownerDocument property of this node and all its children (and 
attributes etc.) to the specified document.
This allows the user to cut and paste document subtrees between different
\&\s-1XML::DOM:\s0:Documents. The node should be removed from the original document
first, before calling setOwnerDocument.
.Sp
This method does nothing when called on a Document node.
.Ip "isAncestor (parent)" 4
.IX Item "isAncestor (parent)"
Returns 1 if parent is an ancestor of this node or if it is this node itself.
.Ip "expandEntityRefs (str)" 4
.IX Item "expandEntityRefs (str)"
Expands all the entity references in the string and returns the result.
The entity references can be character references (e.g. \*(L"&#123;\*(R" or \*(L"&#x1fc2\*(R"),
default entity references (\*(L"&quot;\*(R", \*(L"&gt;\*(R", \*(L"&lt;\*(R", \*(L"&apos;\*(R" and \*(L"&amp;\*(R") or
entity references defined in Entity objects as part of the DocumentType of
the owning Document. Character references are expanded into \s-1UTF-8\s0.
Parameter entity references (e.g. \f(CW%ent\fR;) are not expanded.
.RE
.RS 4
.RE
.Ip "Interface \s-1XML::DOM:\s0:NodeList" 4
.IX Item "Interface XML::DOM::NodeList"
The NodeList interface provides the abstraction of an ordered
collection of nodes, without defining or constraining how this
collection is implemented.
.Sp
The items in the NodeList are accessible via an integral index,
starting from 0.
.Sp
Although the \s-1DOM\s0 spec states that all NodeLists are \*(L"live\*(R" in that they
allways reflect changes to the \s-1DOM\s0 tree, the NodeList returned by
getElementsByTagName is not live in this implementation. See the CAVEATS manpage
for details.
.RS 4
.Ip "item (index)" 4
.IX Item "item (index)"
Returns the indexth item in the collection. If index is
greater than or equal to the number of nodes in the list,
this returns undef.
.Ip "getLength" 4
.IX Item "getLength"
The number of nodes in the list. The range of valid child
node indices is 0 to length-1 inclusive.
.Sh "Additional methods not in the \s-1DOM\s0 Spec"
.IX Subsection "Additional methods not in the DOM Spec"
.Ip "dispose" 4
.IX Item "dispose"
Removes all circular references in this NodeList and its descendants so the 
objects can be claimed for garbage collection. The objects should not be used
afterwards.
.RE
.RS 4
.RE
.Ip "Interface \s-1XML::DOM:\s0:NamedNodeMap" 4
.IX Item "Interface XML::DOM::NamedNodeMap"
Objects implementing the NamedNodeMap interface are used to represent
collections of nodes that can be accessed by name. Note that
NamedNodeMap does not inherit from NodeList; NamedNodeMaps are not
maintained in any particular order. Objects contained in an object
implementing NamedNodeMap may also be accessed by an ordinal index, but
this is simply to allow convenient enumeration of the contents of a
NamedNodeMap, and does not imply that the \s-1DOM\s0 specifies an order to
these Nodes.
.Sp
Note that in this implementation, the objects added to a NamedNodeMap
are kept in order.
.RS 4
.Ip "getNamedItem (name)" 4
.IX Item "getNamedItem (name)"
Retrieves a node specified by name.
.Sp
Return Value: A Node (of any type) with the specified name, or undef if
the specified name did not identify any node in the map.
.Ip "setNamedItem (arg)" 4
.IX Item "setNamedItem (arg)"
Adds a node using its nodeName attribute.
.Sp
As the nodeName attribute is used to derive the name which
the node must be stored under, multiple nodes of certain
types (those that have a \*(L"special\*(R" string value) cannot be
stored as the names would clash. This is seen as preferable
to allowing nodes to be aliased.
.Sp
Parameters:
 \fIarg\fR  A node to store in a named node map. 
.Sp
The node will later be accessible using the value of the nodeName
attribute of the node. If a node with that name is
already present in the map, it is replaced by the new one.
.Sp
Return Value: If the new Node replaces an existing node with the same
name the previously existing Node is returned, otherwise undef is returned.
.Sp
DOMExceptions:
.RS 4
.Ip "\(bu \s-1WRONG_DOCUMENT_ERR\s0" 4
.IX Item "WRONG_DOCUMENT_ERR"
Raised if arg was created from a different document than the one that 
created the NamedNodeMap.
.Ip "\(bu \s-1NO_MODIFICATION_ALLOWED_ERR\s0" 4
.IX Item "NO_MODIFICATION_ALLOWED_ERR"
Raised if this NamedNodeMap is readonly.
.Ip "\(bu \s-1INUSE_ATTRIBUTE_ERR\s0" 4
.IX Item "INUSE_ATTRIBUTE_ERR"
Raised if arg is an Attr that is already an attribute of another Element object.
The \s-1DOM\s0 user must explicitly clone Attr nodes to re-use them in other elements.
.RE
.RS 4
.RE
.Ip "removeNamedItem (name)" 4
.IX Item "removeNamedItem (name)"
Removes a node specified by name. If the removed node is an
Attr with a default value it is immediately replaced.
.Sp
Return Value: The node removed from the map or undef if no node with
such a name exists.
.Sp
DOMException:
.RS 4
.Ip "\(bu \s-1NOT_FOUND_ERR\s0" 4
.IX Item "NOT_FOUND_ERR"
Raised if there is no node named name in the map.
.RE
.RS 4
.RE
.Ip "item (index)" 4
.IX Item "item (index)"
Returns the indexth item in the map. If index is greater than
or equal to the number of nodes in the map, this returns undef.
.Sp
Return Value: The node at the indexth position in the NamedNodeMap, or
undef if that is not a valid index.
.Ip "getLength" 4
.IX Item "getLength"
Returns the number of nodes in the map. The range of valid child node
indices is 0 to length-1 inclusive.
.Sh "Additional methods not in the \s-1DOM\s0 Spec"
.IX Subsection "Additional methods not in the DOM Spec"
.Ip "getValues" 4
.IX Item "getValues"
Returns a NodeList with the nodes contained in the NamedNodeMap.
The NodeList is \*(L"live\*(R", in that it reflects changes made to the NamedNodeMap.
.Sp
When this method is called in a list context, it returns a regular perl list
containing the values. Note that this list is not \*(L"live\*(R". E.g.
.Sp
.Vb 3
\& @list = $map->getValues;        # returns a perl list
\& $nodelist = $map->getValues;    # returns a NodeList (object ref.)
\& for my $val ($map->getValues)   # iterate over the values
.Ve
.Ip "getChildIndex (node)" 4
.IX Item "getChildIndex (node)"
Returns the index of the node in the NodeList as returned by getValues, or \-1
if the node is not in the NamedNodeMap.
.Ip "dispose" 4
.IX Item "dispose"
Removes all circular references in this NamedNodeMap and its descendants so the 
objects can be claimed for garbage collection. The objects should not be used
afterwards.
.RE
.RS 4
.RE
.Ip "Interface \s-1XML::DOM:\s0:CharacterData extends \s-1XML::DOM:\s0:Node" 4
.IX Item "Interface XML::DOM::CharacterData extends XML::DOM::Node"
The CharacterData interface extends Node with a set of attributes and
methods for accessing character data in the \s-1DOM\s0. For clarity this set
is defined here rather than on each object that uses these attributes
and methods. No \s-1DOM\s0 objects correspond directly to CharacterData,
though Text, Comment and CDATASection do inherit the interface from it. 
All offsets in this interface start from 0.
.RS 4
.Ip "getData and setData (data)" 4
.IX Item "getData and setData (data)"
The character data of the node that implements this
interface. The \s-1DOM\s0 implementation may not put arbitrary
limits on the amount of data that may be stored in a
CharacterData node. However, implementation limits may mean
that the entirety of a node's data may not fit into a single
DOMString. In such cases, the user may call substringData to
retrieve the data in appropriately sized pieces.
.Ip "getLength" 4
.IX Item "getLength"
The number of characters that are available through data and
the substringData method below. This may have the value zero,
i.e., CharacterData nodes may be empty.
.Ip "substringData (offset, count)" 4
.IX Item "substringData (offset, count)"
Extracts a range of data from the node.
.Sp
Parameters:
 \fIoffset\fR  Start offset of substring to extract.
 \fIcount\fR   The number of characters to extract.
.Sp
Return Value: The specified substring. If the sum of offset and count
exceeds the length, then all characters to the end of
the data are returned.
.Ip "appendData (str)" 4
.IX Item "appendData (str)"
Appends the string to the end of the character data of the
node. Upon success, data provides access to the concatenation
of data and the DOMString specified.
.Ip "insertData (offset, arg)" 4
.IX Item "insertData (offset, arg)"
Inserts a string at the specified character offset.
.Sp
Parameters:
 \fIoffset\fR  The character offset at which to insert.
 \fIarg\fR     The DOMString to insert.
.Ip "deleteData (offset, count)" 4
.IX Item "deleteData (offset, count)"
Removes a range of characters from the node. 
Upon success, data and length reflect the change.
If the sum of offset and count exceeds length then all characters 
from offset to the end of the data are deleted.
.Sp
Parameters: 
 \fIoffset\fR  The offset from which to remove characters. 
 \fIcount\fR   The number of characters to delete. 
.Ip "replaceData (offset, count, arg)" 4
.IX Item "replaceData (offset, count, arg)"
Replaces the characters starting at the specified character
offset with the specified string.
.Sp
Parameters:
 \fIoffset\fR  The offset from which to start replacing.
 \fIcount\fR   The number of characters to replace. 
 \fIarg\fR     The DOMString with which the range must be replaced.
.Sp
If the sum of offset and count exceeds length, then all characters to the end of
the data are replaced (i.e., the effect is the same as a remove method call with 
the same range, followed by an append method invocation).
.RE
.RS 4
.RE
.Ip "\s-1XML::DOM:\s0:Attr extends \s-1XML::DOM:\s0:Node" 4
.IX Item "XML::DOM::Attr extends XML::DOM::Node"
.RS 4
The Attr nodes built by the \s-1XML::DOM:\s0:Parser always have one child node
which is a Text node containing the expanded string value (i.e. EntityReferences
are always expanded.) EntityReferences may be added when modifying or creating
a new Document.
.Sp
The Attr interface represents an attribute in an Element object.
Typically the allowable values for the attribute are defined in a
document type definition.
.Sp
Attr objects inherit the Node interface, but since they are not
actually child nodes of the element they describe, the \s-1DOM\s0 does not
consider them part of the document tree. Thus, the Node attributes
parentNode, previousSibling, and nextSibling have a undef value for Attr
objects. The \s-1DOM\s0 takes the view that attributes are properties of
elements rather than having a separate identity from the elements they
are associated with; this should make it more efficient to implement
such features as default attributes associated with all elements of a
given type. Furthermore, Attr nodes may not be immediate children of a
DocumentFragment. However, they can be associated with Element nodes
contained within a DocumentFragment. In short, users and implementors
of the \s-1DOM\s0 need to be aware that Attr nodes have some things in common
with other objects inheriting the Node interface, but they also are
quite distinct.
.Sp
The attribute's effective value is determined as follows: if this
attribute has been explicitly assigned any value, that value is the
attribute's effective value; otherwise, if there is a declaration for
this attribute, and that declaration includes a default value, then
that default value is the attribute's effective value; otherwise, the
attribute does not exist on this element in the structure model until
it has been explicitly added. Note that the nodeValue attribute on the
Attr instance can also be used to retrieve the string version of the
attribute's \fIvalue\fR\|(s).
.Sp
In \s-1XML\s0, where the value of an attribute can contain entity references,
the child nodes of the Attr node provide a representation in which
entity references are not expanded. These child nodes may be either
Text or EntityReference nodes. Because the attribute type may be
unknown, there are no tokenized attribute values.
.Ip "getValue" 4
.IX Item "getValue"
On retrieval, the value of the attribute is returned as a string. 
Character and general entity references are replaced with their values.
.Ip "setValue (str)" 4
.IX Item "setValue (str)"
\&\s-1DOM\s0 Spec: On setting, this creates a Text node with the unparsed contents of the 
string.
.Ip "getName" 4
.IX Item "getName"
Returns the name of this attribute.
.RE
.RS 4
.RE
.Ip "\s-1XML::DOM:\s0:Element extends \s-1XML::DOM:\s0:Node" 4
.IX Item "XML::DOM::Element extends XML::DOM::Node"
By far the vast majority of objects (apart from text) that authors
encounter when traversing a document are Element nodes. Assume the
following \s-1XML\s0 document:
.Sp
.Vb 4
\&     <elementExample id="demo">
\&       <subelement1/>
\&       <subelement2><subsubelement/></subelement2>
\&     </elementExample>
.Ve
When represented using \s-1DOM\s0, the top node is an Element node for
\&\*(L"elementExample\*(R", which contains two child Element nodes, one for
\&\*(L"subelement1\*(R" and one for \*(L"subelement2\*(R". \*(L"subelement1\*(R" contains no
child nodes.
.Sp
Elements may have attributes associated with them; since the Element
interface inherits from Node, the generic Node interface method
getAttributes may be used to retrieve the set of all attributes for an
element. There are methods on the Element interface to retrieve either
an Attr object by name or an attribute value by name. In \s-1XML\s0, where an
attribute value may contain entity references, an Attr object should be
retrieved to examine the possibly fairly complex sub-tree representing
the attribute value. On the other hand, in \s-1HTML\s0, where all attributes
have simple string values, methods to directly access an attribute
value can safely be used as a convenience.
.RS 4
.Ip "getTagName" 4
.IX Item "getTagName"
The name of the element. For example, in:
.Sp
.Vb 3
\&               <elementExample id="demo">
\&                       ...
\&               </elementExample>
.Ve
tagName has the value \*(L"elementExample\*(R". Note that this is
case-preserving in \s-1XML\s0, as are all of the operations of the
\&\s-1DOM\s0.
.Ip "getAttribute (name)" 4
.IX Item "getAttribute (name)"
Retrieves an attribute value by name.
.Sp
Return Value: The Attr value as a string, or the empty string if that
attribute does not have a specified or default value.
.Ip "setAttribute (name, value)" 4
.IX Item "setAttribute (name, value)"
Adds a new attribute. If an attribute with that name is
already present in the element, its value is changed to be
that of the value parameter. This value is a simple string,
it is not parsed as it is being set. So any markup (such as
syntax to be recognized as an entity reference) is treated as
literal text, and needs to be appropriately escaped by the
implementation when it is written out. In order to assign an
attribute value that contains entity references, the user
must create an Attr node plus any Text and EntityReference
nodes, build the appropriate subtree, and use
setAttributeNode to assign it as the value of an attribute.
.Sp
DOMExceptions:
.RS 4
.Ip "\(bu \s-1INVALID_CHARACTER_ERR\s0" 4
.IX Item "INVALID_CHARACTER_ERR"
Raised if the specified name contains an invalid character.
.Ip "\(bu \s-1NO_MODIFICATION_ALLOWED_ERR\s0" 4
.IX Item "NO_MODIFICATION_ALLOWED_ERR"
Raised if this node is readonly.
.RE
.RS 4
.RE
.Ip "removeAttribute (name)" 4
.IX Item "removeAttribute (name)"
Removes an attribute by name. If the removed attribute has a
default value it is immediately replaced.
.Sp
DOMExceptions:
.RS 4
.Ip "\(bu \s-1NO_MODIFICATION_ALLOWED_ERR\s0" 4
.IX Item "NO_MODIFICATION_ALLOWED_ERR"
Raised if this node is readonly.
.RE
.RS 4
.RE
.Ip "getAttributeNode" 4
.IX Item "getAttributeNode"
Retrieves an Attr node by name.
.Sp
Return Value: The Attr node with the specified attribute name or undef
if there is no such attribute.
.Ip "setAttributeNode (attr)" 4
.IX Item "setAttributeNode (attr)"
Adds a new attribute. If an attribute with that name is
already present in the element, it is replaced by the new one.
.Sp
Return Value: If the newAttr attribute replaces an existing attribute
with the same name, the previously existing Attr node is
returned, otherwise undef is returned.
.Sp
DOMExceptions:
.RS 4
.Ip "\(bu \s-1WRONG_DOCUMENT_ERR\s0" 4
.IX Item "WRONG_DOCUMENT_ERR"
Raised if newAttr was created from a different document than the one that created
the element.
.Ip "\(bu \s-1NO_MODIFICATION_ALLOWED_ERR\s0" 4
.IX Item "NO_MODIFICATION_ALLOWED_ERR"
Raised if this node is readonly.
.Ip "\(bu \s-1INUSE_ATTRIBUTE_ERR\s0" 4
.IX Item "INUSE_ATTRIBUTE_ERR"
Raised if newAttr is already an attribute of another Element object. The \s-1DOM\s0
user must explicitly clone Attr nodes to re-use them in other elements.
.RE
.RS 4
.RE
.Ip "removeAttributeNode (oldAttr)" 4
.IX Item "removeAttributeNode (oldAttr)"
Removes the specified attribute. If the removed Attr has a default value it is
immediately replaced. If the Attr already is the default value, nothing happens
and nothing is returned.
.Sp
Parameters:
 \fIoldAttr\fR  The Attr node to remove from the attribute list. 
.Sp
Return Value: The Attr node that was removed.
.Sp
DOMExceptions:
.RS 4
.Ip "\(bu \s-1NO_MODIFICATION_ALLOWED_ERR\s0" 4
.IX Item "NO_MODIFICATION_ALLOWED_ERR"
Raised if this node is readonly.
.Ip "\(bu \s-1NOT_FOUND_ERR\s0" 4
.IX Item "NOT_FOUND_ERR"
Raised if oldAttr is not an attribute of the element.
.RE
.RS 4
.Sh "Additional methods not in the \s-1DOM\s0 Spec"
.IX Subsection "Additional methods not in the DOM Spec"
.RE
.Ip "setTagName (newTagName)" 4
.IX Item "setTagName (newTagName)"
Sets the tag name of the Element. Note that this method is not portable
between \s-1DOM\s0 implementations.
.Sp
DOMExceptions:
.RS 4
.Ip "\(bu \s-1INVALID_CHARACTER_ERR\s0" 4
.IX Item "INVALID_CHARACTER_ERR"
Raised if the specified name contains an invalid character.
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.Ip "\s-1XML::DOM:\s0:Text extends \s-1XML::DOM:\s0:CharacterData" 4
.IX Item "XML::DOM::Text extends XML::DOM::CharacterData"
The Text interface represents the textual content (termed character
data in \s-1XML\s0) of an Element or Attr. If there is no markup inside an
element's content, the text is contained in a single object
implementing the Text interface that is the only child of the element.
If there is markup, it is parsed into a list of elements and Text nodes
that form the list of children of the element.
.Sp
When a document is first made available via the \s-1DOM\s0, there is only one
Text node for each block of text. Users may create adjacent Text nodes
that represent the contents of a given element without any intervening
markup, but should be aware that there is no way to represent the
separations between these nodes in \s-1XML\s0 or \s-1HTML\s0, so they will not (in
general) persist between \s-1DOM\s0 editing sessions. The \fInormalize()\fR method
on Element merges any such adjacent Text objects into a single node for
each block of text; this is recommended before employing operations
that depend on a particular document structure, such as navigation with
XPointers.
.Sp
\&\fBNot Implemented\fR: The \s-1XML::DOM:\s0:Parser converts all CDATASections to regular 
text, so as far as I know, there is know way to preserve them. 
If you add CDATASection nodes to a Document yourself, they will be preserved.
.RS 4
.Ip "splitText (offset)" 4
.IX Item "splitText (offset)"
Breaks this Text node into two Text nodes at the specified
offset, keeping both in the tree as siblings. This node then
only contains all the content up to the offset point. And a
new Text node, which is inserted as the next sibling of this
node, contains all the content at and after the offset point.
.Sp
Parameters:
 \fIoffset\fR  The offset at which to split, starting from 0.
.Sp
Return Value: The new Text node.
.Sp
DOMExceptions:
.RS 4
.Ip "\(bu \s-1INDEX_SIZE_ERR\s0" 4
.IX Item "INDEX_SIZE_ERR"
Raised if the specified offset is negative or greater than the number of 
characters in data.
.Ip "\(bu \s-1NO_MODIFICATION_ALLOWED_ERR\s0" 4
.IX Item "NO_MODIFICATION_ALLOWED_ERR"
Raised if this node is readonly.
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.Ip "\s-1XML::DOM:\s0:Comment extends \s-1XML::DOM:\s0:CharacterData" 4
.IX Item "XML::DOM::Comment extends XML::DOM::CharacterData"
This represents the content of a comment, i.e., all the characters
between the starting '<!\-\-' and ending '\-\->'. Note that this is the
definition of a comment in \s-1XML\s0, and, in practice, \s-1HTML\s0, although some
\&\s-1HTML\s0 tools may implement the full \s-1SGML\s0 comment structure.
.Ip "\s-1XML::DOM:\s0:CDATASection extends \s-1XML::DOM:\s0:CharacterData" 4
.IX Item "XML::DOM::CDATASection extends XML::DOM::CharacterData"
\&\s-1CDATA\s0 sections are used to escape blocks of text containing characters
that would otherwise be regarded as markup. The only delimiter that is
recognized in a \s-1CDATA\s0 section is the \*(L"]]>\*(R" string that ends the \s-1CDATA\s0
section. \s-1CDATA\s0 sections can not be nested. The primary purpose is for
including material such as \s-1XML\s0 fragments, without needing to escape all
the delimiters.
.Sp
The DOMString attribute of the Text node holds the text that is
contained by the \s-1CDATA\s0 section. Note that this may contain characters
that need to be escaped outside of \s-1CDATA\s0 sections and that, depending
on the character encoding (\*(L"charset\*(R") chosen for serialization, it may
be impossible to write out some characters as part of a \s-1CDATA\s0 section.
.Sp
The CDATASection interface inherits the CharacterData interface through
the Text interface. Adjacent CDATASections nodes are not merged by use
of the Element.\fInormalize()\fR method.
.Sp
\&\fBNot Implemented\fR: see Text node comments about CDATASections being converted 
to Text nodes when parsing \s-1XML\s0 input.
.Ip "\s-1XML::DOM:\s0:ProcessingInstruction extends \s-1XML::DOM:\s0:Node" 4
.IX Item "XML::DOM::ProcessingInstruction extends XML::DOM::Node"
The ProcessingInstruction interface represents a \*(L"processing
instruction\*(R", used in \s-1XML\s0 as a way to keep processor-specific
information in the text of the document. An example:
.Sp
.Vb 1
\& <?PI processing instruction?>
.Ve
Here, \*(L"\*(PI\*(R" is the target and \*(L"processing instruction\*(R" is the data.
.RS 4
.Ip "getTarget" 4
.IX Item "getTarget"
The target of this processing instruction. \s-1XML\s0 defines this
as being the first token following the markup that begins the
processing instruction.
.Ip "getData and setData (data)" 4
.IX Item "getData and setData (data)"
The content of this processing instruction. This is from the
first non white space character after the target to the
character immediately preceding the ?>.
.RE
.RS 4
.RE
.Ip "\s-1XML::DOM:\s0:Notation extends \s-1XML::DOM:\s0:Node" 4
.IX Item "XML::DOM::Notation extends XML::DOM::Node"
This node represents a Notation, e.g.
.Sp
.Vb 1
\& <!NOTATION gs SYSTEM "GhostScript">
.Ve
.Vb 1
\& <!NOTATION name PUBLIC "pubId">
.Ve
.Vb 1
\& <!NOTATION name PUBLIC "pubId" "sysId">
.Ve
.Vb 1
\& <!NOTATION name SYSTEM "sysId">
.Ve
.RS 4
.Ip "getName and setName (name)" 4
.IX Item "getName and setName (name)"
Returns (or sets) the Notation name, which is the first token after the 
\&\s-1NOTATION\s0 keyword.
.Ip "getSysId and setSysId (sysId)" 4
.IX Item "getSysId and setSysId (sysId)"
Returns (or sets) the system \s-1ID\s0, which is the token after the optional
\&\s-1SYSTEM\s0 keyword.
.Ip "getPubId and setPubId (pubId)" 4
.IX Item "getPubId and setPubId (pubId)"
Returns (or sets) the public \s-1ID\s0, which is the token after the optional
\&\s-1PUBLIC\s0 keyword.
.Ip "getBase" 4
.IX Item "getBase"
This is passed by \s-1XML:\s0:Parser in the Notation handler. 
I don't know what it is yet.
.Ip "getNodeName" 4
.IX Item "getNodeName"
Returns the same as getName.
.RE
.RS 4
.RE
.Ip "\s-1XML::DOM:\s0:Entity extends \s-1XML::DOM:\s0:Node" 4
.IX Item "XML::DOM::Entity extends XML::DOM::Node"
This node represents an Entity declaration, e.g.
.Sp
.Vb 1
\& <!ENTITY % draft 'INCLUDE'>
.Ve
.Vb 1
\& <!ENTITY hatch-pic SYSTEM "../grafix/OpenHatch.gif" NDATA gif>
.Ve
The first one is called a parameter entity and is referenced like this: \f(CW%draft\fR;
The 2nd is a (regular) entity and is referenced like this: &hatch-pic;
.RS 4
.Ip "getNotationName" 4
.IX Item "getNotationName"
Returns the name of the notation for the entity.
.Sp
\&\fINot Implemented\fR The \s-1DOM\s0 Spec says: For unparsed entities, the name of the 
notation for the entity. For parsed entities, this is null.
(This implementation does not support unparsed entities.)
.Ip "getSysId" 4
.IX Item "getSysId"
Returns the system id, or undef.
.Ip "getPubId" 4
.IX Item "getPubId"
Returns the public id, or undef.
.Sh "Additional methods not in the \s-1DOM\s0 Spec"
.IX Subsection "Additional methods not in the DOM Spec"
.Ip "isParameterEntity" 4
.IX Item "isParameterEntity"
Whether it is a parameter entity (%ent;) or not (&ent;)
.Ip "getValue" 4
.IX Item "getValue"
Returns the entity value.
.Ip "getNdata" 4
.IX Item "getNdata"
Returns the \s-1NDATA\s0 declaration (for general unparsed entities), or undef.
.RE
.RS 4
.RE
.Ip "\s-1XML::DOM:\s0:DocumentType extends \s-1XML::DOM:\s0:Node" 4
.IX Item "XML::DOM::DocumentType extends XML::DOM::Node"
Each Document has a doctype attribute whose value is either null or a
DocumentType object. The DocumentType interface in the \s-1DOM\s0 Level 1 Core
provides an interface to the list of entities that are defined for the
document, and little else because the effect of namespaces and the
various \s-1XML\s0 scheme efforts on \s-1DTD\s0 representation are not clearly
understood as of this writing. 
The \s-1DOM\s0 Level 1 doesn't support editing DocumentType nodes.
.Sp
\&\fBNot In \s-1DOM\s0 Spec\fR: This implementation has added a lot of extra 
functionality to the \s-1DOM\s0 Level 1 interface. 
To allow editing of the DocumentType nodes, see \s-1XML::DOM:\s0:ignoreReadOnly.
.RS 4
.Ip "getName" 4
.IX Item "getName"
Returns the name of the \s-1DTD\s0, i.e. the name immediately following the
\&\s-1DOCTYPE\s0 keyword.
.Ip "getEntities" 4
.IX Item "getEntities"
A NamedNodeMap containing the general entities, both external
and internal, declared in the \s-1DTD\s0. Duplicates are discarded.
For example in:
.Sp
.Vb 6
\& <!DOCTYPE ex SYSTEM "ex.dtd" [
\&  <!ENTITY foo "foo">
\&  <!ENTITY bar "bar">
\&  <!ENTITY % baz "baz">
\& ]>
\& <ex/>
.Ve
the interface provides access to foo and bar but not baz.
Every node in this map also implements the Entity interface.
.Sp
The \s-1DOM\s0 Level 1 does not support editing entities, therefore
entities cannot be altered in any way.
.Sp
\&\fBNot In \s-1DOM\s0 Spec\fR: See \s-1XML::DOM:\s0:ignoreReadOnly to edit the DocumentType etc.
.Ip "getNotations" 4
.IX Item "getNotations"
A NamedNodeMap containing the notations declared in the \s-1DTD\s0.
Duplicates are discarded. Every node in this map also
implements the Notation interface.
.Sp
The \s-1DOM\s0 Level 1 does not support editing notations, therefore
notations cannot be altered in any way.
.Sp
\&\fBNot In \s-1DOM\s0 Spec\fR: See \s-1XML::DOM:\s0:ignoreReadOnly to edit the DocumentType etc.
.Sh "Additional methods not in the \s-1DOM\s0 Spec"
.IX Subsection "Additional methods not in the DOM Spec"
.Ip "Creating and setting the DocumentType" 4
.IX Item "Creating and setting the DocumentType"
A new DocumentType can be created with:
.Sp
.Vb 1
\&        $doctype = $doc->createDocumentType ($name, $sysId, $pubId, $internal);
.Ve
To set (or replace) the DocumentType for a particular document, use:
.Sp
.Vb 1
\&        $doc->setDocType ($doctype);
.Ve
.Ip "getSysId and setSysId (sysId)" 4
.IX Item "getSysId and setSysId (sysId)"
Returns or sets the system id.
.Ip "getPubId and setPubId (pudId)" 4
.IX Item "getPubId and setPubId (pudId)"
Returns or sets the public id.
.Ip "setName (name)" 4
.IX Item "setName (name)"
Sets the name of the \s-1DTD\s0, i.e. the name immediately following the
\&\s-1DOCTYPE\s0 keyword. Note that this should always be the same as the element
tag name of the root element.
.Ip "getAttlistDecl (elemName)" 4
.IX Item "getAttlistDecl (elemName)"
Returns the AttlistDecl for the Element with the specified name, or undef.
.Ip "getElementDecl (elemName)" 4
.IX Item "getElementDecl (elemName)"
Returns the ElementDecl for the Element with the specified name, or undef.
.Ip "getEntity (entityName)" 4
.IX Item "getEntity (entityName)"
Returns the Entity with the specified name, or undef.
.Ip "addAttlistDecl (elemName)" 4
.IX Item "addAttlistDecl (elemName)"
Adds a new AttDecl node with the specified elemName if one doesn't exist yet.
Returns the AttlistDecl (new or existing) node.
.Ip "addElementDecl (elemName, model)" 4
.IX Item "addElementDecl (elemName, model)"
Adds a new ElementDecl node with the specified elemName and model if one doesn't 
exist yet.
Returns the AttlistDecl (new or existing) node. The model is ignored if one
already existed.
.Ip "addEntity (parameter, notationName, value, sysId, pubId, ndata)" 4
.IX Item "addEntity (parameter, notationName, value, sysId, pubId, ndata)"
Adds a new Entity node. Don't use createEntity and appendChild, because it should
be added to the internal NamedNodeMap containing the entities.
.Sp
Parameters:
 \fIparameter\fR	 whether it is a parameter entity (%ent;) or not (&ent;).
 \fInotationName\fR the entity name.
 \fIvalue\fR        the entity value.
 \fIsysId\fR        the system id (if any.)
 \fIpubId\fR        the public id (if any.)
 \fIndata\fR        the \s-1NDATA\s0 declaration (if any, for general unparsed entities.)
.Sp
SysId, pubId and ndata may be undefined.
.Sp
DOMExceptions:
.RS 4
.Ip "\(bu \s-1INVALID_CHARACTER_ERR\s0" 4
.IX Item "INVALID_CHARACTER_ERR"
Raised if the notationName does not conform to the \s-1XML\s0 spec.
.RE
.RS 4
.RE
.Ip "addNotation (name, base, sysId, pubId)" 4
.IX Item "addNotation (name, base, sysId, pubId)"
Adds a new Notation object. 
.Sp
Parameters:
 \fIname\fR   the notation name.
 \fIbase\fR   the base to be used for resolving a relative \s-1URI\s0.
 \fIsysId\fR  the system id.
 \fIpubId\fR  the public id.
.Sp
Base, sysId, and pubId may all be undefined.
(These parameters are passed by the \s-1XML:\s0:Parser Notation handler.)
.Sp
DOMExceptions:
.RS 4
.Ip "\(bu \s-1INVALID_CHARACTER_ERR\s0" 4
.IX Item "INVALID_CHARACTER_ERR"
Raised if the notationName does not conform to the \s-1XML\s0 spec.
.RE
.RS 4
.RE
.Ip "addAttDef (elemName, attrName, type, default, fixed)" 4
.IX Item "addAttDef (elemName, attrName, type, default, fixed)"
Adds a new attribute definition. It will add the AttDef node to the AttlistDecl
if it exists. If an AttDef with the specified attrName already exists for the
given elemName, this function only generates a warning.
.Sp
See \s-1XML::DOM:\s0:AttDef::new for the other parameters.
.Ip "getDefaultAttrValue (elem, attr)" 4
.IX Item "getDefaultAttrValue (elem, attr)"
Returns the default attribute value as a string or undef, if none is available.
.Sp
Parameters:
 \fIelem\fR    The element tagName.
 \fIattr\fR    The attribute name.
.Ip "expandEntity (entity [, parameter])" 4
.IX Item "expandEntity (entity [, parameter])"
Expands the specified entity or parameter entity (if parameter=1) and returns
its value as a string, or undef if the entity does not exist.
(The entity name should not contain the '%', '&' or ';' delimiters.)
.RE
.RS 4
.RE
.Ip "\s-1XML::DOM:\s0:DocumentFragment extends \s-1XML::DOM:\s0:Node" 4
.IX Item "XML::DOM::DocumentFragment extends XML::DOM::Node"
DocumentFragment is a \*(L"lightweight\*(R" or \*(L"minimal\*(R" Document object. It is
very common to want to be able to extract a portion of a document's
tree or to create a new fragment of a document. Imagine implementing a
user command like cut or rearranging a document by moving fragments
around. It is desirable to have an object which can hold such fragments
and it is quite natural to use a Node for this purpose. While it is
true that a Document object could fulfil this role, a Document object
can potentially be a heavyweight object, depending on the underlying
implementation. What is really needed for this is a very lightweight
object. DocumentFragment is such an object.
.Sp
Furthermore, various operations \*(-- such as inserting nodes as children
of another Node \*(-- may take DocumentFragment objects as arguments; this
results in all the child nodes of the DocumentFragment being moved to
the child list of this node.
.Sp
The children of a DocumentFragment node are zero or more nodes
representing the tops of any sub-trees defining the structure of the
document. DocumentFragment nodes do not need to be well-formed \s-1XML\s0
documents (although they do need to follow the rules imposed upon
well-formed \s-1XML\s0 parsed entities, which can have multiple top nodes).
For example, a DocumentFragment might have only one child and that
child node could be a Text node. Such a structure model represents
neither an \s-1HTML\s0 document nor a well-formed \s-1XML\s0 document.
.Sp
When a DocumentFragment is inserted into a Document (or indeed any
other Node that may take children) the children of the DocumentFragment
and not the DocumentFragment itself are inserted into the Node. This
makes the DocumentFragment very useful when the user wishes to create
nodes that are siblings; the DocumentFragment acts as the parent of
these nodes so that the user can use the standard methods from the Node
interface, such as \fIinsertBefore()\fR and \fIappendChild()\fR.
.Ip "\s-1XML::DOM:\s0:DOMImplementation" 4
.IX Item "XML::DOM::DOMImplementation"
The DOMImplementation interface provides a number of methods for
performing operations that are independent of any particular instance
of the document object model.
.Sp
The \s-1DOM\s0 Level 1 does not specify a way of creating a document instance,
and hence document creation is an operation specific to an
implementation. Future Levels of the \s-1DOM\s0 specification are expected to
provide methods for creating documents directly.
.RS 4
.Ip "hasFeature (feature, version)" 4
.IX Item "hasFeature (feature, version)"
Returns 1 if and only if feature equals \*(L"\s-1XML\s0\*(R" and version equals \*(L"1.0\*(R".
.RE
.RS 4
.RE
.Ip "\s-1XML::DOM:\s0:Document extends \s-1XML::DOM:\s0:Node" 4
.IX Item "XML::DOM::Document extends XML::DOM::Node"
This is the main root of the document structure as returned by 
\&\s-1XML::DOM:\s0:Parser::parse and \s-1XML::DOM:\s0:Parser::parsefile.
.Sp
Since elements, text nodes, comments, processing instructions, etc.
cannot exist outside the context of a Document, the Document interface
also contains the factory methods needed to create these objects. The
Node objects created have a getOwnerDocument method which associates
them with the Document within whose context they were created.
.RS 4
.Ip "getDocumentElement" 4
.IX Item "getDocumentElement"
This is a convenience method that allows direct access to
the child node that is the root Element of the document.
.Ip "getDoctype" 4
.IX Item "getDoctype"
The Document Type Declaration (see DocumentType) associated
with this document. For \s-1HTML\s0 documents as well as \s-1XML\s0
documents without a document type declaration this returns
undef. The \s-1DOM\s0 Level 1 does not support editing the Document
Type Declaration.
.Sp
\&\fBNot In \s-1DOM\s0 Spec\fR: This implementation allows editing the doctype. 
See \fI\s-1XML::DOM:\s0:ignoreReadOnly\fR for details.
.Ip "getImplementation" 4
.IX Item "getImplementation"
The DOMImplementation object that handles this document. A
\&\s-1DOM\s0 application may use objects from multiple implementations.
.Ip "createElement (tagName)" 4
.IX Item "createElement (tagName)"
Creates an element of the type specified. Note that the
instance returned implements the Element interface, so
attributes can be specified directly on the returned object.
.Sp
DOMExceptions:
.RS 4
.Ip "\(bu \s-1INVALID_CHARACTER_ERR\s0" 4
.IX Item "INVALID_CHARACTER_ERR"
Raised if the tagName does not conform to the \s-1XML\s0 spec.
.RE
.RS 4
.RE
.Ip "createTextNode (data)" 4
.IX Item "createTextNode (data)"
Creates a Text node given the specified string.
.Ip "createComment (data)" 4
.IX Item "createComment (data)"
Creates a Comment node given the specified string.
.Ip "createCDATASection (data)" 4
.IX Item "createCDATASection (data)"
Creates a CDATASection node given the specified string.
.Ip "createAttribute (name [, value [, specified ]])" 4
.IX Item "createAttribute (name [, value [, specified ]])"
Creates an Attr of the given name. Note that the Attr
instance can then be set on an Element using the setAttribute method.
.Sp
\&\fBNot In \s-1DOM\s0 Spec\fR: The \s-1DOM\s0 Spec does not allow passing the value or the 
specified property in this method. In this implementation they are optional.
.Sp
Parameters:
 \fIvalue\fR     The attribute's value. See Attr::setValue for details.
              If the value is not supplied, the specified property is set to 0.
 \fIspecified\fR Whether the attribute value was specified or whether the default
              value was used. If not supplied, it's assumed to be 1.
.Sp
DOMExceptions:
.RS 4
.Ip "\(bu \s-1INVALID_CHARACTER_ERR\s0" 4
.IX Item "INVALID_CHARACTER_ERR"
Raised if the name does not conform to the \s-1XML\s0 spec.
.RE
.RS 4
.RE
.Ip "createProcessingInstruction (target, data)" 4
.IX Item "createProcessingInstruction (target, data)"
Creates a ProcessingInstruction node given the specified name and data strings.
.Sp
Parameters:
 \fItarget\fR  The target part of the processing instruction.
 \fIdata\fR    The data for the node.
.Sp
DOMExceptions:
.RS 4
.Ip "\(bu \s-1INVALID_CHARACTER_ERR\s0" 4
.IX Item "INVALID_CHARACTER_ERR"
Raised if the target does not conform to the \s-1XML\s0 spec.
.RE
.RS 4
.RE
.Ip "createDocumentFragment" 4
.IX Item "createDocumentFragment"
Creates an empty DocumentFragment object.
.Ip "createEntityReference (name)" 4
.IX Item "createEntityReference (name)"
Creates an EntityReference object.
.Sh "Additional methods not in the \s-1DOM\s0 Spec"
.IX Subsection "Additional methods not in the DOM Spec"
.Ip "getXMLDecl and setXMLDecl (xmlDecl)" 4
.IX Item "getXMLDecl and setXMLDecl (xmlDecl)"
Returns the XMLDecl for this Document or undef if none was specified.
Note that XMLDecl is not part of the list of child nodes.
.Ip "setDoctype (doctype)" 4
.IX Item "setDoctype (doctype)"
Sets or replaces the DocumentType. 
\&\fB\s-1NOTE\s0\fR: Don't use appendChild or insertBefore to set the DocumentType.
Even though doctype will be part of the list of child nodes, it is handled
specially.
.Ip "getDefaultAttrValue (elem, attr)" 4
.IX Item "getDefaultAttrValue (elem, attr)"
Returns the default attribute value as a string or undef, if none is available.
.Sp
Parameters:
 \fIelem\fR    The element tagName.
 \fIattr\fR    The attribute name.
.Ip "getEntity (name)" 4
.IX Item "getEntity (name)"
Returns the Entity with the specified name.
.Ip "createXMLDecl (version, encoding, standalone)" 4
.IX Item "createXMLDecl (version, encoding, standalone)"
Creates an XMLDecl object. All parameters may be undefined.
.Ip "createDocumentType (name, sysId, pubId)" 4
.IX Item "createDocumentType (name, sysId, pubId)"
Creates a DocumentType object. SysId and pubId may be undefined.
.Ip "createNotation (name, base, sysId, pubId)" 4
.IX Item "createNotation (name, base, sysId, pubId)"
Creates a new Notation object. Consider using 
\&\s-1XML::DOM:\s0:DocumentType::addNotation!
.Ip "createEntity (parameter, notationName, value, sysId, pubId, ndata)" 4
.IX Item "createEntity (parameter, notationName, value, sysId, pubId, ndata)"
Creates an Entity object. Consider using \s-1XML::DOM:\s0:DocumentType::addEntity!
.Ip "createElementDecl (name, model)" 4
.IX Item "createElementDecl (name, model)"
Creates an ElementDecl object.
.Sp
DOMExceptions:
.RS 4
.Ip "\(bu \s-1INVALID_CHARACTER_ERR\s0" 4
.IX Item "INVALID_CHARACTER_ERR"
Raised if the element name (tagName) does not conform to the \s-1XML\s0 spec.
.RE
.RS 4
.RE
.Ip "createAttlistDecl (name)" 4
.IX Item "createAttlistDecl (name)"
Creates an AttlistDecl object.
.Sp
DOMExceptions:
.RS 4
.Ip "\(bu \s-1INVALID_CHARACTER_ERR\s0" 4
.IX Item "INVALID_CHARACTER_ERR"
Raised if the element name (tagName) does not conform to the \s-1XML\s0 spec.
.RE
.RS 4
.RE
.Ip "expandEntity (entity [, parameter])" 4
.IX Item "expandEntity (entity [, parameter])"
Expands the specified entity or parameter entity (if parameter=1) and returns
its value as a string, or undef if the entity does not exist.
(The entity name should not contain the '%', '&' or ';' delimiters.)
.RE
.RS 4
.SH "EXTRA NODE TYPES"
.IX Header "EXTRA NODE TYPES"
.RE
.Ip "\s-1XML::DOM:\s0:XMLDecl extends \s-1XML::DOM:\s0:Node" 4
.IX Item "XML::DOM::XMLDecl extends XML::DOM::Node"
This node contains the \s-1XML\s0 declaration, e.g.
.Sp
.Vb 1
\& <?xml version="1.0" encoding="UTF-16" standalone="yes"?>
.Ve
See also \s-1XML::DOM:\s0:Document::getXMLDecl.
.RS 4
.Ip "getVersion and setVersion (version)" 4
.IX Item "getVersion and setVersion (version)"
Returns and sets the \s-1XML\s0 version. At the time of this writing the version should
always be \*(L"1.0\*(R"
.Ip "getEncoding and setEncoding (encoding)" 4
.IX Item "getEncoding and setEncoding (encoding)"
undef may be specified for the encoding value.
.Ip "getStandalone and setStandalone (standalone)" 4
.IX Item "getStandalone and setStandalone (standalone)"
undef may be specified for the standalone value.
.RE
.RS 4
.RE
.Ip "\s-1XML::DOM:\s0:ElementDecl extends \s-1XML::DOM:\s0:Node" 4
.IX Item "XML::DOM::ElementDecl extends XML::DOM::Node"
This node represents an Element declaration, e.g.
.Sp
.Vb 1
\& <!ELEMENT address (street+, city, state, zip, country?)>
.Ve
.RS 4
.Ip "getName" 4
.IX Item "getName"
Returns the Element tagName.
.Ip "getModel and setModel (model)" 4
.IX Item "getModel and setModel (model)"
Returns and sets the model as a string, e.g. 
\&\*(L"(street+, city, state, zip, country?)\*(R" in the above example.
.RE
.RS 4
.RE
.Ip "\s-1XML::DOM:\s0:AttlistDecl extends \s-1XML::DOM:\s0:Node" 4
.IX Item "XML::DOM::AttlistDecl extends XML::DOM::Node"
This node represents an \s-1ATTLIST\s0 declaration, e.g.
.Sp
.Vb 5
\& <!ATTLIST person
\&   sex      (male|female)  #REQUIRED
\&   hair     CDATA          "bold"
\&   eyes     (none|one|two) "two"
\&   species  (human)        #FIXED "human">
.Ve
Each attribute definition is stored a separate AttDef node. The AttDef nodes can
be retrieved with getAttDef and added with addAttDef.
(The AttDef nodes are stored in a NamedNodeMap internally.)
.RS 4
.Ip "getName" 4
.IX Item "getName"
Returns the Element tagName.
.Ip "getAttDef (attrName)" 4
.IX Item "getAttDef (attrName)"
Returns the AttDef node for the attribute with the specified name.
.Ip "addAttDef (attrName, type, default, [ fixed ])" 4
.IX Item "addAttDef (attrName, type, default, [ fixed ])"
Adds a AttDef node for the attribute with the specified name.
.Sp
Parameters:
 \fIattrName\fR the attribute name.
 \fItype\fR     the attribute type (e.g. \*(L"\s-1CDATA\s0\*(R" or \*(L"(male|female)\*(R".)
 \fIdefault\fR  the default value enclosed in quotes (!), the string #IMPLIED or 
             the string #REQUIRED.
 \fIfixed\fR    whether the attribute is '#FIXED' (default is 0.)
.RE
.RS 4
.RE
.Ip "\s-1XML::DOM:\s0:AttDef extends \s-1XML::DOM:\s0:Node" 4
.IX Item "XML::DOM::AttDef extends XML::DOM::Node"
Each object of this class represents one attribute definition in an AttlistDecl.
.RS 4
.Ip "getName" 4
.IX Item "getName"
Returns the attribute name.
.Ip "getDefault" 4
.IX Item "getDefault"
Returns the default value, or undef.
.Ip "isFixed" 4
.IX Item "isFixed"
Whether the attribute value is fixed (see #FIXED keyword.)
.Ip "isRequired" 4
.IX Item "isRequired"
Whether the attribute value is required (see #REQUIRED keyword.)
.Ip "isImplied" 4
.IX Item "isImplied"
Whether the attribute value is implied (see #IMPLIED keyword.)
.RE
.RS 4
.SH "IMPLEMENTATION DETAILS"
.IX Header "IMPLEMENTATION DETAILS"
.RS 4
.RE
.Ip "\(bu Perl Mappings" 4
.IX Item "Perl Mappings"
The value undef was used when the \s-1DOM\s0 Spec said null.
.Sp
The \s-1DOM\s0 Spec says: Applications must encode DOMString using \s-1UTF-16\s0 (defined in 
Appendix C.3 of [\s-1UNICODE\s0] and Amendment 1 of [\s-1ISO-10646\s0]).
In this implementation we use plain old Perl strings encoded in \s-1UTF-8\s0 instead of
\&\s-1UTF-16\s0.
.Ip "\(bu Text and CDATASection nodes" 4
.IX Item "Text and CDATASection nodes"
The Expat parser expands EntityReferences and CDataSection sections to 
raw strings and does not indicate where it was found. 
This implementation does therefore convert both to Text nodes at parse time.
CDATASection and EntityReference nodes that are added to an existing Document 
(by the user) will be preserved.
.Sp
Also, subsequent Text nodes are always merged at parse time. Text nodes that are 
added later can be merged with the normalize method. Consider using the addText
method when adding Text nodes.
.Ip "\(bu Printing and toString" 4
.IX Item "Printing and toString"
When printing (and converting an \s-1XML\s0 Document to a string) the strings have to 
encoded differently depending on where they occur. E.g. in a CDATASection all 
substrings are allowed except for \*(L"]]>\*(R". In regular text, certain characters are
not allowed, e.g. \*(L">\*(R" has to be converted to \*(L"&gt;\*(R". 
These routines should be verified by someone who knows the details.
.Ip "\(bu Quotes" 4
.IX Item "Quotes"
Certain sections in \s-1XML\s0 are quoted, like attribute values in an Element.
\&\s-1XML:\s0:Parser strips these quotes and the print methods in this implementation 
always uses double quotes, so when parsing and printing a document, single quotes
may be converted to double quotes. The default value of an attribute definition
(AttDef) in an AttlistDecl, however, will maintain its quotes.
.Ip "\(bu AttlistDecl" 4
.IX Item "AttlistDecl"
Attribute declarations for a certain Element are always merged into a single
AttlistDecl object.
.Ip "\(bu Comments" 4
.IX Item "Comments"
Comments in the \s-1DOCTYPE\s0 section are not kept in the right place. They will become
child nodes of the Document.
.RE
.RS 4
.SH "SEE ALSO"
.IX Header "SEE ALSO"
The Japanese version of this document by Takanori Kawai (Hippo2000)
at http://member.nifty.ne.jp/hippo2000/perltips/xml/dom.htm 
.Sp
The \s-1DOM\s0 Level 1 specification at http://www.w3.org/TR/REC-DOM-Level-1
.Sp
The \s-1XML\s0 spec (Extensible Markup Language 1.0) at http://www.w3.org/TR/REC-xml
.Sp
The \s-1XML:\s0:Parser and \s-1XML:\s0:Parser::Expat manual pages.
.SH "CAVEATS"
.IX Header "CAVEATS"
The method \fIgetElementsByTagName()\fR does not return a \*(L"live\*(R" NodeList.
Whether this is an actual caveat is debatable, but a few people on the 
www-dom mailing list seemed to think so. I haven't decided yet. It's a pain
to implement, it slows things down and the benefits seem marginal.
Let me know what you think. 
.Sp
(To subscribe to the www-dom mailing list send an email with the subject 
\&\*(L"subscribe\*(R" to www-dom-request@w3.org. I only look here occasionally, so don't
send bug reports or suggestions about \s-1XML::DOM\s0 to this list, send them
to enno@att.com instead.)
.SH "AUTHORS"
.IX Header "AUTHORS"
Enno Derksen <\fIenno@att.com\fR> and Clark Cooper <\fIcoopercl@sch.ge.com\fR>.
Please send bugs, comments and suggestions to Enno.
