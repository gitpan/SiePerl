.\" Automatically generated by Pod::Man version 1.15
.\" Mon Apr 23 12:00:29 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "Template 3"
.TH Template 3 "perl v5.6.1" "2000-12-23" "User Contributed Perl Documentation"
.UC
.SH "NAME"
\&\s-1HTML:\s0:Template \- Perl module to use \s-1HTML\s0 Templates from \s-1CGI\s0 scripts
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
First you make a template \- this is just a normal \s-1HTML\s0 file with a few
extra tags, the simplest being <\s-1TMPL_VAR\s0>
.PP
For example, test.tmpl:
.PP
.Vb 8
\&  <HTML>
\&  <HEAD><TITLE>Test Template</TITLE>
\&  <BODY>
\&  My Home Directory is <TMPL_VAR NAME=HOME>
\&  <P>
\&  My Path is set to <TMPL_VAR NAME=PATH>
\&  </BODY>
\&  </HTML>
.Ve
Now create a small \s-1CGI\s0 program:
.PP
.Vb 1
\&  use HTML::Template;
.Ve
.Vb 2
\&  # open the html template
\&  my $template = HTML::Template->new(filename => 'test.tmpl');
.Ve
.Vb 5
\&  # fill in some parameters
\&  $template->param(
\&      HOME => $ENV{HOME},
\&      PATH => $ENV{PATH},
\&  );
.Ve
.Vb 2
\&  # send the obligatory Content-Type
\&  print "Content-Type: text/html\en\en";
.Ve
.Vb 2
\&  # print the template
\&  print $template->output;
.Ve
If all is well in the universe this should show something like this in
your browser when visiting the \s-1CGI:\s0
.PP
My Home Directory is /home/some/directory
My Path is set to /bin;/usr/bin
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module attempts to make using \s-1HTML\s0 templates simple and natural.  It
extends standard \s-1HTML\s0 with a few new HTML-esque tags \- <\s-1TMPL_VAR\s0>,
<\s-1TMPL_LOOP\s0>, <\s-1TMPL_INCLUDE\s0>, <\s-1TMPL_IF\s0> and <\s-1TMPL_ELSE\s0>.  The file
written with \s-1HTML\s0 and these new tags is called a template.  It is
usually saved separate from your script \- possibly even created by
someone else!  Using this module you fill in the values for the
variables, loops and branches declared in the template.  This allows
you to separate design \- the \s-1HTML\s0 \- from the data, which you generate
in the Perl script.
.PP
A Japanese translation of the documentation is available at:
.PP
.Vb 1
\&   http://member.nifty.ne.jp/hippo2000/perltips/html/template.htm
.Ve
This module is licensed under the \s-1GPL\s0.  See the \s-1LICENSE\s0 section
below for more details.
.SH "MOTIVATION"
.IX Header "MOTIVATION"
It is true that there are a number of packages out there to do \s-1HTML\s0
templates.  On the one hand you have things like \s-1HTML:\s0:Embperl which
allows you freely mix Perl with \s-1HTML\s0.  On the other hand lie
home-grown variable substitution solutions.  Hopefully the module can
find a place between the two.
.PP
One advantage of this module over a full \s-1HTML:\s0:Embperl-esque solution
is that it enforces an important divide \- design and programming.  By
limiting the programmer to just using simple variables and loops in
the \s-1HTML\s0, the template remains accessible to designers and other
non-perl people.  The use of HTML-esque syntax goes further to make
the format understandable to others.  In the future this similarity
could be used to extend existing \s-1HTML\s0 editors/analyzers to support
\&\s-1HTML:\s0:Template.
.PP
An advantage of this module over home-grown tag-replacement schemes is
the support for loops.  In my work I am often called on to produce
tables of data in html.  Producing them using simplistic \s-1HTML\s0
templates results in CGIs containing lots of \s-1HTML\s0 since the \s-1HTML\s0
itself cannot represent loops.  The introduction of loop statements in
the \s-1HTML\s0 simplifies this situation considerably.  The designer can
layout a single row and the programmer can fill it in as many times as
necessary \- all they must agree on is the parameter names.
.PP
For all that, I think the best thing about this module is that it does
just one thing and it does it quickly and carefully.  It doesn't try
to replace Perl and \s-1HTML\s0, it just augments them to interact a little
better.  And it's pretty fast.
.SH "The Tags"
.IX Header "The Tags"
Note: even though these tags look like \s-1HTML\s0 they are a little
different in a couple of ways.  First, they must appear entirely on
one line.  Second, they're allowed to \*(L"break the rules\*(R".  Something
like:
.PP
.Vb 1
\&   <IMG SRC="<TMPL_VAR NAME=IMAGE_SRC>">
.Ve
is not really valid \s-1HTML\s0, but it is a perfectly valid use and will
work as planned.
.PP
The \*(L"NAME=\*(R" in the tag is optional, although for extensibility's sake I
recommend using it.  Example \- \*(L"<\s-1TMPL_LOOP\s0 \s-1LOOP_NAME\s0>\*(R" is acceptable.
.PP
If you're a fanatic about valid \s-1HTML\s0 and would like your templates
to conform to valid \s-1HTML\s0 syntax, you may optionally type template tags
in the form of \s-1HTML\s0 comments. This may be of use to \s-1HTML\s0 authors who
would like to validate their templates' \s-1HTML\s0 syntax prior to
\&\s-1HTML:\s0:Template processing, or who use DTD-savvy editing tools.
.PP
.Vb 1
\&  <!-- TMPL_VAR NAME=PARAM1 -->
.Ve
In order to realize a dramatic savings in bandwidth, the standard
(non-comment) tags will be used throughout the rest of this
documentation.
.if n .Sh "<\s-1TMPL_VAR\s0 NAME=""\s-1PARAMETER_NAME\s0"">"
.el .Sh "<\s-1TMPL_VAR\s0 NAME=``\s-1PARAMETER_NAME\s0''>"
.IX Subsection "<TMPL_VAR NAME="PARAMETER_NAME>"
The <\s-1TMPL_VAR\s0> tag is very simple.  For each <\s-1TMPL_VAR\s0> tag in the
template you call \f(CW$template\fR->param(\s-1PARAMETER_NAME\s0 => \*(L"\s-1VALUE\s0\*(R").  When
the template is output the <\s-1TMPL_VAR\s0> is replaced with the \s-1VALUE\s0 text
you specified.  If you don't set a parameter it just gets skipped in
the output.
.PP
Optionally you can use the \*(L"ESCAPE=HTML\*(R" option in the tag to indicate
that you want the value to be HTML-escaped before being returned from
output (the old ESCAPE=1 syntax is still supported).  This means that
the ", <, >, and & characters get translated into &quot;, &lt;, &gt;
and &amp; respectively.  This is useful when you want to use a
\&\s-1TMPL_VAR\s0 in a context where those characters would cause trouble.
Example:
.PP
.Vb 1
\&   <INPUT NAME=param TYPE=TEXT VALUE="<TMPL_VAR NAME="param">">
.Ve
If you called \fIparam()\fR with a value like sam"my you'll get in trouble
with \s-1HTML\s0's idea of a double-quote.  On the other hand, if you use
ESCAPE=HTML, like this:
.PP
.Vb 1
\&   <INPUT NAME=param TYPE=TEXT VALUE="<TMPL_VAR ESCAPE=HTML NAME="param">">
.Ve
You'll get what you wanted no matter what value happens to be passed in for
param.  You can also write ESCAPE=\*(L"\s-1HTML\s0\*(R", ESCAPE='\s-1HTML\s0' and ESCAPE='1'.
Substitute a 0 for the \s-1HTML\s0 and you turn off escaping, which is the default
anyway.
.PP
There is also the \*(L"ESCAPE=URL\*(R" option which may be used for VARs that
populate a \s-1URL\s0.  It will do \s-1URL\s0 escaping, like replacing ' ' with '+'
and '/' with '%2F'.
.if n .Sh "<\s-1TMPL_LOOP\s0 NAME=""\s-1LOOP_NAME\s0""> </TMPL_LOOP>"
.el .Sh "<\s-1TMPL_LOOP\s0 NAME=``\s-1LOOP_NAME\s0''> </TMPL_LOOP>"
.IX Subsection "<TMPL_LOOP NAME="LOOP_NAME> </TMPL_LOOP>"
The <\s-1TMPL_LOOP\s0> tag is a bit more complicated.  The <\s-1TMPL_LOOP\s0> tag
allows you to delimit a section of text and give it a name.  Inside
the <\s-1TMPL_LOOP\s0> you place <\s-1TMPL_VAR\s0>s.  Now you pass to \fIparam()\fR a list
(an array ref) of parameter assignments (hash refs).  The loop
iterates over this list and produces output from the text block for
each pass.  Unset parameters are skipped.  Here's an example:
.PP
.Vb 1
\&   In the template:
.Ve
.Vb 5
\&   <TMPL_LOOP NAME=EMPLOYEE_INFO>
\&         Name: <TMPL_VAR NAME=NAME> <P>
\&         Job: <TMPL_VAR NAME=JOB> <P>
\&        <P>
\&   </TMPL_LOOP>
.Ve
.Vb 1
\&   In the script:
.Ve
.Vb 6
\&   $template->param(EMPLOYEE_INFO => [ 
\&                                       { name => 'Sam', job => 'programmer' },
\&                                       { name => 'Steve', job => 'soda jerk' },
\&                                     ]
\&                   );
\&   print $template->output();
.Ve
.Vb 1
\&   The output:
.Ve
.Vb 6
\&   Name: Sam <P>
\&   Job: programmer <P>
\&   <P>
\&   Name: Steve <P>
\&   Job: soda jerk <P>
\&   <P>
.Ve
As you can see above the <\s-1TMPL_LOOP\s0> takes a list of variable
assignments and then iterates over the loop body producing output.
.PP
Often you'll want to generate a <\s-1TMPL_LOOP\s0>'s contents
programmatically.  Here's an example of how this can be done (many
other ways are possible!):
.PP
.Vb 3
\&   # a couple of arrays of data to put in a loop:
\&   my @words = qw(I Am Cool);
\&   my @numbers = qw(1 2 3);
.Ve
.Vb 1
\&   my @loop_data = ();  # initialize an array to hold your loop
.Ve
.Vb 2
\&   while (@words and @numbers) {
\&     my %row_data;  # get a fresh hash for the row data
.Ve
.Vb 3
\&     # fill in this row
\&     $row_data{WORD} = shift @words;
\&     $row_data{NUMBER} = shift @numbers;
.Ve
.Vb 3
\&     # the crucial step - push a reference to this row into the loop!
\&     push(@loop_data, \e%row_data);
\&   }
.Ve
.Vb 3
\&   # finally, assign the loop data to the loop param, again with a
\&   # reference:
\&   $template->param(THIS_LOOP => \e@loop_data);
.Ve
The above example would work with a template like:
.PP
.Vb 4
\&   <TMPL_LOOP NAME="THIS_LOOP">
\&      Word: <TMPL_VAR NAME="WORD"><BR>
\&      Number: <TMPL_VAR NAME="NUMBER"><P>
\&   </TMPL_LOOP>
.Ve
It would produce output like:
.PP
.Vb 2
\&   Word: I
\&   Number: 1
.Ve
.Vb 2
\&   Word: Am
\&   Number: 2
.Ve
.Vb 2
\&   Word: Cool
\&   Number: 3
.Ve
<\s-1TMPL_LOOP\s0>s within <\s-1TMPL_LOOP\s0>s are fine and work as you would
expect.  If the syntax for the \fIparam()\fR call has you stumped, here's an
example of a param call with one nested loop:
.PP
.Vb 9
\&  $template->param('ROW',[
\&                          { name => 'Bobby',
\&                            nicknames => [
\&                                          { name => 'the big bad wolf' }, 
\&                                          { name => 'He-Man' },
\&                                         ],
\&                          },
\&                         ],
\&                  );
.Ve
Basically, each <\s-1TMPL_LOOP\s0> gets an array reference.  Inside the array
are any number of hash references.  These hashes contain the
name=>value pairs for a single pass over the loop template.  
.PP
Inside a <\s-1TMPL_LOOP\s0>, the only variables that are usable are the ones
from the <\s-1TMPL_LOOP\s0>.  The variables in the outer blocks are not
visible within a template loop.  For the computer-science geeks among
you, a <\s-1TMPL_LOOP\s0> introduces a new scope much like a perl subroutine
call.  If you want your variables to be global you can use
\&'global_vars' option to new described below.
.if n .Sh "<\s-1TMPL_INCLUDE\s0 NAME=""filename.tmpl"">"
.el .Sh "<\s-1TMPL_INCLUDE\s0 NAME=``filename.tmpl''>"
.IX Subsection "<TMPL_INCLUDE NAME="filename.tmpl>"
This tag includes a template directly into the current template at the
point where the tag is found.  The included template contents are used
exactly as if its contents were physically included in the master
template.
.PP
The file specified can be a full path \- beginning with a '/'.  If it
isn't a full path, the path to the enclosing file is tried first.
After that the path in the environment variable \s-1HTML_TEMPLATE_ROOT\s0 is
tried next, if it exists.  Next, the \*(L"path\*(R" \fInew()\fR option is consulted.
As a final attempt, the filename is passed to \fIopen()\fR directly.  See
below for more information on \s-1HTML_TEMPLATE_ROOT\s0 and the \*(L"path\*(R" option
to \fInew()\fR.
.PP
As a protection against infinitly recursive includes, an arbitary
limit of 10 levels deep is imposed.  You can alter this limit with the
\&\*(L"max_includes\*(R" option.  See the entry for the \*(L"max_includes\*(R" option
below for more details.
.if n .Sh "<\s-1TMPL_IF\s0 NAME=""\s-1CONTROL_PARAMETER_NAME\s0""> </TMPL_IF>"
.el .Sh "<\s-1TMPL_IF\s0 NAME=``\s-1CONTROL_PARAMETER_NAME\s0''> </TMPL_IF>"
.IX Subsection "<TMPL_IF NAME="CONTROL_PARAMETER_NAME> </TMPL_IF>"
The <\s-1TMPL_IF\s0> tag allows you to include or not include a block of the
template based on the value of a given parameter name.  If the
parameter is given a value that is true for Perl \- like '1' \- then the
block is included in the output.  If it is not defined, or given a
false value \- like '0' \- then it is skipped.  The parameters are
specified the same way as with \s-1TMPL_VAR\s0.
.PP
Example Template:
.PP
.Vb 3
\&   <TMPL_IF NAME="BOOL">
\&     Some text that only gets displayed if BOOL is true!
\&   </TMPL_IF>
.Ve
Now if you call \f(CW$template\fR->param(\s-1BOOL\s0 => 1) then the above block will
be included by output. 
.PP
<\s-1TMPL_IF\s0> </TMPL_IF> blocks can include any valid \s-1HTML:\s0:Template
construct \- VARs and LOOPs and other \s-1IF/ELSE\s0 blocks.  Note, however,
that intersecting a <\s-1TMPL_IF\s0> and a <\s-1TMPL_LOOP\s0> is invalid.
.PP
.Vb 5
\&   Not going to work:
\&   <TMPL_IF BOOL>
\&      <TMPL_LOOP SOME_LOOP>
\&   </TMPL_IF>
\&      </TMPL_LOOP>
.Ve
If the name of a \s-1TMPL_LOOP\s0 is used in a \s-1TMPL_IF\s0, the \s-1IF\s0 block will
output if the loop has at least one row.  Example:
.PP
.Vb 3
\&  <TMPL_IF LOOP_ONE>
\&    This will output if the loop is not empty.
\&  </TMPL_IF>
.Ve
.Vb 3
\&  <TMPL_LOOP LOOP_ONE>
\&    ....
\&  </TMPL_LOOP>
.Ve
\&\s-1WARNING:\s0 Much of the benefit of \s-1HTML:\s0:Template is in decoupling your
Perl and \s-1HTML\s0.  If you introduce numerous cases where you have
TMPL_IFs and matching Perl \fIif()\fRs, you will create a maintenance
problem in keeping the two synchronized.  I suggest you adopt the
practice of only using \s-1TMPL_IF\s0 if you can do so without requiring a
matching \fIif()\fR in your Perl code.
.Sh "<\s-1TMPL_ELSE\s0>"
.IX Subsection "<TMPL_ELSE>"
You can include an alternate block in your \s-1TMPL_IF\s0 block by using
\&\s-1TMPL_ELSE\s0.  \s-1NOTE:\s0 You still end the block with </TMPL_IF>, not
</TMPL_ELSE>!
.PP
.Vb 1
\&   Example:
.Ve
.Vb 5
\&   <TMPL_IF BOOL>
\&     Some text that is included only if BOOL is true
\&   <TMPL_ELSE>
\&     Some text that is included only if BOOL is false
\&   </TMPL_IF>
.Ve
.if n .Sh "<\s-1TMPL_UNLESS\s0 NAME=""\s-1CONTROL_PARAMETER_NAME\s0""> </TMPL_UNLESS>"
.el .Sh "<\s-1TMPL_UNLESS\s0 NAME=``\s-1CONTROL_PARAMETER_NAME\s0''> </TMPL_UNLESS>"
.IX Subsection "<TMPL_UNLESS NAME="CONTROL_PARAMETER_NAME> </TMPL_UNLESS>"
This tag is the opposite of <\s-1TMPL_IF\s0>.  The block is output if the
\&\s-1CONTROL_PARAMETER\s0 is set false or not defined.  You can use
<\s-1TMPL_ELSE\s0> with <\s-1TMPL_UNLESS\s0> just as you can with <\s-1TMPL_IF\s0>.
.PP
.Vb 1
\&  Example:
.Ve
.Vb 5
\&  <TMPL_UNLESS BOOL>
\&    Some text that is output only if BOOL is FALSE.
\&  <TMPL_ELSE>
\&    Some text that is output only if BOOL is TRUE.
\&  </TMPL_UNLESS>
.Ve
If the name of a \s-1TMPL_LOOP\s0 is used in a \s-1TMPL_UNLESS\s0, the \s-1UNLESS\s0 block
output if the loop has zero rows.
.PP
.Vb 3
\&  <TMPL_UNLESS LOOP_ONE>
\&    This will output if the loop is empty.
\&  </TMPL_UNLESS>
.Ve
.Vb 3
\&  <TMPL_LOOP LOOP_ONE>
\&    ....
\&  </TMPL_LOOP>
.Ve
.SH "Methods"
.IX Header "Methods"
.Sh "\fInew()\fP"
.IX Subsection "new()"
Call \fInew()\fR to create a new Template object:
.PP
.Vb 3
\&  my $template = HTML::Template->new( filename => 'file.tmpl', 
\&                                      option => 'value' 
\&                                    );
.Ve
You must call \fInew()\fR with at least one name => value pair specifying how
to access the template text.  You can use \*(L"filename => 'file.tmpl'\*(R" to
specify a filename to be opened as the template.  Alternately you can
use:
.PP
.Vb 3
\&  my $t = HTML::Template->new( scalarref => $ref_to_template_text, 
\&                               option => 'value' 
\&                             );
.Ve
and
.PP
.Vb 3
\&  my $t = HTML::Template->new( arrayref => $ref_to_array_of_lines , 
\&                               option => 'value' 
\&                             );
.Ve
These initialize the template from in-memory resources.  In almost
every case you'll want to use the filename parameter.  If you're
worried about all the disk access from reading a template file just
use mod_perl and the cache option detailed below.
.PP
The three \fInew()\fR calling methods can also be accessed as below, if you
prefer.
.PP
.Vb 1
\&  my $t = HTML::Template->new_file('file.tmpl', option => 'value');
.Ve
.Vb 2
\&  my $t = HTML::Template->new_scalar_ref($ref_to_template_text, 
\&                                        option => 'value');
.Ve
.Vb 2
\&  my $t = HTML::Template->new_array_ref($ref_to_array_of_lines, 
\&                                       option => 'value');
.Ve
And as a final option, for those that might prefer it, you can call new as:
.PP
.Vb 2
\&  my $t = HTML::Template->new(type => 'filename', 
\&                              source => 'file.tmpl');
.Ve
Which works for all three of the source types.
.PP
If the environment variable \s-1HTML_TEMPLATE_ROOT\s0 is set and your
filename doesn't begin with /, then the path will be relative to the
value of \f(CW$HTML_TEMPLATE_ROOT\fR.  Example \- if the environment variable
\&\s-1HTML_TEMPLATE_ROOT\s0 is set to \*(L"/home/sam\*(R" and I call
\&\s-1HTML:\s0:Template->\fInew()\fR with filename set to \*(L"sam.tmpl\*(R", the
\&\s-1HTML:\s0:Template will try to open \*(L"/home/sam/sam.tmpl\*(R" to access the
template file.  You can also affect the search path for files with the
\&\*(L"path\*(R" option to \fInew()\fR \- see below for more information.
.PP
You can modify the Template object's behavior with new.  These options
are available:
.Ip "\(bu" 4
die_on_bad_params \- if set to 0 the module will let you call
\&\f(CW$template\fR->param(param_name => 'value') even if 'param_name' doesn't
exist in the template body.  Defaults to 1.
.Ip "\(bu" 4
strict \- if set to 0 the module will allow things that look like they might be TMPL_* tags to get by without dieing.  Example:
.Sp
.Vb 1
\&   <TMPL_HUH NAME=ZUH>
.Ve
Would normally cause an error, but if you call new with strict => 0,
\&\s-1HTML:\s0:Template will ignore it.  Defaults to 1.
.Ip "\(bu" 4
cache \- if set to 1 the module will cache in memory the parsed
templates based on the filename parameter and modification date of the
file.  This only applies to templates opened with the filename
parameter specified, not scalarref or arrayref templates.  Caching
also looks at the modification times of any files included using
<\s-1TMPL_INCLUDE\s0> tags, but again, only if the template is opened with
filename parameter.  
.Sp
This is mainly of use in a persistent environment like
Apache/mod_perl.  It has absolutely no benefit in a normal \s-1CGI\s0
environment since the script is unloaded from memory after every
request.  For a cache that does work for normal CGIs see the
\&'shared_cache' option below.
.Sp
Note that different \fInew()\fR parameter settings do not cause a cache
refresh, only a change in the modification time of the template will
trigger a cache refresh.  For most usages this is fine.  My simplistic
testing shows that using cache yields a 90% performance increase under
mod_perl.  Cache defaults to 0.
.Ip "\(bu" 4
shared_cache \- if set to 1 the module will store its cache in shared
memory using the \s-1IPC:\s0:SharedCache module (available from \s-1CPAN\s0).  The
effect of this will be to maintain a single shared copy of each parsed
template for all instances of \s-1HTML:\s0:Template to use.  This can be a
significant reduction in memory usage in a multiple server
environment.  As an example, on one of our systems we use 4MB of
template cache and maintain 25 httpd processes \- shared_cache results
in saving almost 100MB!  Of course, some reduction in speed versus
normal caching is to be expected.  Another difference between normal
caching and shared_cache is that shared_cache will work in a \s-1CGI\s0
environment \- normal caching is only useful in a persistent
environment like Apache/mod_perl.
.Sp
By default \s-1HTML:\s0:Template uses the \s-1IPC\s0 key '\s-1TMPL\s0' as a shared root
segment (0x4c504d54 in hex), but this can be changed by setting the
\&'ipc_key' \fInew()\fR parameter to another 4\-character or integer key.
Other options can be used to affect the shared memory cache correspond
to \s-1IPC:\s0:SharedCache options \- ipc_mode, ipc_segment_size and
ipc_max_size.  See the IPC::SharedCache manpage for a description of how these
work \- in most cases you shouldn't need to change them from the
defaults.
.Sp
For more information about the shared memory cache system used by
\&\s-1HTML:\s0:Template see the IPC::SharedCache manpage.
.Ip "\(bu" 4
double_cache \- if set to 1 the module will use a combination of
shared_cache and normal cache mode for the best possible caching.  Of
course, it also uses the most memory of all the cache modes.  All the
same ipc_* options that work with shared_cache apply to double_cache
as well.  By default double_cache is off.
.Ip "\(bu" 4
blind_cache \- if set to 1 the module behaves exactly as with normal
caching but does not check to see if the file has changed on each
request.  This option should be used with caution, but could be of use
on high-load servers.  My tests show blind_cache performing only 1 to
2 percent faster than cache under mod_perl.
.Sp
\&\s-1NOTE:\s0 Combining this option with shared_cache can result in stale
templates stuck permanently in shared memory!
.Ip "\(bu" 4
file_cache \- if set to 1 the module will store its cache in a file
using the Storable module.  It uses no additional memory, and my
simplistic testing shows that it yields a 50% performance advantage.
Like shared_cache, it will work in a \s-1CGI\s0 environment. Default is 0.
.Sp
If you set this option you must set the \*(L"file_cache_dir\*(R" option.  See
below for details.
.Sp
\&\s-1NOTE:\s0 Storable using \fIflock()\fR to ensure safe access to cache files.
Using file_cache on a system or filesystem (\s-1NFS\s0) without \fIflock()\fR
support is dangerous.
.Ip "\(bu" 4
file_cache_dir \- sets the directory where the module will store the
cache files if file_cache is enabled.  Your script will need write
permissions to this directory.  You'll also need to make sure the
sufficient space is available to store the cache files.
.Ip "\(bu" 4
file_cache_dir_mode \- sets the file mode for newly created file_cache
directories and subdirectories.  Defaults to 0700 for security but
this may be inconvenient if you do not have access to the account
running the webserver.
.Ip "\(bu" 4
double_file_cache \- if set to 1 the module will use a combination of
file_cache and normal cache mode for the best possible caching.  The
file_cache_* options that work with file_cache apply to double_file_cache
as well.  By default double_file_cache is 0.
.Ip "\(bu" 4
associate \- this option allows you to inherit the parameter values
from other objects.  The only requirement for the other object is that
it have a \fIparam()\fR method that works like \s-1HTML:\s0:Template's \fIparam()\fR.  A
good candidate would be a \s-1CGI\s0.pm query object.  Example:
.Sp
.Vb 3
\&  my $query = new CGI;
\&  my $template = HTML::Template->new(filename => 'template.tmpl',
\&                                     associate => $query);
.Ve
Now, \f(CW$template\fR->\fIoutput()\fR will act as though 
.Sp
.Vb 1
\&  $template->param('FormField', $cgi->param('FormField'));
.Ve
had been specified for each key/value pair that would be provided by
the \f(CW$cgi\fR->\fIparam()\fR method.  Parameters you set directly take precedence
over associated parameters.  
.Sp
You can specify multiple objects to associate by passing an anonymous
array to the associate option.  They are searched for parameters in
the order they appear:
.Sp
.Vb 2
\&  my $template = HTML::Template->new(filename => 'template.tmpl',
\&                                     associate => [$query, $other_obj]);
.Ve
The old \fIassociateCGI()\fR call is still supported, but should be
considered obsolete.
.Sp
\&\s-1NOTE:\s0 The parameter names are matched in a case-insensitve manner.  If
you have two parameters in a \s-1CGI\s0 object like '\s-1NAME\s0' and 'Name' one
will be chosen randomly by associate.  This behavior can be changed by
the following option.
.Ip "\(bu" 4
case_sensitive \- setting this option to true causes \s-1HTML:\s0:Template to
treat template variable names case-sensitively.  The following example
would only set one parameter without the \*(L"case_sensitive\*(R" option:
.Sp
.Vb 6
\&  my $template = HTML::Template->new(filename => 'template.tmpl',
\&                                     case_sensitive => 1);
\&  $template->param(
\&    FieldA => 'foo',
\&    fIELDa => 'bar',
\&  );
.Ve
This option defaults to off.
.Ip "\(bu" 4
loop_context_vars \- when this parameter is set to true (it is false by
default) four loop context variables are made available inside a loop:
_\|_FIRST_\|_, _\|_LAST_\|_, _\|_INNER_\|_, _\|_ODD_\|_.  They can be used with
<\s-1TMPL_IF\s0>, <\s-1TMPL_UNLESS\s0> and <\s-1TMPL_ELSE\s0> to control how a loop is
output.  Example:
.Sp
.Vb 4
\&   <TMPL_LOOP NAME="FOO">
\&      <TMPL_IF NAME="__FIRST__">
\&        This only outputs on the first pass.
\&      </TMPL_IF>
.Ve
.Vb 3
\&      <TMPL_IF NAME="__ODD__">
\&        This outputs every other pass, on the odd passes.
\&      </TMPL_IF>
.Ve
.Vb 3
\&      <TMPL_UNLESS NAME="__ODD__">
\&        This outputs every other pass, on the even passes.
\&      </TMPL_IF>
.Ve
.Vb 3
\&      <TMPL_IF NAME="__INNER__">
\&        This outputs on passes that are neither first nor last.
\&      </TMPL_IF>
.Ve
.Vb 4
\&      <TMPL_IF NAME="__LAST__">
\&        This only outputs on the last pass.
\&      <TMPL_IF>
\&   </TMPL_LOOP>
.Ve
One use of this feature is to provide a \*(L"separator\*(R" similar in effect
to the perl function \fIjoin()\fR.  Example:
.Sp
.Vb 4
\&   <TMPL_LOOP FRUIT>
\&      <TMPL_IF __LAST__> and </TMPL_IF>
\&      <TMPL_VAR KIND><TMPL_UNLESS __LAST__>, <TMPL_ELSE>.</TMPL_UNLESS>
\&   </TMPL_LOOP>
.Ve
Would output (in a browser) something like:
.Sp
.Vb 1
\&  Apples, Oranges, Brains, Toes, and Kiwi.
.Ve
Given an appropriate \fIparam()\fR call, of course.  \s-1NOTE:\s0 A loop with only
a single pass will get both _\|_FIRST_\|_ and _\|_LAST_\|_ set to true, but
not _\|_INNER_\|_.
.Ip "\(bu" 4
path \- you can set this variable with a list of paths to search for
files specified with the \*(L"filename\*(R" option to \fInew()\fR and for files
included with the <\s-1TMPL_INCLUDE\s0> tag.  This list is only consulted
when the filename is relative.  The \s-1HTML_TEMPLATE_ROOT\s0 environment
variable is always tried first if it exists.  In the case of a
<\s-1TMPL_INCLUDE\s0> file, the path to the including file is also tried
before path is consulted.
.Sp
Example:
.Sp
.Vb 5
\&   my $template = HTML::Template->new( filename => 'file.tmpl',
\&                                       path => [ '/path/to/templates',
\&                                                 '/alternate/path'
\&                                               ]
\&                                      );
.Ve
\&\s-1NOTE:\s0 the paths in the path list must be expressed as \s-1UNIX\s0 paths,
separated by the forward-slash character ('/').
.Ip "\(bu" 4
no_includes \- set this option to 1 to disallow the <\s-1TMPL_INCLUDE\s0> tag
in the template file.  This can be used to make opening untrusted
templates \fBslightly\fR less dangerous.  Defaults to 0.
.Ip "\(bu" 4
max_includes \- set this variable to determine the maximum depth that
includes can reach.  Set to 10 by default.  Including files to a depth
greater than this value causes an error message to be displayed.  Set
to 0 to disable this protection.
.Ip "\(bu" 4
search_path_on_include \- if set to a true value the module will search
from the top of the array of paths specified by the path option on
every <\s-1TMPL_INCLUDE\s0> and use the first matching template found.  The
normal behavior is to look only in the current directory for a
template to include.  Defaults to 0.
.Ip "\(bu" 4
global_vars \- normally variables declared outside a loop are not
available inside a loop.  This option makes <\s-1TMPL_VAR\s0>s like global
variables in Perl \- they have unlimited scope.  This option also
affects <\s-1TMPL_IF\s0> and <\s-1TMPL_UNLESS\s0>.
.Sp
Example:
.Sp
.Vb 1
\&  This is a normal variable: <TMPL_VAR NORMAL>.<P>
.Ve
.Vb 3
\&  <TMPL_LOOP NAME=FROOT_LOOP>
\&     Here it is inside the loop: <TMPL_VAR NORMAL><P>
\&  </TMPL_LOOP>
.Ve
Normally this wouldn't work as expected, since <\s-1TMPL_VAR\s0 \s-1NORMAL\s0>'s
value outside the loop is not available inside the loop.
.Ip "\(bu" 4
filter \- this option allows you to specify a filter for your template
files.  A filter is a subroutine that will be called after
\&\s-1HTML:\s0:Template reads your template file but before it starts parsing
template tags.
.Sp
In the most simple usage, you simply assign a code reference to the
filter parameter.  This subroutine will recieve a single arguement \- a
reference to a string containing the template file text.  Here is an
example that accepts templates with tags that look like \*(L"!!!ZAP_VAR
\&\s-1FOO\s0!!!\*(R" and transforms them into \s-1HTML:\s0:Template tags:
.Sp
.Vb 4
\&   my $filter = sub {
\&     my $text_ref = shift;
\&     $$text_ref =~ s/!!!ZAP_(.*?)!!!/<TMPL_$1>/g;
\&   }
.Ve
.Vb 3
\&   # open zap.tmpl using the above filter
\&   my $template = HTML::Template->new(filename => 'zap.tmpl',
\&                                      filter => $filter);
.Ve
More complicated usages are possible.  You can request that your
filter receieve the template text as an array of lines rather than as
a single scalar.  To do that you need to specify your filter using a
hash-ref.  In this form you specify the filter using the \*(L"sub\*(R" key and
the desired argument format using the \*(L"format\*(R" key.  The available
formats are \*(L"scalar\*(R" and \*(L"array\*(R".
.Sp
.Vb 3
\&   my $template = HTML::Template->new(filename => 'zap.tmpl',
\&                                      filter => { sub => $filter,
\&                                                  format => 'array' });
.Ve
Using the 'array' format is likely to be more efficient since this is
how \s-1HTML:\s0:Template stores the template text internally.  This may
change in the future.
.Sp
You may also have multiple filters.  This allows simple filters to be
combined for more elaborate functionality.  To do this you specify an
array of filters.  The filters are applied in the order they are
specified.
.Sp
.Vb 7
\&   my $template = HTML::Template->new(filename => 'zap.tmpl',
\&                                      filter => [ 
\&                                           { sub => \e&decompress,
\&                                             format => 'scalar' },
\&                                           { sub => \e&remove_spaces,
\&                                             format => 'array' }
\&                                        ]);
.Ve
The specified filters will be called for any TMPL_INCLUDEed files just
as they are for the main template file.
.Ip "\(bu" 4
vanguard_compatibility_mode \- if set to 1 the module will expect to
see <\s-1TMPL_VAR\s0>s that look like \f(CW%NAME\fR% in addition to the standard
syntax.  Also sets die_on_bad_params => 0.  If you're not at Vanguard
Media trying to use an old format template don't worry about this one.
Defaults to 0.
.Ip "\(bu" 4
debug \- if set to 1 the module will write random debugging information
to \s-1STDERR\s0.  Defaults to 0.
.Ip "\(bu" 4
stack_debug \- if set to 1 the module will use Data::Dumper to print
out the contents of the parse_stack to \s-1STDERR\s0.  Defaults to 0.
.Ip "\(bu" 4
cache_debug \- if set to 1 the module will send information on cache
loads, hits and misses to \s-1STDERR\s0.  Defaults to 0.
.Ip "\(bu" 4
shared_cache_debug \- if set to 1 the module will turn on the debug
option in \s-1IPC:\s0:SharedCache \- see the IPC::SharedCache manpage for
details. Defaults to 0.
.Ip "\(bu" 4
memory_debug \- if set to 1 the module will send information on cache
memory usage to \s-1STDERR\s0.  Requires the GTop module.  Defaults to 0.
.Sh "param"
.IX Subsection "param"
\&\fIparam()\fR can be called in a number of ways
.PP
1) To return a list of parameters in the template : 
.PP
.Vb 1
\&   my @parameter_names = $self->param();
.Ve
2) To return the value set to a param : 
.PP
.Vb 1
\&   my $value = $self->param('PARAM');
.Ve
3) To set the value of a parameter :
.PP
.Vb 2
\&      # For simple TMPL_VARs:
\&      $self->param(PARAM => 'value');
.Ve
.Vb 3
\&      # with a subroutine reference that gets called to get the value of
\&      # the scalar.
\&      $self->param(PARAM => sub { return 'value' });
.Ve
.Vb 8
\&      # And TMPL_LOOPs:
\&      $self->param(LOOP_PARAM => 
\&                   [ 
\&                    { PARAM => VALUE_FOR_FIRST_PASS, ... }, 
\&                    { PARAM => VALUE_FOR_SECOND_PASS, ... } 
\&                    ...
\&                   ]
\&                  );
.Ve
4) To set the value of a a number of parameters :
.PP
.Vb 4
\&     # For simple TMPL_VARs:
\&     $self->param(PARAM => 'value', 
\&                  PARAM2 => 'value'
\&                 );
.Ve
.Vb 16
\&      # And with some TMPL_LOOPs:
\&      $self->param(PARAM => 'value', 
\&                   PARAM2 => 'value',
\&                   LOOP_PARAM => 
\&                   [ 
\&                    { PARAM => VALUE_FOR_FIRST_PASS, ... }, 
\&                    { PARAM => VALUE_FOR_SECOND_PASS, ... } 
\&                    ...
\&                   ],
\&                   ANOTHER_LOOP_PARAM => 
\&                   [ 
\&                    { PARAM => VALUE_FOR_FIRST_PASS, ... }, 
\&                    { PARAM => VALUE_FOR_SECOND_PASS, ... } 
\&                    ...
\&                   ]
\&                  );
.Ve
5) To set the value of a a number of parameters using a hash-ref :
.PP
.Vb 18
\&      $self->param(
\&                   { 
\&                      PARAM => 'value', 
\&                      PARAM2 => 'value',
\&                      LOOP_PARAM => 
\&                      [ 
\&                        { PARAM => VALUE_FOR_FIRST_PASS, ... }, 
\&                        { PARAM => VALUE_FOR_SECOND_PASS, ... } 
\&                        ...
\&                      ],
\&                      ANOTHER_LOOP_PARAM => 
\&                      [ 
\&                        { PARAM => VALUE_FOR_FIRST_PASS, ... }, 
\&                        { PARAM => VALUE_FOR_SECOND_PASS, ... } 
\&                        ...
\&                      ]
\&                    }
\&                   );
.Ve
.Sh "\fIclear_params()\fP"
.IX Subsection "clear_params()"
Sets all the parameters to undef.  Useful internally, if nowhere else!
.Sh "\fIoutput()\fP"
.IX Subsection "output()"
\&\fIoutput()\fR returns the final result of the template.  In most situations
you'll want to print this, like:
.PP
.Vb 1
\&   print $template->output();
.Ve
When output is called each occurrence of <\s-1TMPL_VAR\s0 NAME=name> is
replaced with the value assigned to \*(L"name\*(R" via \fIparam()\fR.  If a named
parameter is unset it is simply replaced with ''.  <\s-1TMPL_LOOPS\s0> are
evaluated once per parameter set, accumlating output on each pass.
.PP
Calling \fIoutput()\fR is guaranteed not to change the state of the
Template object, in case you were wondering.  This property is mostly
important for the internal implementation of loops.
.PP
You may optionally supply a filehandle to print to automatically as
the template is generated.  This may improve performance and lower
memory consumption.  Example:
.PP
.Vb 1
\&   $template->output(print_to => *STDOUT);
.Ve
The return value is undefined when using the \*(L"print_to\*(R" option.
.Sh "\fIquery()\fP"
.IX Subsection "query()"
This method allow you to get information about the template structure.
It can be called in a number of ways.  The simplest usage of query is
simply to check whether a parameter name exists in the template, using
the \f(CW\*(C`name\*(C'\fR option:
.PP
.Vb 4
\&  if ($template->query(name => 'foo')) {
\&    # do something if a varaible of any type 
\&    # named FOO is in the template
\&  }
.Ve
This same usage returns the type of the parameter.  The type is the
same as the tag minus the leading '\s-1TMPL_\s0'.  So, for example, a
\&\s-1TMPL_VAR\s0 parameter returns '\s-1VAR\s0' from \fIquery()\fR.
.PP
.Vb 3
\&  if ($template->query(name => 'foo') eq 'VAR') {
\&    # do something if FOO exists and is a TMPL_VAR
\&  }
.Ve
Note that the variables associated with TMPL_IFs and TMPL_UNLESSs will
be identified as '\s-1VAR\s0' unless they are also used in a \s-1TMPL_LOOP\s0, in
which case they will return '\s-1LOOP\s0'.
.PP
\&\f(CW\*(C`query()\*(C'\fR also allows you to get a list of parameters inside a loop
(and inside loops inside loops).  Example loop:
.PP
.Vb 8
\&   <TMPL_LOOP NAME="EXAMPLE_LOOP">
\&     <TMPL_VAR NAME="BEE">
\&     <TMPL_VAR NAME="BOP">
\&     <TMPL_LOOP NAME="EXAMPLE_INNER_LOOP">
\&       <TMPL_VAR NAME="INNER_BEE">
\&       <TMPL_VAR NAME="INNER_BOP">
\&     </TMPL_LOOP>
\&   </TMPL_LOOP>
.Ve
And some query calls:
.PP
.Vb 2
\&  # returns 'LOOP'
\&  $type = $template->query(name => 'EXAMPLE_LOOP');
.Ve
.Vb 2
\&  # returns ('bop', 'bee', 'example_inner_loop')
\&  @param_names = $template->query(loop => 'EXAMPLE_LOOP');
.Ve
.Vb 3
\&  # both return 'VAR'
\&  $type = $template->query(name => ['EXAMPLE_LOOP', 'BEE']);
\&  $type = $template->query(name => ['EXAMPLE_LOOP', 'BOP']);
.Ve
.Vb 3
\&  # and this one returns 'LOOP'
\&  $type = $template->query(name => ['EXAMPLE_LOOP', 
\&                                    'EXAMPLE_INNER_LOOP']);
.Ve
.Vb 3
\&  # and finally, this returns ('inner_bee', 'inner_bop')
\&  @inner_param_names = $template->query(loop => ['EXAMPLE_LOOP',
\&                                                 'EXAMPLE_INNER_LOOP']);
.Ve
.Vb 3
\&  # for non existent parameter names you get undef
\&  # this returns undef.
\&  $type = $template->query(name => 'DWEAZLE_ZAPPA');
.Ve
.Vb 3
\&  # calling loop on a non-loop parameter name will cause an error.
\&  # this dies:
\&  $type = $template->query(loop => 'DWEAZLE_ZAPPA');
.Ve
As you can see above the \f(CW\*(C`loop\*(C'\fR option returns a list of parameter
names and both \f(CW\*(C`name\*(C'\fR and \f(CW\*(C`loop\*(C'\fR take array refs in order to refer
to parameters inside loops.  It is an error to use \f(CW\*(C`loop\*(C'\fR with a
parameter that is not a loop.
.PP
Note that all the names are returned in lowercase and the types are
uppercase.
.PP
Just like \f(CW\*(C`param()\*(C'\fR, \f(CW\*(C`query()\*(C'\fR with no arguements returns all the
parameter names in the template at the top level.
.SH "FREQUENTLY ASKED QUESTIONS"
.IX Header "FREQUENTLY ASKED QUESTIONS"
In the interest of greater understanding I've started a \s-1FAQ\s0 section of
the perldocs.  Please look in here before you send me email.
.PP
1) Is there a place to go to discuss \s-1HTML:\s0:Template and/or get help?
.PP
There's a mailing-list for \s-1HTML:\s0:Template at htmltmpl@lists.vm.com.
Send a blank message to htmltmpl-subscribe@lists.vm.com to join!
.PP
2) I want support for <\s-1TMPL_XXX\s0>!  How about it?
.PP
Maybe.  I definitely encourage people to discuss their ideas for
\&\s-1HTML:\s0:Template on the mailing list.  Please be ready to explain to me
how the new tag fits in with \s-1HTML:\s0:Template's mission to provide a
fast, lightweight system for using \s-1HTML\s0 templates.
.PP
\&\s-1NOTE:\s0 Offering to program said addition and provide it in the form of
a patch to the most recent version of \s-1HTML:\s0:Template will definitely
have a softening effect on potential opponents!
.PP
3) I found a bug, can you fix it?
.PP
That depends.  Did you send me the \s-1VERSION\s0 of \s-1HTML:\s0:Template, a test
script and a test template?  If so, then almost certainly.
.PP
If you're feeling really adventurous, \s-1HTML:\s0:Template has a publically
available \s-1CVS\s0 server.  See below for more information in the \s-1PUBLIC\s0
\&\s-1CVS\s0 \s-1SERVER\s0 section.
.PP
4) <\s-1TMPL_VAR\s0>s from the main template aren't working inside a <\s-1TMPL_LOOP\s0>!  Why?
.PP
This is the intended behavior.  <\s-1TMPL_LOOP\s0> introduces a separate
scope for <\s-1TMPL_VAR\s0>s much like a subroutine call in Perl introduces a
separate scope for \*(L"my\*(R" variables.  
.PP
If you want your <\s-1TMPL_VAR\s0>s to be global you can set the
\&'global_vars' option when you call \fInew()\fR.  See above for documentation
of the 'global_vars' \fInew()\fR option.
.PP
5) Why do you use /[Tt]/ instead of /t/i?  It's so ugly!
.PP
Simple \- the case-insensitive match switch is very inefficient.
According to _Mastering_Regular_Expressions_ from O'Reilly Press,
/[Tt]/ is faster and more space efficient than /t/i \- by as much as
double against long strings.  //i essentially does a \fIlc()\fR on the
string and keeps a temporary copy in memory.
.PP
When this changes, and it is in the 5.6 development series, I will
gladly use //i.  Believe me, I realize [Tt] is hideously ugly.
.PP
6) How can I pre-load my templates using cache-mode and mod_perl?
.PP
Add something like this to your startup.pl:
.PP
.Vb 2
\&   use HTML::Template;
\&   use File::Find;
.Ve
.Vb 12
\&   print STDERR "Pre-loading HTML Templates...\en";
\&   find(
\&        sub {
\&          return unless /\e.tmpl$/;
\&          HTML::Template->new(
\&                              filename => "$File::Find::dir/$_",
\&                              cache => 1,
\&                             );
\&        },
\&        '/path/to/templates',
\&        '/another/path/to/templates/'
\&      );
.Ve
Note that you'll need to modify the \*(L"return unless\*(R" line to specify
the extension you use for your template files \- I use .tmpl, as you
can see.  You'll also need to specify the path to your template files.
.PP
One potential problem: the \*(L"/path/to/templates/\*(R" must be \s-1EXACTLY\s0 the
same path you use when you call \s-1HTML:\s0:Template->\fInew()\fR.  Otherwise the
cache won't know they're the same file and will load a new copy \-
instead getting a speed increase, you'll double your memory usage.  To
find out if this is happening set cache_debug => 1 in your application
code and look for \*(L"\s-1CACHE\s0 \s-1MISS\s0\*(R" messages in the logs.
.PP
7) What characters are allowed in TMPL_* NAMEs?
.PP
Numbers, letters, '.', '/', '+', '\-' and '_'.
.PP
8) How can I execute a program from inside my template?  
.PP
Short answer: you can't.  Longer answer: you shouldn't since this
violates the fundamental concept behind \s-1HTML:\s0:Template \- that design
and code should be seperate.
.PP
But, inevitably some people still want to do it.  At times it has even
seemed that \s-1HTML:\s0:Template development might split over this issue, so
I will attempt a compromise.  Here is a method you can use to allow
your template authors to evaluate arbitrary perl scripts from within
the template.
.PP
First, tell all your designers that when they want to run a perl
script named \*(L"program.pl\*(R" they should use a tag like:
.PP
.Vb 1
\&  <TMPL_VAR NAME="__execute_program.pl__">
.Ve
Then, have all your programmers call this subroutine instead of
calling \s-1HTML:\s0:Template::new directly.  They still use the same
parameters, but they also get the program execution.  
.PP
.Vb 3
\&  sub new_template {
\&    # get the template object
\&    my $template = HTML::Template->new(@_);
.Ve
.Vb 7
\&    # find program parameters and fill them in
\&    my @params = $template->param();
\&    for my $param (@params) {      
\&       if ($param =~ /^__execute_(.*)__$/) {
\&         $template->param($param, do($1));
\&       }
\&    }
.Ve
.Vb 3
\&    # return the template object
\&    return $template;
\&  }
.Ve
The programs called in this way should return a string containing
their output.  A more complicated subroutine could be written to
capture \s-1STDOUT\s0 from the scripts, but this one is simple enough to
include in the \s-1FAQ\s0.  Another improvement would be to use \fIquery()\fR to
enable program execution inside loops.
.PP
9) Can I get a copy of these docs in Japanese?
.PP
Yes you can.  See Kawai Takanori's translation at:
.PP
.Vb 1
\&   http://member.nifty.ne.jp/hippo2000/perltips/html/template.htm
.Ve
.SH "BUGS"
.IX Header "BUGS"
I am aware of no bugs \- if you find one, join the mailing list and
tell us about it (htmltmpl@lists.vm.com).  You can join the
\&\s-1HTML:\s0:Template mailing-list by sending a blank email to
htmltmpl-subscribe@lists.vm.com.  Of course, you can still email me
directly (sam@tregar.com) with bugs, but I reserve the right to
forward bug reports to the mailing list.
.PP
When submitting bug reports, be sure to include full details,
including the \s-1VERSION\s0 of the module, a test script and a test template
demonstrating the problem!
.PP
If you're feeling really adventurous, \s-1HTML:\s0:Template has a publically
available \s-1CVS\s0 server.  See below for more information in the \s-1PUBLIC\s0
\&\s-1CVS\s0 \s-1SERVER\s0 section.
.SH "CREDITS"
.IX Header "CREDITS"
This module was the brain child of my boss, Jesse Erlbaum
(jesse@vm.com) here at Vanguard Media.  The most original idea in this
module \- the <\s-1TMPL_LOOP\s0> \- was entirely his.
.PP
Fixes, Bug Reports, Optimizations and Ideas have been generously
provided by:
.PP
.Vb 36
\&   Richard Chen
\&   Mike Blazer
\&   Adriano Nagelschmidt Rodrigues
\&   Andrej Mikus
\&   Ilya Obshadko
\&   Kevin Puetz
\&   Steve Reppucci
\&   Richard Dice
\&   Tom Hukins
\&   Eric Zylberstejn
\&   David Glasser
\&   Peter Marelas
\&   James William Carlson
\&   Frank D. Cringle
\&   Winfried Koenig
\&   Matthew Wickline
\&   Doug Steinwand
\&   Drew Taylor
\&   Tobias Brox
\&   Michael Lloyd
\&   Simran Gambhir
\&   Chris Houser <chouser@bluweb.com>
\&   Larry Moore
\&   Todd Larason
\&   Jody Biggs
\&   T.J. Mather
\&   Martin Schroth
\&   Dave Wolfe
\&   uchum
\&   Kawai Takanori
\&   Peter Guelich
\&   Chris Nokleberg
\&   Ralph Corderoy
\&   William Ward
\&   Ade Olonoh
\&   Mark Stosberg
.Ve
Thanks!
.SH "PUBLIC CVS SERVER"
.IX Header "PUBLIC CVS SERVER"
\&\s-1HTML:\s0:Template now has a publicly accessible \s-1CVS\s0 server provided by
SourceForge (www.sourceforge.net).  You can access it by going to
http://sourceforge.net/cvs/?group_id=1075.  Give it a try!
.SH "AUTHOR"
.IX Header "AUTHOR"
Sam Tregar, sam@tregar.com (you can also find me on the mailing list
at htmltmpl@lists.vm.com \- join it by sending a blank message to
htmltmpl-subscribe@lists.vm.com).
.SH "LICENSE"
.IX Header "LICENSE"
\&\s-1HTML:\s0:Template : A module for using \s-1HTML\s0 Templates with Perl
Copyright (C) 2000 Sam Tregar (sam@tregar.com)
.PP
This module is free software; you can redistribute it and/or modify it
under the terms of either:
.PP
a) the \s-1GNU\s0 General Public License as published by the Free Software
Foundation; either version 1, or (at your option) any later version,
or
.PP
b) the \*(L"Artistic License\*(R" which comes with this module.
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT\s0 \s-1ANY\s0 \s-1WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0.  See either
the \s-1GNU\s0 General Public License or the Artistic License for more details.
.PP
You should have received a copy of the Artistic License with this
module, in the file \s-1ARTISTIC\s0.  If not, I'll be glad to provide one.
.PP
You should have received a copy of the \s-1GNU\s0 General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, \s-1MA\s0 02111\-1307
\&\s-1USA\s0
