.\" Automatically generated by Pod::Man version 1.15
.\" Mon Apr 23 12:02:01 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "COMPONENT 1"
.TH COMPONENT 1 "perl v5.6.1" "2000-12-13" "User Contributed Perl Documentation"
.UC
.SH "NAME"
\&\s-1HTML:\s0:Mason::Component \- Mason Component Class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    my $comp1 = $m->current_comp;
\&    my $comp2 = $m->callers(1);
\&    my $comp3 = $m->fetch_comp('foo/bar');
.Ve
.Vb 3
\&    foreach ($comp1,$comp2,$comp3) {
\&       print "My name is ".$_->title.".\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Mason uses the Component class to store components loaded into
memory. Components come from three distinct sources:
.Ip "1" 4
.IX Item "1"
File-based: loaded from a source or object file.
.Ip "2" 4
.IX Item "2"
Subcomponents: embedded components defined with the \f(CW\*(C`<%def>\*(C'\fR tag.
.Ip "3" 4
.IX Item "3"
Anonymous: created on-the-fly with the \f(CW\*(C`make_component\*(C'\fR Parser method.
.PP
Some of the methods below return different values (or nothing at all)
depending on the component type.
.PP
The component \s-1API\s0 is primarily useful for introspection, e.g. \*(L"what
component called me\*(R" or \*(L"does the next component take a certain
argument\*(R".  You can build complex Mason sites without ever dealing
directly with a component object.
.Sh "\s-1CREATING\s0 \s-1AND\s0 \s-1ACCESSING\s0 \s-1COMPONENTS\s0"
.IX Subsection "CREATING AND ACCESSING COMPONENTS"
Common ways to get handles on existing component objects include the
the current_comp entry in the Request manpage, the callers entry in the Request manpage, and the fetch_comp entry in the Request manpage Request methods.
.PP
There is no published \f(CW\*(C`new\*(C'\fR method, because creating a component
requires a parser. Use the the make_component entry in the Parser manpage Parser method to create a
new component dynamically.
.PP
Similarly, there is no \f(CW\*(C`execute\*(C'\fR or \f(CW\*(C`call\*(C'\fR method, because calling a
component requires a request. All of the interfaces for calling a
component (<& &>, \f(CW\*(C`$m\-\*(C'\fRcomp>, \f(CW\*(C`$interp\->exec\*(C'\fR
which normally take a component path, will also take a component
object.
.SH "METHODS"
.IX Header "METHODS"
.Ip "attr (name)" 4
.IX Item "attr (name)"
Looks for the specified attribute in this component and its parents,
returning the first value found. Dies with an error if not
found. Attributes are declared in the \f(CW\*(C`<%attr>\*(C'\fR section.
.Ip "attr_exists (name)" 4
.IX Item "attr_exists (name)"
Returns true if the specified attribute exists in this component or
one of its parents, undef otherwise.
.Ip "cache_file" 4
.IX Item "cache_file"
Returns the data cache filename for this component.
.Ip "create_time" 4
.IX Item "create_time"
Returns the time (in Perl \fItime()\fR format) when this component object
was created.
.Ip "declared_args" 4
.IX Item "declared_args"
Returns a reference to a hash of hashes representing the arguments
declared in the \f(CW\*(C`<%args>\*(C'\fR section. The keys of the main hash are the
variable names including prefix (e.g. \f(CW\*(C`$foo\*(C'\fR, \f(CW\*(C`@lst\*(C'\fR). Each	
secondary hash contains:
.RS 4
.Ip "\(bu" 4
\&'default': the string specified for default value (e.g. 'fido') or undef
if none specified.  Note that in general this is not the default value
itself but rather an expression that gets evaluated every time the
component runs.
.RE
.RS 4
.Sp
For example:
.Sp
.Vb 2
\&  # does $comp have an argument called $fido?
\&  if (exists($comp->declared_args->{'$fido'})) { ... }
.Ve
.Vb 2
\&  # does $fido have a default value?
\&  if (defined($comp->declared_args->{'$fido'}->{default})) { ... }
.Ve
.RE
.Ip "dir_path" 4
.IX Item "dir_path"
Returns the component's notion of a current directory, relative to the
component root; this is used to resolve relative component paths. For
file-based components this is the full component path minus the final
piece.  For subcomponents this is the same as its parent component.
Undefined for anonymous components.
.Ip "first_time" 4
.IX Item "first_time"
Returns true if this is the first time the component has executed,
false otherwise.  Useful for initializing persistent component
lexicals:
.Sp
.Vb 2
\&  if ($m->current_comp->first_time) {
\&     $dbh = DBI->connect(...);
.Ve
Note that in a web-based environment, this \*(L"first time\*(R" will
come once for each child and every time the component is reloaded.
.Ip "flag (name)" 4
.IX Item "flag (name)"
Returns the value for the specified system flag.  Flags are declared
in the \f(CW\*(C`<%flags>\*(C'\fR section and affect the behavior of the component.
.Ip "is_subcomp" 4
.IX Item "is_subcomp"
Returns true if this is a subcomponent of another component.
.Ip "is_file_based" 4
.IX Item "is_file_based"
Returns true if this component was loaded from a source or object
file.
.Ip "call_method (name, args...)" 4
.IX Item "call_method (name, args...)"
Looks for the specified user-defined method in this component and its
parents, calling the first one found. Dies with an error if not found.
Methods are declared in the \f(CW\*(C`<%method>\*(C'\fR section.
.Ip "method_exists (name)" 4
.IX Item "method_exists (name)"
Returns true if the specified user-defined method exists in this
component or one of its parents, undef otherwise.
.Ip "name" 4
.IX Item "name"
Returns a short name of the component.  For file-based components this
is the filename without the path. For subcomponents this is the name
specified in \f(CW\*(C`<%def>\*(C'\fR. Undefined for anonymous components.
.Ip "object_file" 4
.IX Item "object_file"
Returns the object filename for this component.
.Ip "owner" 4
.IX Item "owner"
Defined only for subcomponents; returns the component that this
subcomponent was defined in.
.Ip "parent" 4
.IX Item "parent"
Returns the parent of this component for inheritance purposes, by
default the nearest \f(CW\*(C`autohandler\*(C'\fR in or above the component's directory.
Can be changed via the \f(CW\*(C`inherit\*(C'\fR flag.
.Ip "path" 4
.IX Item "path"
Returns the absolute path of this component.
.Ip "run_count" 4
.IX Item "run_count"
Returns the number of times this component has been invoked. In a
web-based environment, this value is separate for each child and
resets every time the component is reloaded.
.Ip "scall_method (name, args...)" 4
.IX Item "scall_method (name, args...)"
Like the call_method entry in the Component manpage, but returns the method output as a
string instead of printing it. (Think sprintf versus printf.) The
method's return value is discarded.
.Ip "subcomps" 4
.IX Item "subcomps"
With no arguments, returns a hashref containing the subcomponents defined
in this component, with names as keys and component objects as values.
With one argument, returns the subcomponent of that name
or undef if no such subcomponent exists. e.g.
.Sp
.Vb 3
\&    if (my $subcomp = $comp->subcomps('.link')) {
\&        ...
\&    }
.Ve
Subcomponents are declared in the \f(CW\*(C`<%def>\*(C'\fR section.
.Ip "title" 4
.IX Item "title"
Returns a printable string denoting this component.  It is intended to
uniquely identify a component within a given interpreter although this
is not 100% guaranteed. Mason uses this string in error messages,
the previewer component trace, and \f(CW\*(C`$m\-\*(C'\fRcomp_stack>.
.Sp
For file-based components this is the component path.  For
subcomponents this is \*(L"parent_component_path:subcomponent_name\*(R". For
anonymous components this is a unique label like \*(L"[anon 17]\*(R".
.SH "FILE-BASED METHODS"
.IX Header "FILE-BASED METHODS"
The following methods apply only to file-based components (those
loaded from source or object files). They return undef for other
component types.
.Ip "source_file" 4
.IX Item "source_file"
Returns the source filename for this component.
.Ip "source_dir" 4
.IX Item "source_dir"
Returns the directory of the source filename for this component.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jonathan Swartz, swartz@pobox.com
.SH "SEE ALSO"
.IX Header "SEE ALSO"
the HTML::Mason::Request manpage
