.\" Automatically generated by Pod::Man version 1.15
.\" Mon Apr 23 08:20:48 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "Class::Fields::Fuxor 3"
.TH Class::Fields::Fuxor 3 "perl v5.6.1" "2000-07-16" "User Contributed Perl Documentation"
.UC
.SH "NAME"
.Vb 1
\&  Class::Fields::Fuxor - Low level manipuation of object data members
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\&  # As functions.
\&  use Class::Fields::Fuxor;
\&  add_fields($class, $attrib, @fields);
\&  add_field_set($class, \e@fields, \e@attribs);
\&  has_fields($class);
\&  $fields = get_fields($class);
\&  $fattr  = get_attr($class);
.Ve
.Vb 3
\&  # As methods.
\&  package Foo;
\&  use base qw( Class::Fields::Fuxor );
.Ve
.Vb 4
\&  Foo->add_fields($attrib, @fields);
\&  Foo->has_fields;
\&  $fields   = Foo->get_fields;
\&  $fattr    = Foo->get_attr;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a module for low level manipuation of the \f(CW%FIELDS\fR hash and its
accompying \f(CW%fields::attr\fR hash without actually touching them.  Modules
like fields.pm, base.pm and public.pm make use of this module.
.PP
%FIELDS and \f(CW%fields::attr\fR are currently used to store information
about the data members of classes.  Since the current data inheritance
system, built around pseudo-hashes, is considered a bit twitchy, it is
wise to encapsulate and rope it off in the expectation that it will be
replaced with something better.
.PP
Typically one does not want to mess with this stuff and instead uses
fields.pm and friends or perhaps Class::Fields.
.Ip "\fBadd_fields\fR" 4
.IX Item "add_fields"
.Vb 1
\&  add_fields($class, $attrib, @fields);
.Ve
Adds a bunch of \f(CW@fields\fR to the given \f(CW$class\fR using the given \f(CW$attrib\fR.
For example:
.Sp
.Vb 3
\&    # Add the public fields 'this' and 'that' to the class Foo.
\&    use Class::Fields::Attribs;
\&    add_fields('Foo', PUBLIC, qw(this that));
.Ve
$attrib is built from the constants in Class::Fields::Attribs
.Ip "\fBadd_field_set\fR" 4
.IX Item "add_field_set"
.Vb 1
\&  add_field_set($class, \e@fields, \e@attribs);
.Ve
Functionally similar to \fIadd_fields()\fR, excepting that it can add a
group of fields with different attributes all at once.  This is
necessary for the proper functioning of fields.pm.
.Sp
Each element in \f(CW@fields\fR matches up with one in \f(CW@attribs\fR.  Obviously,
the two arrays must be the same size.
.Ip "\fBhas_fields\fR" 4
.IX Item "has_fields"
.Vb 1
\&  has_fields($class);
.Ve
A simple check to see if the given \f(CW$class\fR has a \f(CW%FIELDS\fR hash defined.
A simple test like (defined %{\*(L"$class\e::FIELDS\*(R"}) will sometimes
produce typo warnings because it would create the hash if it was not
present before.
.Ip "\fBget_attr\fR" 4
.IX Item "get_attr"
.Vb 1
\&  $fattr = get_attr($class);
.Ve
Get's the field attribute array for the given \f(CW$class\fR.  This is roughly
equivalent to \f(CW$fields::attr\fR{$class} but we put a nice wrapper around
it for compatibility and readability.
.Sp
$fattr is an array reference containing the attributes of the fields
in the given \f(CW$class\fR.  Each entry in \f(CW$fattr\fR corresponds to the position
indicated by the \f(CW$class\fR's \f(CW%FIELDS\fR has.  For example:
.Sp
.Vb 2
\&    package Foo;
\&    use fields qw(this _that);
.Ve
.Vb 1
\&    $fattr = get_attr('Foo');
.Ve
.Vb 2
\&    # Get the attributes for '_that' in the class 'Foo'.
\&    $that_attribs = print $fattr->[$Foo::FIELDS->{_that}];
.Ve
When possible, one should avoid using this function since it exposes
more implementation detail than I'd like.  Class::Fields
should provide most of the functionality you'll need.
.Ip "\fBget_fields\fR" 4
.IX Item "get_fields"
.Vb 1
\&  $fields = get_fields($class);
.Ve
Gets a reference to the \f(CW%FIELDS\fR hash for the given \f(CW$class\fR.  It will
autogenerate a \f(CW%FIELDS\fR hash if one doesn't already exist.  If you
don't want this behavior, be sure to check beforehand with
\&\fIhas_fields()\fR.
.Sp
When possible, one should avoid using this function since it exposes
more implementation detail than I'd like.  Class::Fields
should provide most of the functionality you'll need.
.SH "AUTHOR"
.IX Header "AUTHOR"
Michael G Schwern <schwern@pobox.com> based heavily on code liberated
from the original fields.pm and base.pm.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
the fields manpage, the base manpage, the public manpage, the private manpage, the protected manpage,
the Class::Fields manpage, the Class::Fields::Attribs manpage
