.\" Automatically generated by Pod::Man version 1.15
.\" Mon Apr 23 08:13:46 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "Array::IntSpan::IP 3"
.TH Array::IntSpan::IP 3 "perl v5.6.1" "2000-02-24" "User Contributed Perl Documentation"
.UC
.SH "NAME"
Array::IntSpan::IP \- a Module for arrays using \s-1IP\s0 addresses as indices
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Array::IntSpan::IP;
.Ve
.Vb 3
\&  my $foo = Array::IntSpan::IP->new(['123.45.67.0',   '123.45.67.255', 'Network 1'],
\&                                    ['123.45.68.0',   '123.45.68.127', 'Network 2'],
\&                                    ['123.45.68.128', '123.45.68.255', 'Network 3']);
.Ve
.Vb 4
\&  print "The address 123.45.68.37 is on network ".$foo->lookup("\e173\e105\e150\e45").".\en";
\&  unless (defined($foo->lookup(((123*256+45)*256+65)*256+67))) {
\&    print "The address 123.45.65.67 is not on a known network.\en";
\&  }
.Ve
.Vb 1
\&  print "The address 123.45.68.177 is on network ".$foo->lookup("123.45.68.177").".\en";
.Ve
.Vb 2
\&  $foo->set_range('123.45.68.128', '123.45.68.255', 'Network 4');
\&  print "The address 123.45.68.177 is now on network ".$foo->lookup("123.45.68.177").".\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Array::IntSpan::IP\*(C'\fR brings the advantages of \f(CW\*(C`Array::IntSpan\*(C'\fR to \s-1IP\s0 address indices.  Anywhere
you use an index in \f(CW\*(C`Array::IntSpan\*(C'\fR, you can use an \s-1IP\s0 address in one of three forms in
\&\f(CW\*(C`Array::IntSpan::IP\*(C'\fR.  The three accepted forms are:
.Ip "Dotted decimal" 4
.IX Item "Dotted decimal"
This is the standard human-readable format for \s-1IP\s0 addresses.  The conversion checks that the
octets are in the range 0\-255.  Example: \f(CW\*(C`'123.45.67.89'\*(C'\fR.
.Ip "Network string" 4
.IX Item "Network string"
A four character string representing the octets in network order. Example: \f(CW\*(C`"\e173\e105\e150\e131"\*(C'\fR.
.Ip "Integer" 4
.IX Item "Integer"
A integer value representing the \s-1IP\s0 address. Example: \f(CW\*(C`((123*256+45)*256+67)*256+89\*(C'\fR or
\&\f(CW\*(C`2066563929\*(C'\fR.
.PP
Note that the algorithm has no way of distinguishing between the integer values 1000 through 9999
and the network string format.  It will presume network string format in these instances.  For
instance, the integer \f(CW\*(C`1234\*(C'\fR (representing the address \f(CW\*(C`'0.0.4.210'\*(C'\fR) will be interpreted as
\&\f(CW\*(C`"\e61\e62\e63\e64"\*(C'\fR, or the \s-1IP\s0 address \f(CW\*(C`'49.50.51.52'\*(C'\fR.  This is unavoidable since Perl does not
strongly type integers and strings separately and there is no other information available to
distinguish between the two in this situation.  I do not expect that this will be a problem in
most situations. Most users will probably use dotted decimal or network string notations, and even
if they do use the integer notation the likelyhood that they will be using the addresses
\&\f(CW\*(C`'0.0.3.232'\*(C'\fR through \f(CW\*(C`'0.0.39.15'\*(C'\fR as indices is relatively low.
.SH "METHODS"
.IX Header "METHODS"
.Sh "ip_as_int"
.IX Subsection "ip_as_int"
The class method \f(CW\*(C`Array::IntSpan::IP::ip_as_int\*(C'\fR takes as its one parameter the \s-1IP\s0 address in one
of the three formats mentioned above and returns the integer notation.
.SH "AUTHOR"
.IX Header "AUTHOR"
Toby Everett, teverett@alascom.att.com
