.\" Automatically generated by Pod::Man version 1.15
.\" Mon Apr 23 08:19:14 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "Elements 3"
.TH Elements 3 "perl v5.6.1" "1997-11-03" "User Contributed Perl Documentation"
.UC
.SH "NAME"
Chemistry::Elements \- Perl extension for working with Chemical Elements
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Chemistry::Elements qw(get_name get_Z get_symbol);
.Ve
.Vb 4
\&  # the constructor can use different input
\&  $element = new Chemistry::Elements $atomic_number;
\&  $element = new Chemistry::Elements $chemical_symbol;
\&  $element = new Chemistry::Elements $element_name;
.Ve
.Vb 4
\&  # you can make up your own attributes by specifying
\&  # a method (which is really AUTOLOAD)
\&        $element->molar_mass(22.989) #sets the attribute
\&  $MM = $element->molar_mass         #retrieves the value
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
There are two parts to the module:  the object stuff and the exportable
functions for use outside of the object stuff.  The exportable
functions are discussed in \s-1EXPORTABLE\s0 \s-1FUNCTIONS\s0.
.PP
Chemistry::Elements provides an easy, object-oriented way to
keep track of your chemical data.  Using either the atomic
number, chemical symbol, or element name you can construct
an Element object.  Once you have an element object, you can
associate your data with the object by making up your own
methods, which the \s-1AUTOLOAD\s0 function handles.  Since each
chemist is likely to want to use his or her own data, or
data for some unforesee-able property, this module does not
try to be a repository for chemical data.
.PP
The Element object constructor tries to be as flexible as possible \-
pass it an atomic number, chemical symbol, or element name and it
tries to create the object.
.PP
.Vb 4
\&  # the constructor can use different input
\&  $element = new Chemistry::Elements $atomic_number;
\&  $element = new Chemistry::Elements $chemical_symbol;
\&  $element = new Chemistry::Elements $element_name;
.Ve
once you have the object, you can define your own methods simply
by using them.  Giving the method an argument (others will be
ignored) creates an attribute with the method's name and
the argument's value.
.PP
.Vb 4
\&  # you can make up your own attributes by specifying
\&  # a method (which is really AUTOLOAD)
\&        $element->molar_mass(22.989) #sets the attribute
\&  $MM = $element->molar_mass         #retrieves the value
.Ve
The atomic number, chemical symbol, and element name can be
retrieved in the same way.
.PP
.Vb 3
\&   $atomic_number = $element->Z;
\&   $name          = $element->name;
\&   $symbol        = $element->symbol;
.Ve
These methods can also be used to set values, although changing
any of the three affects the other two.
.PP
.Vb 1
\&   $element       = new Chemistry::Elements('Lead');
.Ve
.Vb 1
\&   $atomic_number = $element->Z;    # $atomic_number is 82
.Ve
.Vb 1
\&   $element->Z(79);
.Ve
.Vb 1
\&   $name          = $element->name; # $name is 'Gold'
.Ve
.SH "EXPORTABLE FUNCTIONS"
.IX Header "EXPORTABLE FUNCTIONS"
These functions can be exported.  They are not exported by default.
.Sh "\fIget_symbol()\fP"
.IX Subsection "get_symbol()"
This function attempts to return the symbol of the chemical element given
either the chemical symbol, element name, or atmoic number.  The
function does its best to interpret inconsistent input data (e.g.
chemcial symbols of mixed and single case).
.PP
.Vb 1
\&        use Chemistry::Elements qw(get_symbol);
.Ve
.Vb 5
\&        $name = get_symbol('Fe');     #$name is 'Fe'
\&        $name = get_symbol('fe');     #$name is 'Fe'
\&        $name = get_symbol(26);       #$name is 'Fe'
\&        $name = get_symbol('Iron');   #$name is 'Fe'
\&        $name = get_symbol('iron');   #$name is 'Fe'
.Ve
If no symbol can be found, undef is returned.
.PP
Since this function will return the symbol if it is given a symbol,
you can use it to test whether a string is a chemical symbol
(although you have to play some tricks with case since get_symbol
will try its best despite the case of the input data).
.PP
.Vb 4
\&        if( lc($string) eq lc( get_symbol($string) ) )
\&                {
\&                #stuff
\&                }
.Ve
You can modify the symbols (e.g. you work for UCal ;) ) by changing
the data at the end of this module.
.Sh "\fIget_name()\fP"
.IX Subsection "get_name()"
This function attempts to return the name the chemical element given
either the chemical symbol, element name, or atomic number.  The
function does its best to interpret inconsistent input data (e.g.
chemcial symbols of mixed and single case).
.PP
.Vb 5
\&        $name = get_name('Fe');     #$name is 'Iron'
\&        $name = get_name('fe');     #$name is 'Iron'
\&        $name = get_name(26);       #$name is 'Iron'
\&        $name = get_name('Iron');   #$name is 'Iron'
\&        $name = get_name('iron');   #$name is 'Iron'
.Ve
If there is no Z can be found, undef is returned.
.PP
Since this function will return the name if it is given a name,
you can use it to test whether a string is a chemical element name
(although you have to play some tricks with case since get_name
will try its best despite the case of the input data).
.PP
.Vb 4
\&        if( lc($string) eq lc( get_name($string) ) )
\&                {
\&                #stuff
\&                }
.Ve
You can modify the names (e.g. for different languages) by changing
the data at the end of this module.
.Sh "\fIget_Z()\fP"
.IX Subsection "get_Z()"
This function attempts to return the atomic number of the chemical
element given either the chemical symbol, element name, or atomic
number.  The function does its best to interpret inconsistent input data
(e.g. chemcial symbols of mixed and single case).
.PP
.Vb 5
\&        $name = get_Z('Fe');     #$name is 26
\&        $name = get_Z('fe');     #$name is 26
\&        $name = get_Z(26);       #$name is 26
\&        $name = get_Z('Iron');   #$name is 26
\&        $name = get_Z('iron');   #$name is 26
.Ve
If there is no Z can be found, undef is returned.
.PP
Since this function will return the Z if it is given a Z,
you can use it to test whether a string is an atomic number.
You might want to use the string comparison in case the
\&\f(CW$string\fR is not a number (in which case the comparison
will be false save for the case when \f(CW$string\fR is undefined).
.PP
.Vb 4
\&        if( $string eq get_Z($string) )
\&                {
\&                #stuff
\&                }
.Ve
The package constructor automatically finds the largest defined
atomic number (in case you add your own heavy elements).
.Sh "AUTOLOADing methods"
.IX Subsection "AUTOLOADing methods"
You can pseudo-define additional methods to associate data with objects.
For instance, if you wanted to add a molar mass attribute, you
simply pretend that there is a molar_mass method:
.PP
.Vb 1
\&        $element->molar_mass($MM); #add molar mass datum in $MM to object
.Ve
Similiarly, you can retrieve previously set values by not specifying
an argument to your pretend method:
.PP
.Vb 1
\&        $datum = $element->molar_mass();
.Ve
.Vb 2
\&        #or without the parentheses
\&        $datum = $element->molar_mass;
.Ve
If a value has not been associated with the pretend method and the
object, the pretend method returns undef.
.PP
I had thought about providing basic data for the elements, but
thought that anyone using this module would probably have their
own data.  If there is an interest in canned data, perhaps I can
provide mine :)
.SH "TO DO"
.IX Header "TO DO"
I would like make this module easily localizable so that one could
specify other names or symbols for the elements (i.e. a different
language or a different perspective on the heavy elements).  If
anyone should make changes to the data, i would like to get a copy
so that i can include it in future releases :)
.SH "AUTHOR"
.IX Header "AUTHOR"
brian d foy <comdog@computerdog.com>
