.\" Automatically generated by Pod::Man version 1.15
.\" Mon Apr 23 13:53:46 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "XML::Grove::AsString 3"
.TH XML::Grove::AsString 3 "perl v5.6.1" "1998-09-25" "User Contributed Perl Documentation"
.UC
.SH "NAME"
\&\s-1XML:\s0:Grove::AsString \- output content of \s-1XML\s0 objects as a string
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use XML::Grove::AsString;
.Ve
.Vb 2
\& $string = $xml_object->as_string OPTIONS;
\& $string = $element->attr_as_string $attr, OPTIONS;
.Ve
.Vb 1
\& $writer = new XML::Grove::AsString OPTIONS;
.Ve
.Vb 6
\& # OPTIONS
\& $writer->filter([ \e&callback ]);
\& $writer->entity_map([ \e&callback ]);
\& $writer->entity_map([ $mapper ]);
\& $writer->entity_map_options([ \e%options ]);
\& $writer->entity_map_filter([ $bool ]);
.Ve
.Vb 2
\& $string = $writer->as_string($xml_object);
\& $writer->as_string($xml_object, $file_handle);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Calling `\f(CW\*(C`as_string\*(C'\fR' on an \s-1XML\s0 object returns the character data
contents of that object as a string, including all elements below that
object.  Calling `\f(CW\*(C`attr_as_string\*(C'\fR' on an element returns the
contents of the named attribute as a string.  Comments, processing
instructions, and, by default, entities all return an empty string.
.PP
\&\fI\s-1OPTIONS\s0\fR may either be a key-value list or a hash containing the
options described below.  The default options are no filtering and
entities are mapped to empty strings.
.SH "OPTIONS"
.IX Header "OPTIONS"
This list summarizes the options available for `\f(CW\*(C`as_string\*(C'\fR':
.PP
.Vb 4
\&    filter => sub to filter character data
\&    entity_map => an object or sub to map character entities
\&    entity_map_options => options passed to entity_map
\&    entity_map_filter => true to use filter on mapped entities
.Ve
`\f(CW\*(C`filter\*(C'\fR' is an anonymous sub that gets called to process character
data before it is appended to the string to be returned.  This can be
used, for example, to escape characters that are special in output
formats.  `\f(CW\*(C`entity_map_filter\*(C'\fR' is a flag to indicate if mapped
entities should be filtered after mapping.  `\f(CW\*(C`filter\*(C'\fR' is called like
this:
.PP
.Vb 1
\&    $string = &$filter ($character_data);
.Ve
`\f(CW\*(C`entity_map\*(C'\fR' is an object that accepts `\f(CW\*(C`lookup\*(C'\fR' methods or an
anonymous sub that gets called with the entity replacement text (data)
and mapper options as arguments and returns the corresponding
character replacements.  It is called like this:
.PP
.Vb 2
\&    $replacement_text = $entity_map->lookup ($entity_data,
\&                                             $entity_map_options);
.Ve
or this:
.PP
.Vb 2
\&    $replacement_text = &$entity_map ($entity_data,
\&                                      $entity_map_options);
.Ve
`\f(CW\*(C`entity_map_options\*(C'\fR' is passed through to the `\f(CW\*(C`lookup\*(C'\fR' method,
the type of value is defined by the entity mapping package or the
anonymous sub.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Here is an example of entity mapping using the Text::EntityMap module:
.PP
.Vb 2
\&    use Text::EntityMap;
\&    use XML::Grove::AsString;
.Ve
.Vb 4
\&    $html_iso_dia = Text::EntityMap->load ('ISOdia.2html');
\&    $html_iso_pub = Text::EntityMap->load ('ISOpub.2html');
\&    $html_map = Text::EntityMap->group ($html_iso_dia,
\&                                        $html_iso_pub);
.Ve
.Vb 1
\&    $element->as_string (entity_map => $html_map);
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Ken MacLeod, ken@bitsko.slc.ut.us
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1), \s-1XML:\\fIs0:Parser\fR\|(3), \s-1XML:\\fIs0:Parser::Grove\fR\|(3).
.PP
Extensible Markup Language (\s-1XML\s0) <http://www.w3c.org/XML>
