.\" Automatically generated by Pod::Man version 1.15
.\" Mon Apr 23 13:18:23 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "Map 3"
.TH Map 3 "perl v5.6.1" "2000-08-21" "User Contributed Perl Documentation"
.UC
.SH "NAME"
Unicode::Map V0.108 \- maps charsets from and to utf16 unicode 
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
use \fIUnicode::Map()\fR;
.Sp
\&\fI$Map\fR = new Unicode::Map(\*(L"\s-1ISO-8859\-1\s0\*(R");
.Sp
\&\fI$utf16\fR = \fI$Map\fR \-> to_unicode (\*(L"Hello world!\*(R");
  => \f(CW$utf16\fR == \*(L"\e0H\e0e\e0l\e0l\e0o\e0 \e0w\e0o\e0r\e0l\e0d\e0!\*(R"
.Sp
\&\fI$locale\fR = \fI$Map\fR \-> from_unicode (\fI$utf16\fR);
  => \f(CW$locale\fR == \*(L"Hello world!\*(R"
.PP
A more detailed description below.
.PP
2do: short note about perl's Unicode perspectives.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module converts strings from and to 2\-byte Unicode \s-1UCS2\s0 format. 
All mappings happen via 2 byte \s-1UTF16\s0 encodings, not via 1 byte \s-1UTF8\s0
encoding. To transform these use Unicode::String.
.PP
For historical reasons this module coexists with Unicode::Map8.
Please use Unicode::Map8 unless you need to care for two byte character
sets, e.g. chinese \s-1GB2312\s0. Anyway, if you stick to the basic 
functionality (see documentation) you can use both modules equivalently.
.PP
Practically this module will disappear from earth sooner or later as 
Unicode mapping support needs somehow to get into perl's core. If you 
like to work on this field please don't hesitate contacting Gisle Aas!
.PP
This module can't deal directly with utf8. Use Unicode::String to convert
utf8 to utf16 and vice versa.
.PP
Character mapping is according to the data of binary mapfiles in Unicode::Map 
hierarchy. Binary mapfiles can also be created with this module, enabling you
to install own specific character sets. Refer to mkmapfile or file \s-1REGISTRY\s0 in the Unicode::Map hierarchy.
.SH "CONVERSION METHODS"
.IX Header "CONVERSION METHODS"
Probably these are the only methods you will need from this module. Their
usage is compatible with Unicode::Map8.
.Ip "new" 4
.IX Item "new"
\&\fI$Map\fR = new Unicode::Map(\*(L"\s-1GB2312\-80\s0\*(R")
.Sp
Returns a new Map object for \s-1GB2312\-80\s0 encoding.
.Ip "from_unicode" 4
.IX Item "from_unicode"
\&\fI$dest\fR = \fI$Map\fR \-> from_unicode (\fI$src\fR)
.Sp
Creates a string in locale charset representation from utf16 encoded
string \fI$src\fR.
.Ip "to_unicode" 4
.IX Item "to_unicode"
\&\fI$dest\fR   = \fI$Map\fR \-> to_unicode (\fI$src\fR)
.Sp
Creates a string in utf16 representation from \fI$src\fR.
.Ip "to8" 4
.IX Item "to8"
Alias for \fIfrom_unicode\fR. For compatibility with Unicode::Map8
.Ip "to16" 4
.IX Item "to16"
Alias for \fIto_unicode\fR. For compatibility with Unicode::Map8
.SH "WARNINGS"
.IX Header "WARNINGS"
You can demand Unicode::Map to issue warnings at deprecated or incompatible 
usage with the constants \s-1WARN_DEFAULT\s0, \s-1WARN_DEPRECATION\s0 or \s-1WARN_COMPATIBILITY\s0.
The latter both can be ored together.
.Ip "No special warnings:" 4
.IX Item "No special warnings:"
$Unicode::Map::WARNINGS = Unicode::Map::WARN_DEFAULT
.Ip "Warnings for deprecated usage:" 4
.IX Item "Warnings for deprecated usage:"
$Unicode::Map::WARNINGS = Unicode::Map::WARN_DEPRECATION
.Ip "Warnings for incompatible usage:" 4
.IX Item "Warnings for incompatible usage:"
$Unicode::Map::WARNINGS = Unicode::Map::WARN_COMPATIBILITY
.SH "MAINTAINANCE METHODS"
.IX Header "MAINTAINANCE METHODS"
\&\fINote:\fR These methods are solely for the maintainance of Unicode::Map.
Using any of these methods will lead to programs incompatible with
Unicode::Map8.
.Ip "alias" 4
.IX Item "alias"
\&\fI@list\fR = \fI$Map\fR \-> alias (\fI$csid\fR)
.Sp
Returns a list of alias names of character set \fI$csid\fR.
.Ip "mapping" 4
.IX Item "mapping"
\&\fI$path\fR = \fI$Map\fR \-> mapping (\fI$csid\fR)
.Sp
Returns the absolute path of binary character mapping for character set 
\&\fI$csid\fR according to \s-1REGISTRY\s0 file of Unicode::Map.
.Ip "id" 4
.IX Item "id"
\&\fI$real_id\fR||\f(CW\*(C`""\*(C'\fR = \fI$Map\fR \-> id (\fI$test_id\fR)
.Sp
Returns a valid character set identifier \fI$real_id\fR, if \fI$test_id\fR is
a valid character set name or alias name according to \s-1REGISTRY\s0 file of 
Unicode::Map.
.Ip "ids" 4
.IX Item "ids"
\&\fI@ids\fR = \fI$Map\fR \-> \fIids()\fR
.Sp
Returns a list of all character set names defined in \s-1REGISTRY\s0 file.
.Ip "read_text_mapping" 4
.IX Item "read_text_mapping"
\&\f(CW\*(C`1\*(C'\fR||\f(CW\*(C`0\*(C'\fR = \fI$Map\fR \-> read_text_mapping (\fI$csid\fR, \fI$path\fR, \fI$style\fR)
.Sp
Read a text mapping of style \fI$style\fR named \fI$csid\fR from filename \fI$path\fR.
The mapping then can be saved to a file with method: write_binary_mapping.
<$style> can be:
.Sp
.Vb 1
\& style          description
.Ve
.Vb 4
\& "unicode"    A text mapping as of ftp://ftp.unicode.org/MAPPINGS/
\& ""           Same as "unicode"
\& "reverse"    Similar to unicode, but both columns are switched
\& "keld"       A text mapping as of ftp://dkuug.dk/i18n/charmaps/
.Ve
.Ip "src" 4
.IX Item "src"
\&\fI$path\fR = \fI$Map\fR \-> src (\fI$csid\fR)
.Sp
Returns the path of textual character mapping for character set \fI$csid\fR 
according to \s-1REGISTRY\s0 file of Unicode::Map.
.Ip "style" 4
.IX Item "style"
\&\fI$path\fR = \fI$Map\fR \-> style (\fI$csid\fR)
.Sp
Returns the style of textual character mapping for character set \fI$csid\fR 
according to \s-1REGISTRY\s0 file of Unicode::Map.
.Ip "write_binary_mapping" 4
.IX Item "write_binary_mapping"
\&\f(CW\*(C`1\*(C'\fR||\f(CW\*(C`0\*(C'\fR = \fI$Map\fR \-> write_binary_mapping (\fI$csid\fR, \fI$path\fR)
.Sp
Stores a mapping that has been loaded via method read_text_mapping in
file \fI$path\fR.
.SH "DEPRECATED METHODS"
.IX Header "DEPRECATED METHODS"
Some functionality is no longer promoted.
.Ip "noise" 4
.IX Item "noise"
Deprecated! Don't use any longer.
.Ip "reverse_unicode" 4
.IX Item "reverse_unicode"
Deprecated! Use Unicode::String::byteswap instead.
.SH "BINARY MAPPINGS"
.IX Header "BINARY MAPPINGS"
Structure of binary Mapfiles
.PP
Unicode character mapping tables have sequences of sequential key and
sequential value codes. This property is used to crunch the maps easily. 
n (0<n<256) sequential characters are represented as a bytecount n and
the first character code key_start. For these subsequences the according 
value sequences are crunched together, also. The value 0 is used to start
an extended information block (that is just partially implemented, though).
.PP
One could think of two ways to make a binary mapfile. First method would 
be first to write a list of all key codes, and then to write a list of all 
value codes. Second method, used here, appends to all partial key code lists
the according crunched value code lists. This makes value codes a little bit
closer to key codes. 
.PP
\&\fBNote: the file format is still in a very liquid state. Neither rely on
that it will stay as this, nor that the description is bugless, nor that
all features are implemented.\fR
.PP
\&\s-1STRUCTURE:\s0
.Ip "<main>:" 4
.IX Item "<main>:"
.Vb 1
\&   offset  structure     value
.Ve
.Vb 2
\&   0x00    word          0x27b8   (magic)
\&   0x02    @(<extended> || <submapping>)
.Ve
The mapfile ends with extended mode <end> in main stream.
.Ip "<submapping>:" 4
.IX Item "<submapping>:"
.Vb 5
\&   0x00    byte != 0     charsize1 (bits)
\&   0x01    byte          n1 number of chars for one entry
\&   0x02    byte          charsize2 (bits)
\&   0x03    byte          n2 number of chars for one entry
\&   0x04    @(<extended> || <key_seq> || <key_val_seq)
.Ve
.Vb 1
\&   bs1=int((charsize1+7)/8), bs2=int((charsize2+7)/8)
.Ve
One submapping ends when <mapend> entry occurs.
.Ip "<key_val_seq>:" 4
.IX Item "<key_val_seq>:"
.Vb 6
\&   0x00    size=0|1|2|4  n, number of sequential characters 
\&   size    bs1           key1
\&   +bs1    bs2           value1
\&   +bs2    bs1           key2
\&   +bs1    bs2           value2
\&   ...
.Ve
key_val_seq ends, if either file ends (n = infinite mode) or n pairs are
read.
.Ip "<key_seq>:" 4
.IX Item "<key_seq>:"
.Vb 3
\&   0x00    byte          n, number of sequential characters 
\&   0x01    bs1           key_start, first character of sequence
\&   1+bs1   @(<extended> || <val_seq>)
.Ve
A key sequence starts with a byte count telling how long the sequence
is. It is followed by the key start code. After this comes a list of 
value sequences. The list of value sequences ends, if \fIsum\fR\|(m) equals n.
.Ip "<val_seq>:" 4
.IX Item "<val_seq>:"
.Vb 2
\&   0x00    byte          m, number of sequential characters
\&   0x01    bs2           val_start, first character of sequence
.Ve
.Ip "<extended>:" 4
.IX Item "<extended>:"
.Vb 4
\&   0x00    byte          0
\&   0x01    byte          ftype
\&   0x02    byte          fsize, size of following structure
\&   0x03    fsize bytes   something
.Ve
For future extensions or private use one can insert here 1..255 byte long 
streams. ftype can have values 30..255, values 0..29 are reserved. Modi
are not fully defined now and could change. They will be explained later.
.SH "TO BE DONE"
.IX Header "TO BE DONE"
.Ip "\-" 4
Something clever, when a character has no translation.
.Ip "\-" 4
Direct charset \-> charset mapping.
.Ip "\-" 4
Better performance.
.Ip "\-" 4
Support for mappings according to \s-1RFC\s0 1345.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.Ip "\-" 4
File \f(CW\*(C`REGISTRY\*(C'\fR and binary mappings in directory \f(CW\*(C`Unicode/Map\*(C'\fR of your
perl library path 
.Ip "\-" 4
\&\fIrecode\fR\|(1), \fImap\fR\|(1), \fImkmapfile\fR\|(1), \fIUnicode::Map\fR\|(3), \fIUnicode::Map8\fR\|(3),
\&\fIUnicode::String\fR\|(3), \fIUnicode::CharName\fR\|(3), \fImirrorMappings\fR\|(1)
.Ip "\-" 4
\&\s-1RFC\s0 1345
.Ip "\-" 4
Mappings at Unicode consortium ftp://ftp.unicode.org/MAPPINGS/
.Ip "\-" 4
Registrated Internet character sets ftp://dkuug.dk/i18n/charmaps/
.Ip "\-" 4
2do: more references
.SH "AUTHOR"
.IX Header "AUTHOR"
Martin Schwartz <\fImartin@nacho.de\fR>
