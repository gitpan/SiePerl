.\" Automatically generated by Pod::Man version 1.15
.\" Mon Apr 23 12:24:12 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "NameParse 3"
.TH NameParse 3 "perl v5.6.1" "2001-02-23" "User Contributed Perl Documentation"
.UC
.SH "NAME"
Lingua::EN::NameParse \- routines for manipulating a persons name
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use Lingua::EN::NameParse qw(clean case_surname);
.Ve
.Vb 11
\&   # optional configuration arguments
\&   my %args = 
\&   (
\&      salutation     => 'Dear',
\&      sal_default    => 'Friend',
\&      auto_clean     => 1,
\&      force_case     => 1,
\&      lc_prefix      => 1,
\&      initials       => 3,   
\&      allow_reversed => 1   
\&   );
.Ve
.Vb 1
\&   my $name = new Lingua::EN::NameParse(%args);
.Ve
.Vb 1
\&   $error = $name->parse("MR AC DE SILVA");
.Ve
.Vb 2
\&   %name_comps = $name->components;
\&   $surname = $name_comps{surname_1}; # DE SILVA
.Ve
.Vb 1
\&   $correct_casing = $name->case_all; # Mr AC de Silva
.Ve
.Vb 1
\&   $good_name = &clean("Bad Na9me   "); # "Bad Name"
.Ve
.Vb 1
\&   $name->salutation; # Dear Mr de Silva
.Ve
.Vb 3
\&   %my_properties = $name->properties;
\&   $number_surnames = $my_properties{number}; # 1
\&   $bad_input = $my_properties{non_matching};
.Ve
.Vb 2
\&   $lc_prefix = 0;
\&   $correct_case = &case_surname("DE SILVA-MACNAY",$lc_prefix); # De Silva-MacNay
.Ve
.SH "REQUIRES"
.IX Header "REQUIRES"
Perl, version 5.001 or higher and Parse::RecDescent
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module takes as input a person or persons name in 
free format text such as,
.PP
.Vb 3
\&    Mr AB & M/s CD MacNay-Smith
\&    MR J.L. D'ANGELO
\&    Estate Of The Late Lieutenant Colonel AB Van Der Heiden
.Ve
and attempts to parse it. If successful, the name is broken
down into components and useful functions can be performed such as :
.PP
.Vb 4
\&   converting upper or lower case values to name case (Mr AB MacNay   )
\&   creating a personalised greeting or salutation     (Dear Mr MacNay )
\&   extracting the names individual components         (Mr,AB,MacNay   )
\&   determining the type of format the name is in      (Mr_A_Smith     )
.Ve
If the name cannot be parsed you have the option of cleaning the name
of bad characters, or extracting any portion that was parsed and the 
portion that failed.
.PP
This module can be used for analysing and improving the quality of
lists of names.
.SH "DEFINITIONS"
.IX Header "DEFINITIONS"
The following terms are used by NameParse to define the components 
that can make up a name.
.PP
.Vb 6
\&   Precursor   - Estate of (The Late), Right Honourable ...
\&   Title       - Mr, Mrs, Ms., Sir, Dr, Major, Reverend ...
\&   Conjunction - word to separate names or initials, such as "And"
\&   Initials    - 1-3 letters, each with an optional space and/or dot
\&   Surname     - De Silva, Van Der Heiden, MacNay-Smith, O'Reilly ...
\&   Suffix      - Senior, Jnr, III, V ...
.Ve
Refer to the component grammar defined within the code for a complete
list of combinations. 
.PP
\&'Name casing' refers to the correct use of upper and lower case letters 
in peoples names, such as Mr \s-1AB\s0 McNay. 
.PP
To describe the formats supported by NameParse, a short hand representation
of the name is used. The following formats are currently supported :
.PP
.Vb 12
\&   Mr_A_Smith_&_Ms_B_Jones
\&   Mr_&_Ms_A_&_B_Smith
\&   Mr_A_&_Ms_B_Smith
\&   Mr_&_Ms_A_Smith
\&   Mr_A_&_B_Smith
\&   Mr_John_A_Smith
\&   Mr_John_Smith
\&   Mr_A_Smith
\&   John_Adam_Smith
\&   John_A_Smith
\&   John_Smith
\&   A_Smith
.Ve
Precursors are only applied to the Mr_John_A_Smith, Mr_John_Smith,
John_Adam_Smith, Mr_A_Smith, Mr_John_Smith, John_Smith and A_Smith formats.
.PP
Suffixes are only applied to the Mr_John_A_Smith,Mr_John_Smith, 
Mr_A_Smith, John_Adam_Smith, John_A_Smith and John_Smith formats.
.SH "METHODS"
.IX Header "METHODS"
.Sh "new"
.IX Subsection "new"
The \f(CW\*(C`new\*(C'\fR method creates an instance of a name object and sets up
the grammar used to parse names. This must be called before any of the
following methods are invoked. Note that the object only needs to be
created \s-1ONCE\s0, and can be reused with new input data. Calling \f(CW\*(C`new\*(C'\fR 
repeatedly will significantly slow your program down.
.PP
Various setup options may be defined in a hash that is passed as an optional 
argument to the \f(CW\*(C`new\*(C'\fR method. Note that all the arguments are optional. You
need to define the combination of arguments that are appropriate for your
usage.
.PP
.Vb 10
\&   my %args = 
\&   (
\&      salutation     => 'Dear',
\&      sal_default    => 'Friend',
\&      auto_clean     => 1,
\&      force_case     => 1,
\&      lc_prefix      => 1,
\&      initials       => 3,   
\&      allow_reversed => 1   
\&   );
.Ve
.Vb 1
\&   my $name = new Lingua::EN::NameParse(%args);
.Ve
.Ip "salutation"
.IX Item "salutation"
The option defines the salutation word, such as \*(L"Dear\*(R" or \*(L"Greetings\*(R". It
must be defined if you are planning to use the \f(CW\*(C`salutation\*(C'\fR method.
.Ip "sal_default"
.IX Item "sal_default"
This option defines the defaulting word to substitute for the title and
\&\fIsurname\fR\|(s), when parsing fails to identify them. It is also used when a
precursor occurs. Examples are \*(L"Friend\*(R" or \*(L"Member\*(R". It must be defined if 
you are planning to use the \f(CW\*(C`salutation\*(C'\fR method. If an '&' or 'and' occurs
in the unmatched section then it is assumed that we are dealing with more than
one person, and an 's' is appended to the defaulting word.
.Ip "force_case"
.IX Item "force_case"
This option will force the \f(CW\*(C`case_all\*(C'\fR method to name case the entire input
string, including any unmatched sections that failed parsing. For example, in 
\&\*(L"\s-1MR\s0 A \s-1JONES\s0 & \s-1ASSOCIATES\s0\*(R", \*(L"& \s-1ASSOCIATES\s0\*(R" will also be name cased. The casing
rules for unmatched sections are the same as for surnames. This is usually
the best option, although any initials in the unmatched section will not
be correctly cased. This option is useful when you know you data has invalid 
names, but you cannot filter out or reject them.
.Ip "auto_clean"
.IX Item "auto_clean"
When this option is set to a positive value, any call to the \f(CW\*(C`parse\*(C'\fR method 
that fails will attempt to 'clean' the name and then reparse it. See the 
\&\f(CW\*(C`clean\*(C'\fR method for details. This is useful for dirty data with embedded 
unprintable or non alphabetic characters. 
.Ip "lc_prefix"
.IX Item "lc_prefix"
When this option is set to a positive value, it will force the \f(CW\*(C`case_all\*(C'\fR 
and \f(CW\*(C`case_component\*(C'\fR methods to lower case the first letter of each word that
occurs in the prefix portion of a surname. For example, Mr \s-1AB\s0 de Silva,
or Ms \s-1AS\s0 von der Heiden.
.Ip "initials"
.IX Item "initials"
Allows the user to control the number of letters that can occur in the initials.
Valid settings are 1,2 or 3. If no value is supplied a default of 2 is used.  
.Ip "allow_reversed"
.IX Item "allow_reversed"
When this option is set to a positive value, names in reverse order will be
processed. The only valid format is the surname followed by a comma and the
rest of the name, which can be in any of the combinations allowed by non
reversed names. Some examples are:
.PP
Smith, Mr \s-1AB\s0
Jones, Jim
De Silva, Professor A.B. 
.PP
The program change the order of the name back to the non reversed format, and 
then performs the normal parsing. Note that if the name can be parsed, the fact
that it's order was originally reversed, is not recorded as a property of the
name object.
.Sh "parse"
.IX Subsection "parse"
.Vb 1
\&    $error = $name->parse("MR AC DE SILVA");
.Ve
The \f(CW\*(C`parse\*(C'\fR method takes a single parameter of a text string containing a 
name. It attempts to parse the name and break it down into the components 
described above. If the name was parsed successfully, a 0 is returned, 
otherwise a 1. This step is a prerequisite for the following functions.
.Sh "case_all"
.IX Subsection "case_all"
.Vb 1
\&    $correct_casing = $name->case_all;
.Ve
The \f(CW\*(C`case_all\*(C'\fR method converts the first letter of each component to
capitals and the remainder to lower case, with the following exceptions-
.PP
.Vb 3
\&   initials remain capitalised
\&   surname spelling such as MacNay-Smith, O'Brien and Van Der Heiden are preserved
\&   - see C<surname_prefs.txt> for user defined exceptions
.Ve
A complete definition of the capitalising rules can be found by studying
the component grammar defined within the code.
.PP
The method returns the entire cased name as text.
.Sh "case_components"
.IX Subsection "case_components"
.Vb 2
\&   %my_name = $name->components;
\&   $cased_surname = $my_name{surname_1};
.Ve
The \f(CW\*(C`case_components\*(C'\fR method does the same thing as the \f(CW\*(C`case_all\*(C'\fR method,
but returns the name cased components in a hash. The following keys are used
for each component-
.PP
.Vb 12
\&   precursor
\&   title_1
\&   title_2
\&   given_name_1
\&   initials_1
\&   initials_2
\&   middle_name
\&   conjunction_1
\&   conjunction_2
\&   surname_1
\&   surname_2
\&   suffix
.Ve
Entries only occur in the hash for each component that the currently parsed
name contains, meaning there are no keys with undefined values.
.Sh "components"
.IX Subsection "components"
.Vb 2
\&   %name = $name->components;
\&   $surname = $my_name{surname_1};
.Ve
The \f(CW\*(C`components\*(C'\fR method does the same thing as the \f(CW\*(C`case_components\*(C'\fR method,
but each component is returned as it appears in the input string, with no case
conversion.
.Sh "case_surname"
.IX Subsection "case_surname"
.Vb 1
\&   $correct_casing = &case_surname("DE SILVA-MACNAY" [,$lc_prefix]);
.Ve
\&\f(CW\*(C`case_surname\*(C'\fR is a stand alone function that does not require a name
object. The input is a text string and the output is a string converted to
the correct casing for surnames. An optional argument controls the casing
rules for prefix portions of a surname, as described above in the \f(CW\*(C`lc_prefix\*(C'\fR
section.
.PP
See \f(CW\*(C`surname_prefs.txt\*(C'\fR for user defined exceptions
.PP
This function is useful when you know you are only dealing with names that
do not have initials like \*(L"Mr John Jones\*(R". It is much faster than the case_all 
method, but does not understand context, and cannot detect errors on strings
that are not personal names.
.Sh "surname_prefs.txt"
.IX Subsection "surname_prefs.txt"
Some surnames can have more than one form of valid capitalisation, such as
MacQuarie or Macquarie. Where the user wants to specify one form as the default,
a text file called surname_prefs.txt should be created and placed in the same
location as the NameParse module. The text file should contain one surname per 
line, in the capitalised form you want, such as
.PP
.Vb 2
\&   Macquarie
\&   MacHado
.Ve
NameParse will still operate if the file does not exist
.Sh "salutation"
.IX Subsection "salutation"
The \f(CW\*(C`salutation\*(C'\fR method converts a name into a personal greeting,
such as \*(L"Dear Mr & Mrs O'Brien\*(R". 
.PP
If an error is detected during parsing, such as with the name
\&\*(L"\s-1AB\s0 Smith & Associates\*(R", the title (if it occurs) and the \fIsurname\fR\|(s) are
replaced with a default word like \*(L"Friend\*(R" or \*(L"Member\*(R". If the input string
contains a conjunction, an 's' is added to the default.
.PP
If the name contains a precursor, a default salutation is also produced.
.Sh "clean"
.IX Subsection "clean"
.Vb 1
\&   $good_name = &clean("Bad Na9me");
.Ve
\&\f(CW\*(C`clean\*(C'\fR is a stand alone function that does not require a name object. 
The input is a text string and the output is the string with:
.PP
.Vb 2
\&   all repeating spaces removed
\&   all characters not in the set (A-Z a-z - ' , . &) removed
.Ve
.Sh "properties"
.IX Subsection "properties"
The \f(CW\*(C`properties\*(C'\fR method returns all the properties of the name,
non_matching, number and type, as a hash.
.Ip "type"
.IX Item "type"
The type of format a name is in, as one of the following strings: 
.PP
.Vb 13
\&   Mr_A_Smith_&_Ms_B_Jones
\&   Mr_&_Ms_A_&_B_Smith
\&   Mr_A_&_Ms_B_Smith
\&   Mr_&_Ms_A_Smith
\&   Mr_A_&_B_Smith
\&   Mr_John_A_Smith
\&   Mr_John_Smith
\&   Mr_A_Smith
\&   John_Adam_Smith
\&   John_A_Smith
\&   John_Smith
\&   A_Smith
\&   unknown
.Ve
.Ip "non_matching"
.IX Item "non_matching"
Returns any unmatched section that was found.
.SH "LIMITATIONS"
.IX Header "LIMITATIONS"
The huge number of character combinations that can form a valid names makes
it is impossible to correctly identify them all. Firstly, there are many 
ambiguities, which have no right answer.
.PP
.Vb 3
\&   Macbeth or MacBeth, are both valid spellings
\&   Is ED WOOD E.D. Wood or Edward Wood
\&   Is 'Mr Rapid Print' a name or a company
.Ve
One approach is to have large lookup files of names and words, statistical rules
and fuzzy logic to attempt to derive context. This approach gives high levels of 
accuracy but uses a lot of your computers time and resources.
.PP
NameParse takes the approach of using a limited set of rules, based on the
formats that are commonly used by business to represent peoples names. This
gives us fairly high accuracy, with acceptable speed and program size.
.PP
NameParse will accept names from many countries, like Van Der Heiden,
De La Mare and Le Fontain. Having said that, it is still biased toward English,
because the precursors, titles and conjunctions are based on English usage. 
.PP
Names with two or more words, but no separating hyphen are not recognized.
This is a real quandary as Indian, Chinese and other names can have several 
components. If these are allowed for, any component after the surname
will also be picked up. For example in \*(L"Mr \s-1AB\s0 Jones Trading As Jones Pty Ltd\*(R" 
will return a surname of \*(L"Jones Trading\*(R".
.PP
Because of the large combination of possible names defined in the grammar, the
program is not very fast, except for the more limited \f(CW\*(C`case_surname\*(C'\fR subroutine.
See the \*(L"Future Directions\*(R" section for possible speed ups.
.SH "REFERENCES"
.IX Header "REFERENCES"
\&\*(L"The Wordsworth Dictionary of Abbreviations & Acronyms\*(R" (1997)
.PP
Australian Standard \s-1AS4212\-1994\s0 \*(L"Geographic Information Systems \- 
Data Dictionary for transfer of street addressing information\*(R"
.SH "FUTURE DIRECTIONS"
.IX Header "FUTURE DIRECTIONS"
.Vb 4
\&   Add filtering of very long names
\&   Add diagnostic messages explaining why parsing failed
\&   Add transforming methods to do things like remove dots from initials
\&   Try to derive gender (Mr... is male, Ms, Mrs... is female)
.Ve
Let the user select what level of complexity of grammar they need for
their data. For example, if you know most of your names are in a \*(L"John Smith\*(R"
format, you can avoid the ambiguity between two letter given names and 
initials. Using a limited grammar subset will also be much faster.
.PP
Define grammar for other languages. Hopefully, all that would be needed is
to specify a new module with its own grammar, and inherit all the existing
methods. I don't have the knowledge of the naming conventions for non-english 
languages.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Lingua::EN::AddressParse
Lingua::EN::MatchNames
Lingua::EN::NickNames
Lingua::EN::NameCase
Parse::RecDescent
.SH "TO DO"
.IX Header "TO DO"
Add regression tests for all combinations of each component
.SH "BUGS"
.IX Header "BUGS"
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1999\-2001 Kim Ryan. All rights reserved.
This program is free software; you can redistribute it 
and/or modify it under the terms of the Perl Artistic License
(see http://www.perl.com/perl/misc/Artistic.html).
.SH "AUTHOR"
.IX Header "AUTHOR"
NameParse was written by Kim Ryan <kimaryan@ozemail.com.au> in 1999.
Thanks to all the people who provided ideas and suggestions, including \-
.PP
.Vb 5
\&   QM Industries <http://www.qmi.com.au>
\&   Damian Conway <damian@cs.monash.edu.au> author of Parse::RecDescent
\&   <mark.summerfield@chest.ac.uk>, author of Lingua::EN::NameCase, 
\&   Ron Savage <rpsavage@ozemail.com.au>
\&   <alastair@calliope.demon.co.uk>, Adam Huffman, Douglas Wilson
.Ve
