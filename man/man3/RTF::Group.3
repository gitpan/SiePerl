.\" Automatically generated by Pod::Man version 1.15
.\" Mon Apr 23 13:13:13 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "Group 3"
.TH Group 3 "perl v5.6.1" "2001-02-17" "User Contributed Perl Documentation"
.UC
.SH "NAME"
\&\s-1RTF:\s0:Group \- Base class for manipulating Rich Text Format (\s-1RTF\s0) groups
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a base class for manipulating \s-1RTF\s0 groups.  Groups are stored internally
as lists. Lists may contain (sub)groups or atoms (raw text or control words).
.PP
Unlike the behavior of groups in the original \f(CW\*(C`RTF::Document module\*(C'\fR (versions 0.63 and earlier), references to arrays (lists) are \fInot\fR treated as subgroups, but are dereferenced when expanded (as lists or strings).
.PP
This allows more flexibility for changing control codes within a group, without
having to know their exact location, or to use kluges like \fIsplice\fR on the
arrays.
.PP
I am in the process of writing a \f(CW\*(C`RTF::Generator\*(C'\fR module which will supercede
\&\f(CW\*(C`RTF::Document\*(C'\fR.
.SH "METHODS"
.IX Header "METHODS"
.Sh "new"
.IX Subsection "new"
.Vb 1
\&    $group = new RTF::Group LIST, PROPERTIES;
.Ve
Creates a new group. If \s-1LIST\s0 is specified, it is appended to the group.
\&\s-1PROPERTIES\s0 are optional, and are used to set properties for the object.
.PP
By default, the \f(CW\*(C`subgroup\*(C'\fR property is set.  This means that if the
group is appended to another group, it will be emitted (using the \f(CW\*(C`_rtf_list\*(C'\fR
and \f(CW\*(C`as_string\*(C'\fR methods) as a group within a group:
.PP
.Vb 4
\&    $g1 = new RTF::Group(g1);
\&    $g2 = new RTF::Group(g2);
\&    $g1->append($g2);
\&    print $g1->as_string;       # emits '{g1{g2}}'
.Ve
If we disable the \f(CW\*(C`subgroup\*(C'\fR property, we get the following:
.PP
.Vb 4
\&    $g1 = new RTF::Group(g1);
\&    $g2 = new RTF::Group(g2, {subgroup=>0});
\&    $g1->append($g2);
\&    print $g1->as_string;       # emits '{g1 g2}'
.Ve
The \f(CW\*(C`escape\*(C'\fR property enables automatic escaping of unescaped
curly brackets when a group is emitted as a string. (This property
is also enabled by default.)
.PP
The \f(CW\*(C`wrap\*(C'\fR property is not used in this version.
.PP
Each property is also a method for getting or setting it's value. For
example,
.PP
.Vb 4
\&    unless ($g2->subgroup)
\&    {
\&        $g2->subgroup(1);
\&    }
.Ve
See the \f(CW\*(C`append\*(C'\fR method for more details on how groups are handled.
.Sh "append"
.IX Subsection "append"
.Vb 1
\&    $group->append LIST;
.Ve
Appends \s-1LIST\s0 to the group. \s-1LIST\s0 may be plain text, controls, other groups, or
references to a \s-1SCALAR\s0 or another \s-1LIST\s0.
.PP
If \s-1LIST\s0 contains another \s-1RTF:\s0:Group, it will be embedded as a subgroup
(how this is handled is explained in the the documentation for the \f(CW\*(C`new\*(C'\fR
method).
.PP
If \s-1LIST\s0 contains a reference to a \s-1SCALAR\s0, the value it points to will be
emitted when the \f(CW\*(C`_rtf_list()\*(C'\fR or \f(CW\*(C`_string\*(C'\fR methods are called.
.PP
If \s-1LIST\s0 contains a reference to \s-1CODE\s0, the value that code returns will
be emitted as if it were returned by \f(CW\*(C`_rtf_list()\*(C'\fR. For instance,
.PP
.Vb 5
\&    sub generator
\&    {
\&        my $arg = shift;
\&        return uc($arg);
\&    }
.Ve
.Vb 2
\&    $g1 = new RTF::Group(g1);
\&    $g1->append( \e&generator, 'g2' );
.Ve
.Vb 1
\&    print $g1->as_string();            # emits '{g1 G2}'
.Ve
Note that \f(CW\*(C`\e&generator\*(C'\fR must have one and only one argument, which is following item on the list. The argument is \fInot\fR processed by \f(CW\*(C`RTF::Group\*(C'\fR. (Versions of this module prior to 1.00 specified an array reference as the argument. This is not necessarily the case now.)
.Sh "as_string"
.IX Subsection "as_string"
.Vb 1
\&    print $group->as_string();
.Ve
Returns the group as a string that would appear in an \s-1RTF\s0 document. (The deprecated \f(CW\*(C`string\*(C'\fR method is an alias for \f(CW\*(C`as_string\*(C'\fR.)
.Sh "is_empty"
.IX Subsection "is_empty"
.Vb 1
\&    if ($group->is_empty) { ... }
.Ve
Returns true if the group is empty, false if it contains something. Zero-length
strings are considered nothing.
.Sh "_rtf_list"
.IX Subsection "_rtf_list"
.Vb 1
\&    @RTF = $group->_rtf_list LIST;
.Ve
\&\*(L"Parses\*(R" \s-1LIST\s0 by dereferencing scalars, arrays or subgroups. If \s-1LIST\s0 is
not specified, parses group. (Although this may useful for parsers, it is
intended for internal use \fI(read: private method)\fR.)
.Sh "_list_as_string"
.IX Subsection "_list_as_string"
.Vb 1
\&    $output = $group->_list_as_string( LIST )
.Ve
Converts the output of the \f(CW\*(C`_rtf_list()\*(C'\fR method into a string. This is a
private method and may go away in future versions: use the \f(CW\*(C`as_string\*(C'\fR
method instead.
.Sh "_escape"
.IX Subsection "_escape"
.Vb 1
\&    $atom = RTF::Group::_escape( SCALAR );
.Ve
Does simple \s-1RTF\s0 escaping of brackets and 8\-bit characters. It is also a private method.
.SH "CAVEATS"
.IX Header "CAVEATS"
.Sh "Incompatabilities with Previous Versions"
.IX Subsection "Incompatabilities with Previous Versions"
This version is a rewrite. Some embarassingly wrongheaded code was changed.
.PP
Earlier versions of \f(CW\*(C`RTF::Group\*(C'\fR specified that code references required an
array reference to follow as an argument. That is now not the case: while one
and only one argument is still required, it can be anything: a scalar, a scalar
reference, a hash reference, an array reference, etc.
.Sh "Circular References"
.IX Subsection "Circular References"
\&\f(CW\*(C`RTF::Group\*(C'\fR cannot handle circular references. This version does not even check for them. Which means that
.PP
.Vb 2
\&    $g1 = new RTF::Group();
\&    $g2 = new RTF::Group();
.Ve
.Vb 2
\&    $g1->append($g2);
\&    $g2->append($g1);
.Ve
will cause \fIbad things to happen\fR. Do not do this.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Microsoft Technical Support and Application Note, \*(L"Rich Text Format (\s-1RTF\s0)
Specification and Sample Reader Program\*(R", Version 1.5.
.SH "FUTURE ENHANCEMENTS"
.IX Header "FUTURE ENHANCEMENTS"
\&\fIPossibly\fR the ability to parse a stream into an \f(CW\*(C`RTF::Group\*(C'\fR and some hooks to plug in a parser (so that the \f(CW\*(C`RTF::Parser\*(C'\fR module will work nicely with this).
.SH "AUTHOR"
.IX Header "AUTHOR"
Robert Rothenberg <rrwo@cpan.org>
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (c) 1999\-2001 Robert Rothenberg. All rights reserved.
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
