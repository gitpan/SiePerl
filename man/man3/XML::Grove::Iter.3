.\" Automatically generated by Pod::Man version 1.15
.\" Mon Apr 23 13:53:50 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "XML::Grove::Iter 3"
.TH XML::Grove::Iter 3 "perl v5.6.1" "1998-09-25" "User Contributed Perl Documentation"
.UC
.SH "NAME"
\&\s-1XML:\s0:Grove::Iter \- add tree iteration methods to \s-1XML\s0 objects
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use XML::Grove::Iter;
.Ve
.Vb 1
\& $iter = $xml_object->iter;
.Ve
.Vb 3
\& $iter2 = $iter->parent;
\& $iter2 = $iter->next;
\& $iter2 = $iter->previous;
.Ve
.Vb 4
\& $iter2 = $element_iter->first_child;
\& $iter2 = $element_iter->last_child;
\& $iter2 = $element_iter->attr_first ($attr);
\& $iter2 = $element_iter->attr_last ($attr);
.Ve
.Vb 3
\& $obj = $iter->delegate;
\& $root = $iter->root;
\& @path = $iter->rootpath;
.Ve
.Vb 4
\& $bool = $iter->is_iter;
\& $bool = $iter->is_same ($obj);
\& $bool = $iter->at_last;
\& $bool = $iter->at_first;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1XML:\s0:Grove::Iter is a proxy-based tree iterator.  ``Proxy based''
means that the iterator ``stands in'' for the real object and is used
as you would normally use the real object.  The iterator handles
moving around the tree and forwards all other methods to the real
object.
.PP
`\f(CW\*(C`parent\*(C'\fR' returns the parent iterator of this iterator, or
`\f(CW\*(C`undef\*(C'\fR' if this is the root iterator.  `\f(CW\*(C`next\*(C'\fR' and `\f(CW\*(C`previous\*(C'\fR'
return the iterator of the next object or the previous object,
respectively, in the parent's content (the sibling objects), or
`\f(CW\*(C`undef\*(C'\fR' if there is no next or previous sibling.
.PP
`\f(CW\*(C`first_child\*(C'\fR' and `\f(CW\*(C`last_child\*(C'\fR' return the iterator of the first
child or the last child of the contents of this element or document.
`\f(CW\*(C`attr_first\*(C'\fR' and `\f(CW\*(C`attr_last\*(C'\fR' return the iterator of the first
child or last child of the named attribute.  These all return
`\f(CW\*(C`undef\*(C'\fR' if the contents are empty.
.PP
`\f(CW\*(C`delegate\*(C'\fR' returns the object that this iterator stands-in for,
``the delegate''.
.PP
`\f(CW\*(C`root\*(C'\fR' returns the iterator of the top-most object of the sub-tree
being iterated.  Note that this may not be the root of the document
tree if the first iterator was created using a nested object.
.PP
`\f(CW\*(C`rootpath\*(C'\fR' returns a list of the parent iterators between and
including the root and this iterator.
.PP
`\f(CW\*(C`is_iter\*(C'\fR' returns true if this object is an iterator.  Ordinary \s-1XML\s0
objects have been extended with an `\f(CW\*(C`is_iter\*(C'\fR' method that returns
false.
.PP
`\f(CW\*(C`is_same\*(C'\fR' returns true if `\f(CW\*(C`$obj\*(C'\fR' is this iterator's delegate, or
if `\f(CW\*(C`$obj\*(C'\fR' is an iterator that points to the same delegate.
.PP
`\f(CW\*(C`at_last\*(C'\fR' and `\f(CW\*(C`at_first\*(C'\fR' return true if calling `\f(CW\*(C`next\*(C'\fR' or
`\f(CW\*(C`previous\*(C'\fR', respectively, would return `\f(CW\*(C`undef\*(C'\fR'.  Or in other
words, they return true if this iterator is at the end or the
beginning of the parent element's content.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ken MacLeod, ken@bitsko.slc.ut.us
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1), \s-1XML:\\fIs0:Parser\fR\|(3), \s-1XML:\\fIs0:Parser::Grove\fR\|(3).
.PP
Extensible Markup Language (\s-1XML\s0) <http://www.w3c.org/XML>
