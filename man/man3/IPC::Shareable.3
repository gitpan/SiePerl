.\" Automatically generated by Pod::Man version 1.15
.\" Mon Apr 23 12:08:59 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "IPC::Shareable 3"
.TH IPC::Shareable 3 "perl v5.6.1" "2001-03-05" "User Contributed Perl Documentation"
.UC
.SH "NAME"
\&\s-1IPC:\s0:Shareable \- share Perl variables between processes
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\& use IPC::Shareable (':lock');
\& tie SCALAR, 'IPC::Shareable', GLUE, OPTIONS;
\& tie ARRAY,  'IPC::Shareable', GLUE, OPTIONS;
\& tie HASH,   'IPC::Shareable', GLUE, OPTIONS;
.Ve
.Vb 2
\& (tied VARIABLE)->shlock;
\& (tied VARIABLE)->shunlock;
.Ve
.Vb 2
\& (tied VARIABLE)->shlock(LOCK_SH|LOCK_NB) 
\&        or print "resource unavailable\en";
.Ve
.Vb 1
\& (tied VARIABLE)->remove;
.Ve
.Vb 2
\& IPC::Shareable->clean_up;
\& IPC::Shareable->clean_up_all;
.Ve
.SH "CONVENTIONS"
.IX Header "CONVENTIONS"
The occurrence of a number in square brackets, as in [N], in the text
of this document refers to a numbered note in the the NOTES entry elsewhere in this document.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1IPC:\s0:Shareable allows you to tie a variable to shared memory making it
easy to share the contents of that variable with other Perl processes.
Scalars, arrays, and hashes can be tied.  The variable being tied may
contain arbitrarily complex data structures \- including references to
arrays, hashes of hashes, etc.
.PP
The association between variables in distinct processes is provided by
\&\s-1GLUE\s0.  This is an integer number or 4 character string[1] that serves
as a common identifier for data across process space.  Hence the
statement
.PP
.Vb 1
\& tie $scalar, 'IPC::Shareable', 'data';
.Ve
in program one and the statement
.PP
.Vb 1
\& tie $variable, 'IPC::Shareable', 'data';
.Ve
in program two will bind \f(CW$scalar\fR in program one and \f(CW$variable\fR in
program two.
.PP
There is no pre-set limit to the number of processes that can bind to
data; nor is there a pre-set limit to the complexity of the underlying
data of the tied variables[2].  The amount of data that can be shared
within a single bound variable is limited by the system's maximum size
for a shared memory segment (the exact value is system-dependent).
.PP
The bound data structures are all linearized (using Raphael Manfredi's
Storable module) before being slurped into shared memory.  Upon
retrieval, the original format of the data structure is recovered.
Semaphore flags can be used for locking data between competing processes.
.SH "OPTIONS"
.IX Header "OPTIONS"
Options are specified by passing a reference to a hash as the fourth
argument to the \fItie()\fR function that enchants a variable.
Alternatively you can pass a reference to a hash as the third
argument; \s-1IPC:\s0:Shareable will then look at the field named \fBkey\fR in
this hash for the value of \s-1GLUE\s0.  So,
.PP
.Vb 1
\& tie $variable, 'IPC::Shareable', 'data', \e%options;
.Ve
is equivalent to
.PP
.Vb 1
\& tie $variable, 'IPC::Shareable', { key => 'data', ... };
.Ve
Boolean option values can be specified using a value that evaluates to
either true or false in the Perl sense.
.PP
\&\s-1NOTE:\s0 Earlier versions allowed you to use the word \fByes\fR for true and
the word \fBno\fR for false, but support for this \*(L"feature\*(R" is being
removed.  \fByes\fR will still act as true (since it is true, in the Perl
sense), but use of the word \fBno\fR now emits an (optional) warning and
then converts to a false value.  This warning will become mandatory in a
future release and then at some later date the use of \fBno\fR will
stop working altogether.
.PP
The following fields are recognized in the options hash.
.Ip "\fBkey\fR" 4
.IX Item "key"
The \fBkey\fR field is used to determine the \s-1GLUE\s0 when using the
three-argument form of the call to \fItie()\fR.  This argument is then, in
turn, used as the \s-1KEY\s0 argument in subsequent calls to \fIshmget()\fR and
\&\fIsemget()\fR.
.Sp
The default value is \s-1IPC_PRIVATE\s0, meaning that your variables cannot
be shared with other processes.
.Ip "\fBcreate\fR" 4
.IX Item "create"
\&\fBcreate\fR is used to control whether calls to \fItie()\fR create new shared
memory segments or not.  If \fBcreate\fR is set to a true value,
\&\s-1IPC:\s0:Shareable will create a new binding associated with \s-1GLUE\s0 as
needed.  If \fBcreate\fR is false, \s-1IPC:\s0:Shareable will not attempt to
create a new shared memory segment associated with \s-1GLUE\s0.  In this
case, a shared memory segment associated with \s-1GLUE\s0 must already exist
or the call to \fItie()\fR will fail and return undef.  The default is
false.
.Ip "\fBexclusive\fR" 4
.IX Item "exclusive"
If \fBexclusive\fR field is set to a true value, calls to \fItie()\fR will fail
(returning undef) if a data binding associated with \s-1GLUE\s0 already
exists.  If set to a false value, calls to \fItie()\fR will succeed even if
a shared memory segment associated with \s-1GLUE\s0 already exists.  The
default is false
.Ip "\fBmode\fR" 4
.IX Item "mode"
The \fImode\fR argument is an octal number specifying the access
permissions when a new data binding is being created.  These access
permission are the same as file access permissions in that 0666 is
world readable, 0600 is readable only by the effective \s-1UID\s0 of the
process creating the shared variable, etc.  The default is 0666 (world
readable and writable).
.Ip "\fBdestroy\fR" 4
.IX Item "destroy"
If set to a true value, the shared memory segment underlying the data
binding will be removed when the process calling \fItie()\fR exits
(gracefully)[3].  Use this option with care.  In particular
you should not use this option in a program that will fork
after binding the data.  On the other hand, shared memory is
a finite resource and should be released if it is not needed.
The default is false 
.Ip "\fBsize\fR" 4
.IX Item "size"
This field may be used to specify the size of the shared memory
segment allocated.  The default is \s-1IPC:\\fIs0:Shareable::SHM_BUFSIZ()\fR.
.PP
Default values for options are
.PP
.Vb 6
\& key       => IPC_PRIVATE,
\& create    => 0,
\& exclusive => 0,
\& destroy   => 0,
\& mode      => 0,
\& size      => IPC::Shareable::SHM_BUFSIZ(),
.Ve
.SH "LOCKING"
.IX Header "LOCKING"
\&\s-1IPC:\s0:Shareable provides methods to implement application-level
advisory locking of the shared data structures.  These methods are
called \fIshlock()\fR and \fIshunlock()\fR.  To use them you must first get the
object underlying the tied variable, either by saving the return
value of the original call to \fItie()\fR or by using the built-in \fItied()\fR
function.
.PP
To lock a variable, do this:
.PP
.Vb 3
\& $knot = tie $sv, 'IPC::Shareable', $glue, { %options };
\& ...
\& $knot->shlock;
.Ve
or equivalently
.PP
.Vb 2
\& tie($scalar, 'IPC::Shareable', $glue, { %options });
\& (tied $scalar)->shlock;
.Ve
This will place an exclusive lock on the data of \f(CW$scalar\fR.  You can
also get shared locks or attempt to get a lock without blocking.
\&\s-1IPC:\s0:Shareable makes the constants \s-1LOCK_EX\s0, \s-1LOCK_SH\s0, \s-1LOCK_UN\s0, and
\&\s-1LOCK_NB\s0 exportable to your address space with the export tags
\&\f(CW\*(C`:lock\*(C'\fR, \f(CW\*(C`:flock\*(C'\fR, or \f(CW\*(C`:all\*(C'\fR.  The values should be the same as
the standard \f(CW\*(C`flock\*(C'\fR option arguments.
.PP
.Vb 6
\& if ( (tied $scalar)->shlock(LOCK_SH|LOCK_NB) ) {
\&        print "The value is $scalar\en";
\&        (tied $scalar)->shunlock;
\& } else {
\&        print "Another process has an exlusive lock.\en";
\& }
.Ve
If no argument is provided to \f(CW\*(C`shlock\*(C'\fR, it defaults to \s-1LOCK_EX\s0.  To
unlock a variable do this:
.PP
.Vb 1
\& $knot->shunlock;
.Ve
or
.PP
.Vb 1
\& (tied $scalar)->shunlock;
.Ve
or
.PP
.Vb 1
\& $knot->shlock(LOCK_UN);        # Same as calling shunlock
.Ve
There are some pitfalls regarding locking and signals about which you
should make yourself aware; these are discussed in the NOTES entry elsewhere in this document.
.PP
If you use the advisory locking, \s-1IPC:\s0:Shareable assumes that you know
what you are doing and attempts some optimizations.  When you obtain
a lock, either exclusive or shared, a fetch and thaw of the data is
performed.  No additional fetch/thaw operations are performed until
you release the lock and access the bound variable again.  During the
time that the lock is kept, all accesses are perfomed on the copy in
program memory.  If other processes do not honor the lock, and update
the shared memory region unfairly, the process with the lock will not be in
sync.  In other words, \s-1IPC:\s0:Shareable does not enforce the lock
for you.  
.PP
A similar optimization is done if you obtain an exclusive lock.
Updates to the shared memory region will be postponed until you
release the lock (or downgrade to a shared lock).
.PP
Use of locking can significantly improve performance for operations
such as iterating over an array, retrieving a list from a slice or 
doing a slice assignment.
.SH "REFERENCES"
.IX Header "REFERENCES"
When a reference to a non-tied scalar, hash, or array is assigned to a
\&\fItie()\fRd variable, \s-1IPC:\s0:Shareable will attempt to \fItie()\fR the thingy being
referenced[4].  This allows disparate processes to see changes to not
only the top-level variable, but also changes to nested data.  This
feature is intended to be transparent to the application, but there
are some caveats to be aware of.
.PP
First of all, \s-1IPC:\s0:Shareable does not (yet) guarantee that the ids
shared memory segments allocated automagically are unique.  The more
automagical \fItie()\fRing that happens, the greater the chance of a
collision.
.PP
Secondly, since a new shared memory segment is created for each thingy
being referenced, the liberal use of references could cause the system
to approach its limit for the total number of shared memory segments
allowed.
.SH "OBJECTS"
.IX Header "OBJECTS"
\&\s-1IPC:\s0:Shareable implements \fItie()\fRing objects to shared memory too.
Since an object is just a reference, the same principles (and caveats)
apply to \fItie()\fRing objects as other reference types.
.SH "DESTRUCTION"
.IX Header "DESTRUCTION"
\&\fIperl\fR\|(1) will destroy the object underlying a tied variable when then
tied variable goes out of scope.  Unfortunately for \s-1IPC:\s0:Shareable,
this may not be desirable: other processes may still need a handle on
the relevant shared memory segment.  \s-1IPC:\s0:Shareable therefore provides
an interface to allow the application to control the timing of removal
of shared memory segments.  The interface consists of three methods \-
\&\fIremove()\fR, \fIclean_up()\fR, and \fIclean_up_all()\fR \- and the \fBdestroy\fR option
to \fItie()\fR.
.Ip "\fBdestroy option\fR" 4
.IX Item "destroy option"
As described in the OPTIONS entry elsewhere in this document, specifying the \fBdestroy\fR option when
\&\fItie()\fRing a variable coerces \s-1IPC:\s0:Shareable to remove the underlying
shared memory segment when the process calling \fItie()\fR exits gracefully.
Note that any related shared memory segments created automagically by
the use of references will also be removed.
.Ip "\fB\f(BIremove()\fB\fR" 4
.IX Item "remove()"
.Vb 1
\& (tied $var)->remove;
.Ve
Calling \fIremove()\fR on the object underlying a \fItie()\fRd variable removes
the associated shared memory segment.  The segment is removed
irrespective of whether it has the \fBdestroy\fR option set or not and
irrespective of whether the calling process created the segment.
.Ip "\fB\f(BIclean_up()\fB\fR" 4
.IX Item "clean_up()"
.Vb 1
\& IPC::Shareable->clean_up;
.Ve
This is a class method that provokes \s-1IPC:\s0:Shareable to remove all
shared memory segments created by the process.  Segments not created
by the calling process are not removed.
.Ip "\fB\f(BIclean_up_all()\fB\fR" 4
.IX Item "clean_up_all()"
.Vb 1
\& IPC::Shareable->clean_up_all;
.Ve
This is a class method that provokes \s-1IPC:\s0:Shareable to remove all
shared memory segments encountered by the process.  Segments are
removed even if they were not created by the calling process.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
In a file called \fBserver\fR:
.PP
.Vb 31
\& #!/usr/bin/perl -w
\& use strict;
\& use IPC::Shareable;
\& my $glue = 'data';
\& my %options = (
\&     create    => 'yes',
\&     exclusive => 0,
\&     mode      => 0644,
\&     destroy   => 'yes',
\& );
\& my %colours;
\& tie %colours, 'IPC::Shareable', $glue, { %options } or
\&     die "server: tie failed\en";
\& %colours = (
\&     red => [
\&         'fire truck',
\&         'leaves in the fall',
\&     ],
\&     blue => [
\&         'sky',
\&         'police cars',
\&     ],
\& );
\& ((print "server: there are 2 colours\en"), sleep 5)
\&     while scalar keys %colours == 2;
\& print "server: here are all my colours:\en";
\& foreach my $c (keys %colours) {
\&     print "server: these are $c: ",
\&         join(', ', @{$colours{$c}}), "\en";
\& }
\& exit;
.Ve
In a file called \fBclient\fR
.PP
.Vb 19
\& #!/usr/bin/perl -w
\& use strict;
\& use IPC::Shareable;
\& my $glue = 'data';
\& my %options = (
\&     create    => 0,
\&     exclusive => 0,
\&     mode      => 0644,
\&     destroy   => 0,
\&     );
\& my %colours;
\& tie %colours, 'IPC::Shareable', $glue, { %options } or
\&     die "client: tie failed\en";
\& foreach my $c (keys %colours) {
\&     print "client: these are $c: ",
\&         join(', ', @{$colours{$c}}), "\en";
\& }
\& delete $colours{'red'};
\& exit;
.Ve
And here is the output (the sleep commands in the command line prevent
the output from being interrupted by shell prompts):
.PP
.Vb 8
\& bash$ ( ./server & ) ; sleep 10 ; ./client ; sleep 10
\& server: there are 2 colours
\& server: there are 2 colours
\& server: there are 2 colours
\& client: these are blue: sky, police cars
\& client: these are red: fire truck, leaves in the fall
\& server: here are all my colours:
\& server: these are blue: sky, police cars
.Ve
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
Calls to \fItie()\fR that try to implement \s-1IPC:\s0:Shareable will return true
if successful, \fIundef\fR otherwise.  The value returned is an instance
of the \s-1IPC:\s0:Shareable class.
.SH "AUTHOR"
.IX Header "AUTHOR"
Benjamin Sugars <bsugars@canoe.ca>
.SH "NOTES"
.IX Header "NOTES"
.Sh "Footnotes from the above sections"
.IX Subsection "Footnotes from the above sections"
.Ip "1" 4
.IX Item "1"
If \s-1GLUE\s0 is longer than 4 characters, only the 4 most significant
characters are used.  These characters are turned into integers by
\&\fIunpack()\fRing them.  If \s-1GLUE\s0 is less than 4 characters, it is space
padded.
.Ip "2" 4
.IX Item "2"
\&\s-1IPC:\s0:Shareable provides no pre-set limits, but the system does.
Namely, there are limits on the number of shared memory segments that
can be allocated and the total amount of memory usable by shared
memory.
.Ip "3" 4
.IX Item "3"
If the process has been smoked by an untrapped signal, the binding
will remain in shared memory.  If you're cautious, you might try
.Sp
.Vb 6
\& $SIG{INT} = \e&catch_int;
\& sub catch_int {
\&     die;
\& }
\& ...
\& tie $variable, IPC::Shareable, 'data', { 'destroy' => 'Yes!' };
.Ve
which will at least clean up after your user hits \s-1CTRL-C\s0 because
\&\s-1IPC:\s0:Shareable's \s-1END\s0 method will be called.  Or, maybe you'd like to
leave the binding in shared memory, so subsequent process can recover
the data...
.Ip "4" 4
.IX Item "4"
This behaviour is markedly different from previous versions of
\&\s-1IPC:\s0:Shareable.  Older versions would sometimes \fItie()\fR referenced
thingies, and sometimes not.  The new approach is more reliable (I
think) and predictable (certainly) but uses more shared memory
segments.
.Sh "General Notes"
.IX Subsection "General Notes"
.Ip "o" 4
When using \fIshlock()\fR to lock a variable, be careful to guard against
signals.  Under normal circumstances, \s-1IPC:\s0:Shareable's \s-1END\s0 method
unlocks any locked variables when the process exits.  However, if an
untrapped signal is received while a process holds an exclusive lock,
\&\s-1DESTROY\s0 will not be called and the lock may be maintained even though
the process has exited.  If this scares you, you might be better off
implementing your own locking methods.  
.Sp
One advantage of using \f(CW\*(C`flock\*(C'\fR on some known file instead of the
locking implemented with semaphores in \s-1IPC:\s0:Shareable is that when a
process dies, it automatically releases any locks.  This only happens
with \s-1IPC:\s0:Shareable if the process dies gracefully.  The alternative
is to attempt to account for every possible calamitous ending for your
process (robust signal handling in Perl is a source of much debate,
though it usually works just fine) or to become familiar with your
system's tools for removing shared memory and semaphores.  This
concern should be balanced against the significant performance
improvements you can gain for larger data structures by using the
locking mechanism implemented in \s-1IPC:\s0:Shareable.
.Ip "o" 4
There is a program called ipcs(1/8) (and ipcrm(1/8)) that is
available on at least Solaris and Linux that might be useful for
cleaning moribund shared memory segments or semaphore sets produced
by bugs in either \s-1IPC:\s0:Shareable or applications using it.
.Ip "o" 4
This version of \s-1IPC:\s0:Shareable does not understand the format of
shared memory segments created by versions prior to 0.60.  If you try
to tie to such segments, you will get an error.  The only work around
is to clear the shared memory segments and start with a fresh set.
.Ip "o" 4
Iterating over a hash causes a special optimization if you have not
obtained a lock (it is better to obtain a read (or write) lock before
iterating over a hash tied to Shareable, but we attempt this
optimization if you do not).  The fetch/thaw operation is performed
when the first key is accessed.  Subsequent key and and value
accesses are done without accessing shared memory.  Doing an
assignment to the hash or fetching another value between key
accesses causes the hash to be replaced from shared memory.  The
state of the iterator in this case is not defined by the Perl
documentation.  Caveat Emptor.
.SH "CREDITS"
.IX Header "CREDITS"
Thanks to all those with comments or bug fixes, especially
.PP
.Vb 12
\& Maurice Aubrey      <maurice@hevanet.com>
\& Stephane Bortzmeyer <bortzmeyer@pasteur.fr>
\& Doug MacEachern     <dougm@telebusiness.co.nz>
\& Robert Emmery       <roberte@netscape.com>
\& Mohammed J. Kabir   <kabir@intevo.com>
\& Terry Ewing         <terry@intevo.com>
\& Tim Fries           <timf@dicecorp.com>
\& Joe Thomas          <jthomas@women.com>
\& Paul Makepeace      <Paul.Makepeace@realprogrammers.com>
\& Raphael Manfredi    <Raphael_Manfredi@pobox.com>
\& Lee Lindley         <Lee.Lindley@bigfoot.com>
\& Dave Rolsky         <autarch@urth.org>
.Ve
.SH "BUGS"
.IX Header "BUGS"
Certainly; this is beta software. When you discover an anomaly, send
an email to me at bsugars@canoe.ca.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1), \fIperltie\fR\|(1), \fIStorable\fR\|(3), \fIshmget\fR\|(2), \fIipcs\fR\|(1), \fIipcrm\fR\|(1)
and other SysV \s-1IPC\s0 man pages.
