.\" Automatically generated by Pod::Man version 1.15
.\" Mon Apr 23 11:57:10 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "Fraction 3"
.TH Fraction 3 "perl v5.6.1" "1998-02-02" "User Contributed Perl Documentation"
.UC
.SH "NAME"
Math::Fraction \- To Manipulate Exact Fractions (v.53b, Beta Release)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Math::Fraction;
.Ve
.Vb 1
\&    $a = frac(1,2); $b = frac(6,7);
.Ve
.Vb 2
\&    print "$a + $b = ", $a + $b, "$a * $b = ", $a * $b;
\&    print $a->num;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This program is meant to replace the old bigrat perl library.  It can do
everything it can do and a lot more.
.PP
Some of its features include:
.Ip "\(bu" 4
Being able to add, subtract, multiply, and divide, among other things
just like you would normal numbers that's to the overload module.
.Ip "\(bu" 4
Being able to convert a decimal, including repeating ones, into a
fraction.  For example, 1.142857142857 would become 8/7.
.Ip "\(bu" 4
Being able to control how the fraction is displayed.  For example
8/7 verses 1 1/7
.Ip "\(bu" 4
Being able to use arbitrary size numbers in the numerator and the
denominator.
.Ip "\(bu" 4
Being able to covert between \s-1SMALL\s0 (using normal floats/integers) and
\&\s-1BIG\s0 (using arbitrary size floats/integers) as needed so you do not have
to worry about it. (New as of ver .4a)
.Ip "\(bu" 4
Being able to have multiple default sets so that a function can modify
the defaults with out effecting other functions (New as of ver .4a)
.Sh "Usage"
.IX Subsection "Usage"
.Vb 2
\& frac(FRACTION, TAGS) || Math::Fraction->new(FRACTION, TAGS)
\& ex $f1=frac(2,3); $f2=frac(7,3,MIXED); $f3=frac("-10 3/4");
.Ve
\&\s-1FRACTION\s0 can equal any of the following:
.Ip "(Numerator, Denominator)" 4
.IX Item "(Numerator, Denominator)"
.PD 0
.Ip "(Number, Numerator, Denominator)" 4
.IX Item "(Number, Numerator, Denominator)"
.Ip "Decimal" 4
.IX Item "Decimal"
.if n .Ip """""Numerator/Denominator""""" 4
.el .Ip "``Numerator/Denominator''" 4
.IX Item ""Numerator/Denominator"
.if n .Ip """""Number Numerator/Denominator""""" 4
.el .Ip "``Number Numerator/Denominator''" 4
.IX Item ""Number Numerator/Denominator"
.PD
.PP
Any of these numbers can be any real number however if you
enter in negative numbers in anything but the First Number for
the Mixed (3 numbers) the negative will be ignored.
.PP
\&\s-1TAGS\s0 can equal 0, one or more of the following
.Ip "NORMAL|MIXED|MIXED_RAW|RAW|DEF_MIXED" 4
.IX Item "NORMAL|MIXED|MIXED_RAW|RAW|DEF_MIXED"
Controls How the fraction is displayed:
.RS 4
.Ip "\s-1NORMAL\s0" 8
.IX Item "NORMAL"
display it in the #/# form
.Ip "\s-1MIXED_RAW\s0" 8
.IX Item "MIXED_RAW"
display it in the # #/# form
.Ip "\s-1MIXED\s0" 8
.IX Item "MIXED"
the same as \s-1MIXED_RAW\s0 but if one part is equal to 0 it will leave it off
.Ip "\s-1RAW\s0" 8
.IX Item "RAW"
the same as \s-1NORAML\s0 but always includes the sign
.Ip "\s-1DEF_MIXED\s0" 8
.IX Item "DEF_MIXED"
will let it be what ever the default value is at the time
.RE
.RS 4
.RE
.Ip "REDUCE|NO_REDUCE|DEF_REDUCE" 4
.IX Item "REDUCE|NO_REDUCE|DEF_REDUCE"
Controls the automatic reduction of fraction after operations are
performed on it.
.Ip "AUTO|NO_AUTO|DEF_AUTO" 4
.IX Item "AUTO|NO_AUTO|DEF_AUTO"
Set rether to automatically convert between \s-1BIG\s0 and \s-1SMALL\s0 as needed
see the Notes on the AUTO tag entry elsewhere in this document.
.Ip "SMALL|BIG|DEF_BIG" 4
.IX Item "SMALL|BIG|DEF_BIG"
When the \s-1AUTO\s0 tag is \s-1NOT\s0 set it will set whether to use Arbitrary-Length
numbers using the Math::BigInt and Math::BigFloat package. (Not the **
operator will not work however due to limitations of the packages.)
When the \s-1AUTO\s0 tag is set these tags will have \s-1NO\s0 effect.
(Note the default tags are \s-1NORMAL\s0 \s-1REDUCE\s0 \s-1AUTO\s0 and \s-1SMALL\s0)
.Sh "Methods"
.IX Subsection "Methods"
.Ip "reduce" 4
.IX Item "reduce"
returns a reduced fraction but leaves the original object untouched.
.Ip "string(NORMAL|MIXED|MIXED_RAW|RAW)" 4
.IX Item "string(NORMAL|MIXED|MIXED_RAW|RAW)"
returns the fraction as a string.
if no parameters are given the objects default display method
will be used.
.Ip "decimal|num" 4
.IX Item "decimal|num"
returned the decimal value of the fraction
.Ip "list|list(\s-1MIXED\s0)" 4
.IX Item "list|list(MIXED)"
returns a list containing the fraction if \s-1MIXED\s0 is
used than a 3 item list is returned.
.Ip "is_tag" 4
.IX Item "is_tag"
returns 1 is that tag exists in the fraction undef if is set to the
default \-1 otherwise
.Ip "is_tag(\s-1INC_DEF\s0)" 4
.IX Item "is_tag(INC_DEF)"
returns 1 is that tag exists in the fraction \-1 if
is tag does not exist but the default is set to that, 0 otherwise.
.Ip "tags" 4
.IX Item "tags"
returns a list of the objects tags
.Ip "tags(\s-1INC_DEF\s0)" 4
.IX Item "tags(INC_DEF)"
returns a list of the objects tags if a particular tag
is set to read a default the default tag is returned instead.
.PP
All of the above methods may all be exported so that they
can be used as functions with a fraction as their first parameter. The
string, decimal|num functions can be imported with the tag \s-1STR_NUM\s0
instead of having to list each one.
.Ip "modify" 4
.IX Item "modify"
modifies the object.  Works almost the same as the new method
but it doesn't return anything and preserves the objects tags unless
overridden by new entries
.Ip "modify_reduce" 4
.IX Item "modify_reduce"
same as reduce but it modifies the object instead of
returning a fraction.
.Ip "modify_num(Numerator)" 4
.IX Item "modify_num(Numerator)"
modifies the fraction's numerator.
.Ip "modify_den(Denominator)" 4
.IX Item "modify_den(Denominator)"
modified the fraction's denominator.
.Ip "modify_tag(\s-1TAGS\s0)" 4
.IX Item "modify_tag(TAGS)"
modifies the fraction tags.
.PP
The is_tag, tags, and modify_tags methods can be used on the class its
self to get at or modify the default tags.
.PP
The following methods will always modify or read the Class defaults
.Ip "digits" 4
.IX Item "digits"
returns the default number of digests to return when doing
floating point operations with \s-1BIG\s0 numbers, if set to undef 
Math::BigFloat will decide.
.Sp
.Vb 1
\&  modify_digits(NUM)
.Ve
.Sh "Dafault Sets"
.IX Subsection "Dafault Sets"
Default sets are way of modifying the defaults with out effecting
other functions.  Functions that relay on the default values or modify the
default should start with a \f(CW\*(C`$set_id = temp_set\*(C'\fR
and end with a \f(CW\*(C`temp_set($set_id)\*(C'\fR.
.PP
See the section on "EXAMPLES" for examples of how default sets work.
.PP
The following methods are met to manage default sets and will always
work on the Class defaults.
.Ip "sets" 4
.IX Item "sets"
returns a list of all the sets;
.Ip "name_set" 4
.IX Item "name_set"
return the name of the current set.
.Ip "name_set(\s-1NAME\s0)" 4
.IX Item "name_set(NAME)"
name the current set
.Ip "save_set" 4
.IX Item "save_set"
saves the current sent based on its name as given above
.Ip "save_set(\s-1NAME\s0)" 4
.IX Item "save_set(NAME)"
save the current set as \s-1NAME\s0
.Ip "save_set(\s-1RAND\s0)" 4
.IX Item "save_set(RAND)"
save the current set using a unique name
.Ip "load_set(\s-1NAME\s0)" 4
.IX Item "load_set(NAME)"
loads a set.
.Ip "copy_set(\s-1NAME_ORG\s0, \s-1NAME_NEW\s0)" 4
.IX Item "copy_set(NAME_ORG, NAME_NEW)"
copies a set. Returns true if successful.
.Ip "del_set(\s-1NAME\s0)" 4
.IX Item "del_set(NAME)"
deletes a set.
.Ip "exists_set(\s-1NAME\s0)" 4
.IX Item "exists_set(NAME)"
returns true if the set exists.
.Ip "use_set(\s-1NAME\s0)" 4
.IX Item "use_set(NAME)"
uses a set, that is any changes you make to the used set
will also change the original set, like a link.
.Ip "temp_set" 4
.IX Item "temp_set"
loads a temp set using the default default values
and returns a unique id you need to keep.
.Ip "temp_set(\s-1ID\s0)" 4
.IX Item "temp_set(ID)"
restores the original set based on the id you should of kept.
.PP
Unless otherwise specified all the set methods will return the name of
the set being worked on if it was successful, false otherwise
.Ip "tags(\s-1SET\s0)" 4
.IX Item "tags(SET)"
lists all the tags in \s-1SET\s0.
.Ip "is_tag(\s-1TAG\s0, \s-1SET\s0)" 4
.IX Item "is_tag(TAG, SET)"
returns true if \s-1TAG\s0 exists in \s-1SET\s0
.Ip "digits(\s-1SET\s0)" 4
.IX Item "digits(SET)"
returns what digits is set to in \s-1SET\s0;
.Sh "Overloaded Operators"
.IX Subsection "Overloaded Operators"
The following operations have been overridden and will return a
fraction:
.PP
.Vb 1
\&  +  -  /  *  +  +=  -=  *=  /=  ++  -- abs
.Ve
The following operations have also been overridden:
.PP
.Vb 1
\& <=> == != < <= > >=
.Ve
The following operations have also been overridden however they may spit
out nasty fractions.
.PP
.Vb 1
\&  ** sqrt
.Ve
Whenever you try to access a fraction as a string the string method
will be called and when try to access it as a number the decimal method
will be called.
.PP
This means that almost all other operations will work however some might
return decimals like the sin and cos;
.Sh "Notes on the \s-1AUTO\s0 tag"
.IX Subsection "Notes on the AUTO tag"
With the \s-1AUTO\s0 tag set Fractions will be converted between \s-1SMALL\s0 and
\&\s-1BIG\s0 as needed.  The \s-1BIG\s0 and \s-1SMALL\s0 tag will be \fI*ignorded*\fR unless you
explicitly specify \s-1NO_AUTO\s0 in auto to control how the fraction is
stored.
.PP
When you give it a number it will decide if it is small enough to be
stored as a \s-1SMALL\s0 or if the fraction needs to converted to \s-1BIG\s0.
However, in order for it to recognize a big fraction the number needs to
be in quotes, thus \f(CW\*(C`frac(7823495784957895478,781344567825678454)\*(C'\fR will still
be stored as a small with some of the digits lost.
.PP
When calculating to \s-1SMALL\s0 numbers that results in a number that is to
big for \s-1SMALL\s0 the calculation is done \s-1AGAIN\s0 but this time with \s-1BIG\s0
numbers (so that it will calculate all the digits correctly) and the
new fraction will become a \s-1BIG\s0.
.PP
When calculating to \s-1BIG\s0 numbers that results in a number that is small
enough to be a \s-1SMALL\s0 the new fraction will become a \s-1SMALL\s0.
.PP
Normally, the \s-1AUTO\s0 tag will save time as calculating with \s-1BIG\s0 numbers
can be quite time consuming however it might slow thinks down if it
constantly converts between the two thus in some cases it may be wise to
turn it off.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
This is a small demonstration of what the fraction module can do.
.PP
It is run for the most part with these two functions.
.PP
.Vb 2
\& sub pevel {print ">$_[0]\en"; $ans = eval $_[0]; print " $ans\en"; }
\& sub evelp {print ">$_[0]\en"; eval $_[0]; }
.Ve
You can see it for yourself my typing in
\&\f(CW\*(C`perl \-e "use Math::FractionDemo; frac_calc;"\*(C'\fR then frac_demo.
.PP
.Vb 22
\& >frac(1, 3)
\&  1/3
\& >frac(4, 3, MIXED)
\&  1 1/3
\& >frac(1, 1, 3)
\&  4/3
\& >frac(1, 1, 3, MIXED)
\&  1 1/3
\& >frac(10)
\&  10/1
\& >frac(10, MIXED)
\&  10
\& >frac(.66667)
\&  2/3
\& >frac(1.33333, MIXED)
\&  1 1/3
\& >frac("5/6")
\&  5/6
\& >frac("1 2/3")
\&  5/3
\& >frac(10, 20, NO_REDUCE)
\&  10/20
.Ve
.Vb 20
\& >$f1=frac(2,3); $f2=frac(4,5);
\& >$f1 + $f2
\&  22/15
\& >$f1 * $f2
\&  8/15
\& >$f1 + 1.6667
\&  7/3
\& >$f2->modify_tag(MIXED)
\& >$f2 + 10
\&  10 4/5
\& >frac($ans, NORMAL) # trick to create new fraction with different tags
\&  54/5
\& >$f1 + $f2          # Add two unlikes it goes to default mode
\&  22/15
\& >$f1**1.2
\&  229739670999407/373719281884655
\& >$f1->num**1.2
\&  0.614738607654485
\& >frac(1,2)+frac(2,5)
\&  9/10
.Ve
.Vb 20
\& >$f1=frac(5,3,NORMAL); $f2=frac(7,5);
\& >"$f1  $f2"
\&  5/3  7/5
\& >Math::Fraction->modify_tag(MIXED)
\& >"$f1  $f2"
\&  5/3  1 2/5
\& >$f1 = frac("3267893629762/32678632179820")
\&  3267893629762/32678632179820
\& >$f2 = frac("5326875886785/76893467996910")
\&  5326875886785/76893467996910
\& >$f1->is_tag(BIG).",".$f2->is_tag(BIG) # Notice how neither is BIG
\&  0,0
\& >$f1+$f2
\&  21267734600460495169085706/125638667885089122116217810
\& >$ans->is_tag(BIG)                     # But this answer is.
\&  1
\& >$f1*$f2
\&  1740766377695750621849517/251277335770178244232435620
\& >$ans->is_tag(BIG)                     # And so is this one.
\&  1
.Ve
.Vb 18
\& >$f1 = frac("3267893629762/32678632179820", BIG)
\&  3267893629762/32678632179820
\& >$f1->is_tag(BIG)   # Notice how the big tag had no effect.
\&  0
\& >$f1->modify_tag(NO_AUTO, BIG)
\& >$f1->is_tag(BIG)   # But now it does.  You have to turn off AUTO.
\&  1
\& >$f1->num
\&  .10000093063197482237806917498797382196606
\& >Math::Fraction->modify_digits(15)
\& >$f1->num
\&  .1000009306319748
\& >$f1 = frac("0.1231231234564564564564564564561234567891234567891234")
\&  13680347037037036999999999999963000037/
\&                             111111111000000000000000000000000000000
\& >Math::Fraction->modify_digits(65)
\& >$f1->num
\&  .123123123456456456456456456456123456789123456789123456789123456789
.Ve
.Vb 17
\& >$f1 = frac(7,5);
\& >$f2 = frac("3267893629762/32678632179820", NO_AUTO, BIG)
\& >Math::Fraction->modify_tag(MIXED); Math::Fraction->modify_digits(60)
\& >"$f1 ".$f2->num
\&  1 2/5 .1000009306319748223780691749879738219660647769485035912494771
\& >Math::Fraction->load_set(DEFAULT)
\& >"$f1 ".$f2->num
\&  7/5 .10000093063197482237806917498797382196606
\& >Math::Fraction->modify_digits(25)
\& >"$f1 ".$f2->num
\&  7/5 .10000093063197482237806917
\& >$s = Math::Fraction->temp_set
\& >Math::Fraction->modify_tag(MIXED); Math::Fraction->modify_digits(15)
\& >"$f1 ".$f2->num
\&  1 2/5 .1000009306319748
\& >Math::Fraction->temp_set($s)
\& >Math::Fraction->exists_set($s)
.Ve
.Vb 2
\& >"$f1 ".$f2->num  # Notice how it goes back to the previous settings.
\&  7/5 .10000093063197482237806917
.Ve
.Vb 23
\& >Math::Fraction->name_set('temp1')
\& >Math::Fraction->modify_tag(MIXED, NO_AUTO)
\& >Math::Fraction->modify_digits(60)
\& >&s(Math::Fraction->tags, Math::Fraction->digits)
\&  MIXED REDUCE SMALL NO_AUTO 60
\& >Math::Fraction->save_set  # If no name is given it will be saved via
\& >                          # its given name
\& >Math::Fraction->load_set(DEFAULT)
\& >&s(Math::Fraction->tags, Math::Fraction->digits)
\&  NORMAL REDUCE SMALL AUTO undef
\& >&s(Math::Fraction->tags('temp1'), Math::Fraction->digits('temp1'))
\&  MIXED REDUCE SMALL NO_AUTO 60
\& >  # ^^ Notice how this lets you preview other sets w/out loading them.
\& >Math::Fraction->load_set(DEFAULT)
\& >Math::Fraction->use_set('temp1')
\& >Math::Fraction->modify_tag(NO_REDUCE)
\& >&s(Math::Fraction->tags, Math::Fraction->digits)
\&  MIXED NO_REDUCE SMALL NO_AUTO 60
\& >&s(Math::Fraction->tags('temp1'), Math::Fraction->digits('temp1'))
\&  MIXED NO_REDUCE SMALL NO_AUTO 60
\& >  # ^^ Notice how this also modifies the temp1 tag becuase it is
\& >  #    being used if it was just loaded it would not do this
\& >  #    becuase there is no link.
.Ve
.SH "NOTES"
.IX Header "NOTES"
Beta Release
.PP
Originally Developed with Perl v 5.003_37 for Win32.
.PP
Has been testing on Perl Ver 5.003 on a solaris machine and perl
5.004 on Windows 95.
.PP
Built on a Linux 2 machine with perl v5.003.
.PP
Please send me feedback at kevina@clark.net
.PP
This is my first real attempt at writing a Perl Module and at
Object-Oriented Programming. (Although I know this is not a true-true
Object-Oriented Module as I cheated a little). I mainly wrote it to
teach my self how to program Object-Oriently in Perl and for the challenge.
.PP
If you know of any faster or simpler way of doing any this please let me
know.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
the Math::FractionDemo manpage, \fIperl\fR\|(1b)
.SH "AUTHOR and COPYRIGHT"
.IX Header "AUTHOR and COPYRIGHT"
Kevin Atkinson, kevina@clark.net
.PP
Copyright (c) 1997 Kevin Atkinson.  All rights reserved.
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
