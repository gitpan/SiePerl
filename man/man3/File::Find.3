.\" Automatically generated by Pod::Man version 1.15
.\" Fri Apr 20 13:10:32 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "File::Find 3"
.TH File::Find 3 "perl v5.6.1" "2001-02-23" "Perl Programmers Reference Guide"
.UC
.SH "NAME"
find \- traverse a file tree
.PP
finddepth \- traverse a directory structure depth-first
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    use File::Find;
\&    find(\e&wanted, '/foo', '/bar');
\&    sub wanted { ... }
.Ve
.Vb 3
\&    use File::Find;
\&    finddepth(\e&wanted, '/foo', '/bar');
\&    sub wanted { ... }
.Ve
.Vb 2
\&    use File::Find;
\&    find({ wanted => \e&process, follow => 1 }, '.');
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The first argument to \fIfind()\fR is either a hash reference describing the
operations to be performed for each file, or a code reference.
.PP
Here are the possible keys for the hash:
.if n .Ip "\f(CW""""wanted""""\fR" 3
.el .Ip "\f(CWwanted\fR" 3
.IX Item "wanted"
The value should be a code reference.  This code reference is called
\&\fIthe \fIwanted()\fI function\fR below.
.if n .Ip "\f(CW""""bydepth""""\fR" 3
.el .Ip "\f(CWbydepth\fR" 3
.IX Item "bydepth"
Reports the name of a directory only \s-1AFTER\s0 all its entries
have been reported.  Entry point \fIfinddepth()\fR is a shortcut for
specifying \f(CW\*(C`{ bydepth =\*(C'\fR 1 }> in the first argument of \fIfind()\fR.
.if n .Ip "\f(CW""""preprocess""""\fR" 3
.el .Ip "\f(CWpreprocess\fR" 3
.IX Item "preprocess"
The value should be a code reference.  This code reference is used to
preprocess a directory; it is called after \fIreaddir()\fR but before the loop that
calls the \fIwanted()\fR function.  It is called with a list of strings and is
expected to return a list of strings.  The code can be used to sort the
strings alphabetically, numerically, or to filter out directory entries based
on their name alone.
.if n .Ip "\f(CW""""postprocess""""\fR" 3
.el .Ip "\f(CWpostprocess\fR" 3
.IX Item "postprocess"
The value should be a code reference.  It is invoked just before leaving the
current directory.  It is called in void context with no arguments.  The name
of the current directory is in \f(CW$File::Find::dir\fR.  This hook is handy for
summarizing a directory, such as calculating its disk usage.
.if n .Ip "\f(CW""""follow""""\fR" 3
.el .Ip "\f(CWfollow\fR" 3
.IX Item "follow"
Causes symbolic links to be followed. Since directory trees with symbolic
links (followed) may contain files more than once and may even have
cycles, a hash has to be built up with an entry for each file.
This might be expensive both in space and time for a large
directory tree. See \fIfollow_fast\fR and \fIfollow_skip\fR below.
If either \fIfollow\fR or \fIfollow_fast\fR is in effect:
.RS 3
.Ip "\(bu" 6
It is guaranteed that an \fIlstat\fR has been called before the user's
\&\fI\fIwanted()\fI\fR function is called. This enables fast file checks involving \ _.
.Ip "\(bu" 6
There is a variable \f(CW\*(C`$File::Find::fullname\*(C'\fR which holds the absolute
pathname of the file with all symbolic links resolved
.RE
.RS 3
.RE
.if n .Ip "\f(CW""""follow_fast""""\fR" 3
.el .Ip "\f(CWfollow_fast\fR" 3
.IX Item "follow_fast"
This is similar to \fIfollow\fR except that it may report some files more
than once.  It does detect cycles, however.  Since only symbolic links
have to be hashed, this is much cheaper both in space and time.  If
processing a file more than once (by the user's \fI\fIwanted()\fI\fR function)
is worse than just taking time, the option \fIfollow\fR should be used.
.if n .Ip "\f(CW""""follow_skip""""\fR" 3
.el .Ip "\f(CWfollow_skip\fR" 3
.IX Item "follow_skip"
\&\f(CW\*(C`follow_skip==1\*(C'\fR, which is the default, causes all files which are
neither directories nor symbolic links to be ignored if they are about
to be processed a second time. If a directory or a symbolic link 
are about to be processed a second time, File::Find dies.
\&\f(CW\*(C`follow_skip==0\*(C'\fR causes File::Find to die if any file is about to be
processed a second time.
\&\f(CW\*(C`follow_skip==2\*(C'\fR causes File::Find to ignore any duplicate files and
dirctories but to proceed normally otherwise.
.if n .Ip "\f(CW""""no_chdir""""\fR" 3
.el .Ip "\f(CWno_chdir\fR" 3
.IX Item "no_chdir"
Does not \f(CW\*(C`chdir()\*(C'\fR to each directory as it recurses. The \fIwanted()\fR
function will need to be aware of this, of course. In this case,
\&\f(CW\*(C`$_\*(C'\fR will be the same as \f(CW\*(C`$File::Find::name\*(C'\fR.
.if n .Ip "\f(CW""""untaint""""\fR" 3
.el .Ip "\f(CWuntaint\fR" 3
.IX Item "untaint"
If find is used in taint-mode (\-T command line switch or if \s-1EUID\s0 != \s-1UID\s0
or if \s-1EGID\s0 != \s-1GID\s0) then internally directory names have to be untainted
before they can be cd'ed to. Therefore they are checked against a regular
expression \fIuntaint_pattern\fR.  Note that all names passed to the
user's \fI\fIwanted()\fI\fR function are still tainted. 
.if n .Ip "\f(CW""""untaint_pattern""""\fR" 3
.el .Ip "\f(CWuntaint_pattern\fR" 3
.IX Item "untaint_pattern"
See above. This should be set using the \f(CW\*(C`qr\*(C'\fR quoting operator.
The default is set to  \f(CW\*(C`qr|^([\-+@\ew./]+)$|\*(C'\fR. 
Note that the parantheses are vital.
.if n .Ip "\f(CW""""untaint_skip""""\fR" 3
.el .Ip "\f(CWuntaint_skip\fR" 3
.IX Item "untaint_skip"
If set, directories (subtrees) which fail the \fIuntaint_pattern\fR
are skipped. The default is to 'die' in such a case.
.PP
The \fIwanted()\fR function does whatever verifications you want.
\&\f(CW\*(C`$File::Find::dir\*(C'\fR contains the current directory name, and \f(CW\*(C`$_\*(C'\fR the
current filename within that directory.  \f(CW\*(C`$File::Find::name\*(C'\fR contains
the complete pathname to the file. You are \fIchdir()\fR'd to
\&\f(CW\*(C`$File::Find::dir\*(C'\fR when the function is called, unless \f(CW\*(C`no_chdir\*(C'\fR
was specified.  When <follow> or <follow_fast> are in effect, there is
also a \f(CW\*(C`$File::Find::fullname\*(C'\fR.  The function may set
\&\f(CW\*(C`$File::Find::prune\*(C'\fR to prune the tree unless \f(CW\*(C`bydepth\*(C'\fR was
specified.  Unless \f(CW\*(C`follow\*(C'\fR or \f(CW\*(C`follow_fast\*(C'\fR is specified, for
compatibility reasons (find.pl, find2perl) there are in addition the
following globals available: \f(CW\*(C`$File::Find::topdir\*(C'\fR,
\&\f(CW\*(C`$File::Find::topdev\*(C'\fR, \f(CW\*(C`$File::Find::topino\*(C'\fR,
\&\f(CW\*(C`$File::Find::topmode\*(C'\fR and \f(CW\*(C`$File::Find::topnlink\*(C'\fR.
.PP
This library is useful for the \f(CW\*(C`find2perl\*(C'\fR tool, which when fed,
.PP
.Vb 2
\&    find2perl / -name .nfs\e* -mtime +7 \e
\&        -exec rm -f {} \e; -o -fstype nfs -prune
.Ve
produces something like:
.PP
.Vb 10
\&    sub wanted {
\&        /^\e.nfs.*\ez/s &&
\&        (($dev, $ino, $mode, $nlink, $uid, $gid) = lstat($_)) &&
\&        int(-M _) > 7 &&
\&        unlink($_)
\&        ||
\&        ($nlink || (($dev, $ino, $mode, $nlink, $uid, $gid) = lstat($_))) &&
\&        $dev < 0 &&
\&        ($File::Find::prune = 1);
\&    }
.Ve
Set the variable \f(CW\*(C`$File::Find::dont_use_nlink\*(C'\fR if you're using \s-1AFS\s0,
since \s-1AFS\s0 cheats.
.PP
Here's another interesting wanted function.  It will find all symlinks
that don't resolve:
.PP
.Vb 3
\&    sub wanted {
\&         -l && !-e && print "bogus link: $File::Find::name\en";
\&    }
.Ve
See also the script \f(CW\*(C`pfind\*(C'\fR on \s-1CPAN\s0 for a nice application of this
module.
.SH "CAVEAT"
.IX Header "CAVEAT"
Be aware that the option to follow symbolic links can be dangerous.
Depending on the structure of the directory tree (including symbolic
links to directories) you might traverse a given (physical) directory
more than once (only if \f(CW\*(C`follow_fast\*(C'\fR is in effect). 
Furthermore, deleting or changing files in a symbolically linked directory
might cause very unpleasant surprises, since you delete or change files
in an unknown directory.
