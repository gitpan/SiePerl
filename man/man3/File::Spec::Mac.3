.\" Automatically generated by Pod::Man version 1.15
.\" Fri Apr 20 13:10:41 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "File::Spec::Mac 3"
.TH File::Spec::Mac 3 "perl v5.6.1" "2001-02-23" "Perl Programmers Reference Guide"
.UC
.SH "NAME"
File::Spec::Mac \- File::Spec for MacOS
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& require File::Spec::Mac; # Done internally by File::Spec if needed
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Methods for manipulating file specifications.
.SH "METHODS"
.IX Header "METHODS"
.Ip "canonpath" 2
.IX Item "canonpath"
On MacOS, there's nothing to be done.  Returns what it's given.
.Ip "catdir" 2
.IX Item "catdir"
Concatenate two or more directory names to form a complete path ending with 
a directory.  Put a trailing : on the end of the complete path if there 
isn't one, because that's what's done in MacPerl's environment.
.Sp
The fundamental requirement of this routine is that
.Sp
.Vb 1
\&          File::Spec->catdir(split(":",$path)) eq $path
.Ve
But because of the nature of Macintosh paths, some additional 
possibilities are allowed to make using this routine give reasonable results 
for some common situations.  Here are the rules that are used.  Each 
argument has its trailing \*(L":\*(R" removed.  Each argument, except the first,
has its leading \*(L":\*(R" removed.  They are then joined together by a \*(L":\*(R".
.Sp
So
.Sp
.Vb 5
\&          File::Spec->catdir("a","b") = "a:b:"
\&          File::Spec->catdir("a:",":b") = "a:b:"
\&          File::Spec->catdir("a:","b") = "a:b:"
\&          File::Spec->catdir("a",":b") = "a:b"
\&          File::Spec->catdir("a","","b") = "a::b"
.Ve
etc.
.Sp
To get a relative path (one beginning with :), begin the first argument with :
or put a "" as the first argument.
.Sp
If you don't want to worry about these rules, never allow a \*(L":\*(R" on the ends 
of any of the arguments except at the beginning of the first.
.Sp
Under MacPerl, there is an additional ambiguity.  Does the user intend that
.Sp
.Vb 1
\&          File::Spec->catfile("LWP","Protocol","http.pm")
.Ve
be relative or absolute?  There's no way of telling except by checking for the
existence of \s-1LWP:\s0 or :LWP, and even there he may mean a dismounted volume or
a relative path in a different directory (like in \f(CW@INC\fR).   So those checks
aren't done here. This routine will treat this as absolute.
.Ip "catfile" 2
.IX Item "catfile"
Concatenate one or more directory names and a filename to form a
complete path ending with a filename.  Since this uses catdir, the
same caveats apply.  Note that the leading : is removed from the filename,
so that 
.Sp
.Vb 1
\&          File::Spec->catfile($ENV{HOME},"file");
.Ve
and
.Sp
.Vb 1
\&          File::Spec->catfile($ENV{HOME},":file");
.Ve
give the same answer, as one might expect.
.Ip "curdir" 2
.IX Item "curdir"
Returns a string representing the current directory.
.Ip "devnull" 2
.IX Item "devnull"
Returns a string representing the null device.
.Ip "rootdir" 2
.IX Item "rootdir"
Returns a string representing the root directory.  Under MacPerl,
returns the name of the startup volume, since that's the closest in
concept, although other volumes aren't rooted there.
.Ip "tmpdir" 2
.IX Item "tmpdir"
Returns a string representation of the first existing directory
from the following list or '' if none exist:
.Sp
.Vb 1
\&    $ENV{TMPDIR}
.Ve
.Ip "updir" 2
.IX Item "updir"
Returns a string representing the parent directory.
.Ip "file_name_is_absolute" 2
.IX Item "file_name_is_absolute"
Takes as argument a path and returns true, if it is an absolute path.  In 
the case where a name can be either relative or absolute (for example, a 
folder named \*(L"\s-1HD\s0\*(R" in the current working directory on a drive named \*(L"\s-1HD\s0\*(R"), 
relative wins.  Use \*(L":\*(R" in the appropriate place in the path if you want to
distinguish unambiguously.
.Sp
As a special case, the file name '' is always considered to be absolute.
.Ip "path" 2
.IX Item "path"
Returns the null list for the MacPerl application, since the concept is 
usually meaningless under MacOS. But if you're using the MacPerl tool under 
\&\s-1MPW\s0, it gives back \f(CW$ENV\fR{Commands} suitably split, as is done in 
:lib:ExtUtils:MM_Mac.pm.
.Ip "splitpath" 2
.IX Item "splitpath"
.PD 0
.Ip "splitdir" 2
.IX Item "splitdir"
.Ip "catpath" 2
.IX Item "catpath"
.Ip "abs2rel" 2
.IX Item "abs2rel"
.PD
See the abs2rel entry in the File::Spec::Unix manpage for general documentation.
.Sp
Unlike \f(CW\*(C`File::Spec::Unix\-\*(C'\fR\fIabs2rel()\fR>, this function will make
checks against the local filesystem if necessary.  See
the file_name_is_absolute entry elsewhere in this document for details.
.Ip "rel2abs" 2
.IX Item "rel2abs"
See the rel2abs entry in the File::Spec::Unix manpage for general documentation.
.Sp
Unlike \f(CW\*(C`File::Spec::Unix\-\*(C'\fR\fIrel2abs()\fR>, this function will make
checks against the local filesystem if necessary.  See
the file_name_is_absolute entry elsewhere in this document for details.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
the File::Spec manpage
