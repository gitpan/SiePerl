.\" Automatically generated by Pod::Man version 1.15
.\" Mon Apr 23 13:52:56 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "Generator 3"
.TH Generator 3 "perl v5.6.1" "2000-12-12" "User Contributed Perl Documentation"
.UC
.SH "NAME"
\&\s-1XML:\s0:Generator \- Perl extension for generating \s-1XML\s0
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use XML::Generator;
.Ve
.Vb 3
\&   my $xml = XML::Generator->new(escape => 'always',
\&                                 pretty => 2,
\&                                 conformance => 'strict');
.Ve
.Vb 2
\&   print $xml->foo($xml->bar({ baz => 3 }, $xml->bam),
\&                   $xml->bar([ 'qux' ], "Hey there, world"));
.Ve
.Vb 7
\&   # The above would yield:
\&   <foo>
\&     <bar baz="3">
\&       <bam />
\&     </bar>
\&     <qux:bar>Hey there, world</qux:bar>
\&   </foo>
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
In general, once you have an \s-1XML:\s0:Generator object, you then simply call
methods on that object named for each \s-1XML\s0 tag you wish to generate. 
Say you want to generate this \s-1XML:\s0
.PP
.Vb 5
\&   <person>
\&     <name>Bob</name>
\&     <age>34</age>
\&     <job>Accountant</job>
\&   </person>
.Ve
Here's a snippet of code that does the job, complete with pretty printing:
.PP
.Vb 7
\&   use XML::Generator;
\&   my $gen = XML::Generator->new(escape => 'always', pretty => 2);
\&   print $gen->person(
\&            $gen->name("Bob"),
\&            $gen->age(34),
\&            $gen->job("Accountant")
\&         );
.Ve
The only problem with this is if you want to use a tag name that Perl's
lexer won't understand as a method name, such as \*(L"shoe-size\*(R".  Fortunately,
since you can always call methods as variable names, there's a simple
work-around:
.PP
.Vb 2
\&   my $shoe_size = "shoe-size";
\&   $xml = $gen->$shoe_size("12 1/2");
.Ve
Which correctly generates:
.PP
.Vb 1
\&   <shoe-size>12 1/2</shoe-size>
.Ve
You can use a hash ref as the first parameter if the tag should include
atributes.  An array ref can be supplied as the first argument to indicate
a namespace for the element and the attributes (the elements of the array
are concatenated with ':').  Under strict conformance, however, you are
only allowed one namespace component.
.PP
If you want to specify a namespace as well as attributes, you can make the
second argument a hash ref.  If you do it the other way around, the array ref
will simply get stringified and included as part of the content of the tag.
If an \s-1XML:\s0:Generator object has a namespace set, and a namespace is also
supplied to the tag, the supplied namespace overrides the default.
.PP
Here's an example to show how the attribute and namespace parameters work:
.PP
.Vb 4
\&   $xml = $gen->account({ type => 'checking', id => '34758'},
\&            $gen->open(['transaction'], 2000),
\&            $gen->deposit(['transaction'], { date => '1999.04.03'}, 1500)
\&          );
.Ve
This generates:
.PP
.Vb 4
\&   <account type="checking" id="34578">
\&     <transaction:open>2000</transaction:open>
\&     <transaction:deposit transaction:date="1999.04.03">1500</transaction:deposit>
\&   </account>
.Ve
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
\&\s-1XML:\s0:Generator->new(option => 'value', option => 'value');
.PP
The following options are available:
.Sh "namespace"
.IX Subsection "namespace"
The value of this option is used as the global default namespace.
For example,
.PP
.Vb 2
\&   my $html = XML::Generator->new(namespace => 'HTML');
\&   print $html->font({ face => 'Arial' }, "Hello, there");
.Ve
would yield
.PP
.Vb 1
\&   <HTML:font HTML:face="Arial">Hello, there</HTML:font>
.Ve
See \s-1HTML:\s0:Generator for routines specific to \s-1HTML\s0 generation.
.Sh "escape"
.IX Subsection "escape"
The contents and the values of each attribute have any illegal \s-1XML\s0
characters escaped if this option is supplied.  If the value is 'always',
then &, < and > (and " within attribute values) will be converted into the
corresponding \s-1XML\s0 entity.  If the value is any other true value, then the
escaping will be turned off character-by-character if the character in question
is preceded by a backslash, or for the entire string if it is supplied as a
scalar reference.  So, for example,
.PP
.Vb 3
\&   my $a = XML::Generator->new(escape => 'always');
\&   my $b = XML::Generator->new(escape => 'true');
\&   print $a->foo('<', $b->bar('3 \e> 4', \e" && 6 < 5"), '\e&', '>');
.Ve
would yield
.PP
.Vb 1
\&   <foo>&lt;<bar>3 > 4 && 6 < 5</bar>\e&amp;&gt;</foo>
.Ve
.Sh "pretty"
.IX Subsection "pretty"
To have nice pretty printing of the output \s-1XML\s0 (great for config files
that you might also want to edit by hand), pass an integer for the
number of spaces per level of indenting, eg.
.PP
.Vb 3
\&   my $gen = XML::Generator->new(pretty => 2);
\&   print $gen->foo($gen->bar('baz'),
\&                   $gen->qux({ tricky => 'no'}, 'quux'));
.Ve
would yield
.PP
.Vb 4
\&   <foo>
\&     <bar>baz</bar>
\&     <qux tricky="no">quux</qux>
\&   </foo>
.Ve
Pretty printing does not apply to \s-1CDATA\s0 sections or Processing Instructions.
.Sh "conformance"
.IX Subsection "conformance"
If the value of this option is 'strict', a number of syntactic
checks are performed to ensure that generated \s-1XML\s0 conforms to the
formal \s-1XML\s0 specification.  In addition, since entity names beginning
with 'xml' are reserved by the W3C, inclusion of this option enables
several special tag names: xmlpi, xmlcmnt, xmldecl, xmldtd, xmlcdata,
and xml to allow generation of processing instructions, comments, \s-1XML\s0
declarations, \s-1DTD\s0's, character data sections and \*(L"final\*(R" \s-1XML\s0 documents,
respectively.
.PP
See the section on "XML CONFORMANCE" and the section on "SPECIAL TAGS" for more information.
.Sh "empty"
.IX Subsection "empty"
There are 5 possible values for this option:
.PP
.Vb 5
\&   self    -  create empty tags as <tag />  (default)
\&   compact -  create empty tags as <tag/>
\&   close   -  close empty tags as <tag></tag>
\&   ignore  -  don't do anything (non-compliant!)
\&   args    -  use count of arguments to decide between <x /> and <x></x>
.Ve
Many web browsers like the 'self' form, but any one of the forms besides
\&'ignore' is acceptable under the \s-1XML\s0 standard.
.PP
\&'ignore' is intended for subclasses that deal with \s-1HTML\s0 and other
\&\s-1SGML\s0 subsets which allow atomic tags.  It is an error to specify both
\&'conformance' => 'strict' and 'empty' => 'ignore'.
.PP
\&'args' will produce <x /> if there are no arguments at all, or if there
is just a single undef argument, and <x></x> otherwise.
.SH "XML CONFORMANCE"
.IX Header "XML CONFORMANCE"
When the 'conformance' => 'strict' option is supplied, a number of
syntactic checks are enabled.  All entity and attribute names are
checked to conform to the \s-1XML\s0 specification, which states that they
must begin with either an alphabetic character or an underscore and
may then consist of any number of alphanumerics, underscores, periods
or hyphens.  Alphabetic and alphanumeric are interpreted according to
the current locale if 'use locale' is in effect and according to the
Unicode standard for Perl versions >= 5.6.  Furthermore, entity or
attribute names are not allowed to begin with 'xml' (in any case),
although a number of special tags beginning with 'xml' are allowed
(see the section on "SPECIAL TAGS").
.PP
In addition, only one namespace component will be allowed when strict
conformance is in effect, and attribute names can be given a specific
namespace, which will override both the default namespace and the tag-
specific namespace.  For example,
.PP
.Vb 5
\&   my $gen = XML::Generator->new(conformance => 'strict',
\&                                 namespace   => 'foo');
\&   my $xml = $gen->bar({ a => 1 },
\&               $gen->baz(['bam'], { b => 2, 'name:c' => 3 })
\&              );
.Ve
will generate:
.PP
.Vb 1
\&   <foo:bar foo:a="1"><bam:baz bam:b="2" name:c="3" /></foo:bar>
.Ve
.SH "SPECIAL TAGS"
.IX Header "SPECIAL TAGS"
The following special tags are available when running under strict
conformance (otherwise they don't act special):
.Sh "xmlpi"
.IX Subsection "xmlpi"
Processing instruction; first argument is target, remaining arguments
are attribute, value pairs.  Attribute names are syntax checked, values
are escaped.
.Sh "xmlcmnt"
.IX Subsection "xmlcmnt"
Comment.  Arguments are concatenated and placed inside <!\-\- ... \-\-> comment
delimiters.  Any occurences of '\-\-' in the concatenated arguments are
converted to '\-&#45;'
.Sh "xmldecl"
.IX Subsection "xmldecl"
Declaration.  This can be used to specify the version, encoding, and other
XML-related declarations (i.e., anything inside the <?xml?> tag).
.Sh "xmldtd"
.IX Subsection "xmldtd"
\&\s-1DTD\s0 <!DOCTYPE> tag creation. The format of this method is different from 
others. Since \s-1DTD\s0's are global and cannot contain namespace information,
the first argument arrayref is concatenated together to form the \s-1DTD:\s0
.PP
.Vb 1
\&   print $xml->xmldtd([ 'html', 'PUBLIC', $xhtml_w3c, $xhtml_dtd ])
.Ve
This would produce the following declaration:
.PP
.Vb 2
\&   <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
\&        "DTD/xhtml1-transitional.dtd">
.Ve
Assuming that \f(CW$xhtml_w3c\fR and \f(CW$xhtml_dtd\fR had the correct values. For
shortcuts to <!DOCTYPE> generation, see the \s-1HTML:\s0:Generator module.
Note that you can also specify a \s-1DTD\s0 on creation using the \fInew()\fR method's
dtd option.
.Sh "xmlcdata"
.IX Subsection "xmlcdata"
Character data section; arguments are concatenated and placed inside
<![CDATA[ ... ]]> character data section delimiters.  Any occurences of
\&']]>' in the concatenated arguments are converted to ']]&gt;'.
.Sh "xml"
.IX Subsection "xml"
\&\*(L"Final\*(R" \s-1XML\s0 document.  Must be called with one and exactly one
\&\s-1XML:\s0:Generator-produced \s-1XML\s0 document.  Any combination of
\&\s-1XML:\s0:Generator-produced \s-1XML\s0 comments or processing instructions may
also be supplied as arguments.  Prepends an \s-1XML\s0 declaration, and
re-blesses the argument into a \*(L"final\*(R" class that can't be embedded.
.SH "CREATING A SUBCLASS"
.IX Header "CREATING A SUBCLASS"
For an example of how to subclass \s-1XML:\s0:Generator, see Nathan Wiger's 
\&\s-1HTML:\s0:Generator module.
.PP
At times, you may find it desireable to subclass \s-1XML:\s0:Generator. For example,
you might want to provide a more application-specific interface to the \s-1XML\s0
generation routines provided. Perhaps you have a custom database application
and would really like to say:
.PP
.Vb 2
\&   my $dbxml = new XML::Generator::MyDatabaseApp;
\&   print $dbxml->xml($dbxml->custom_tag_handler(@data));
.Ve
Here, \fIcustom_tag_handler()\fR may be a method that builds a recursive \s-1XML\s0
structure based on the contents of \f(CW@data\fR. In fact, it may even be named
for a tag you want generated, such as \fIauthors()\fR, whose behavior changes
based on the contents (perhaps creating recursive definitions in the
case of multiple elements).
.PP
Creating a subclass of \s-1XML:\s0:Generator is actually relatively straightforward,
there are just three things you have to remember:
.PP
.Vb 1
\&   1. All of the useful utilities are in XML::Generator::util.
.Ve
.Vb 2
\&   2. To construct a tag you simply have to call SUPER::tagname,
\&      where "tagname" is the name of your tag.
.Ve
.Vb 1
\&   3. You must fully-qualify the methods in XML::Generator::util.
.Ve
So, let's assume that we want to provide a custom \s-1HTML\s0 \fItable()\fR method:
.PP
.Vb 2
\&   package XML::Generator::CustomHTML;
\&   use base 'XML::Generator';
.Ve
.Vb 2
\&   sub table {
\&       my $self = shift;
.Ve
.Vb 3
\&       # parse our args to get namespace and attribute info
\&       my($namespace, $attr, @content) =
\&          $self->XML::Generator::util::parse_args(@_)
.Ve
.Vb 4
\&       # check for strict conformance
\&       if ( $self->XML::Generator::util::config('conformance') eq 'strict' ) {
\&          # ... special checks ...
\&       }
.Ve
.Vb 1
\&       # ... special formatting magic happens ...
.Ve
.Vb 3
\&       # construct our custom tags
\&       return $self->SUPER::table($attr, $self->tr($self->td(@content)));
\&   }
.Ve
That's pretty much all there is to it. We have to explicitly call
\&\s-1SUPER:\\fIs0:table()\fR since we're inside the class's \fItable()\fR method. The others
can simply be called directly, assuming that we don't have a \fItr()\fR in the
current package.
.PP
If you want to explicitly create a specific tag by name, or just want a
faster approach than \s-1AUTOLOAD\s0 provides, you can use the \fItag()\fR method
directly. So, we could replace that last line above with:
.PP
.Vb 2
\&       # construct our custom tags 
\&       return $self->XML::Generator::util::tag('table', $attr, ...);
.Ve
Here, we must explicitly call \fItag()\fR with the tag name itself as its first
argument so it knows what to generate. These are the methods that you might
find useful:
.Ip "\s-1XML:\\fIs0:Generator::util::parse_args()\fR" 4
.IX Item "XML:f(ISs0:Generator::util::parse_args()"
This parses the argument list and returns the namespace (arrayref), attributes
(hashref), and remaining content (array), in that order.
.Ip "\s-1XML:\\fIs0:Generator::util::tag()\fR" 4
.IX Item "XML:f(ISs0:Generator::util::tag()"
This does the work of generating the appropriate tag. The first argument must
be the name of the tag to generate.
.Ip "\s-1XML:\\fIs0:Generator::util::config()\fR" 4
.IX Item "XML:f(ISs0:Generator::util::config()"
This retrieves options as set via the \fInew()\fR method.
.Ip "\s-1XML:\\fIs0:Generator::util::escape()\fR" 4
.IX Item "XML:f(ISs0:Generator::util::escape()"
This escapes any illegal \s-1XML\s0 characters.
.PP
Remember that all of these methods must be fully-qualified with the
\&\s-1XML:\s0:Generator::util package name. This is because \s-1AUTOLOAD\s0 is used by 
the main \s-1XML:\s0:Generator package to create tags. Simply calling \fIparse_args()\fR
will result in a set of \s-1XML\s0 tags called <parse_args>.
.PP
Finally, remember that since you are subclassing \s-1XML:\s0:Generator, you do not
need to provide your own \fInew()\fR method. The one from \s-1XML:\s0:Generator is designed
to allow you to properly subclass it.
.SH "AUTHORS"
.IX Header "AUTHORS"
.Ip "Benjamin Holzman <bholzman@earthlink.net>" 4
.IX Item "Benjamin Holzman <bholzman@earthlink.net>"
Original author and maintainer
.Ip "Bron Gondwana <perlcode@brong.net>" 4
.IX Item "Bron Gondwana <perlcode@brong.net>"
First modular version
.Ip "Nathan Wiger <nate@nateware.com>" 4
.IX Item "Nathan Wiger <nate@nateware.com>"
Modular rewrite to enable subclassing
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.Ip "Perl-XML \s-1FAQ\s0" 4
.IX Item "Perl-XML FAQ"
http://www.perlxml.com/faq/perl-xml-faq.html
.Ip "The \s-1XML:\s0:Writer module" 4
.IX Item "The XML::Writer module"
http://search.cpan.org/search?mode=module&query=XML::Writer
.Ip "The \s-1XML:\s0:Handler::YAWriter module" 4
.IX Item "The XML::Handler::YAWriter module"
http://search.cpan.org/search?mode=module&query=XML::Handler::YAWriter
.Ip "The \s-1HTML:\s0:Generator module" 4
.IX Item "The HTML::Generator module"
http://search.cpan.org/search?mode=module&query=HTML::Generator
