.\" Automatically generated by Pod::Man version 1.15
.\" Mon Apr 23 12:30:54 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "MD5 3"
.TH MD5 3 "perl v5.6.1" "1996-08-12" "User Contributed Perl Documentation"
.UC
.SH "NAME"
\&\s-1MD5\s0 \- Perl interface to the \s-1RSA\s0 Data Security Inc. \s-1MD5\s0 Message-Digest Algorithm
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use MD5;
.Ve
.Vb 2
\&    $context = new MD5;
\&    $context->reset();
.Ve
.Vb 2
\&    $context->add(LIST);
\&    $context->addfile(HANDLE);
.Ve
.Vb 2
\&    $digest = $context->digest();
\&    $string = $context->hexdigest();
.Ve
.Vb 2
\&    $digest = MD5->hash(SCALAR);
\&    $string = MD5->hexhash(SCALAR);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \fB\s-1MD5\s0\fR module allows you to use the \s-1RSA\s0 Data Security Inc. \s-1MD5\s0
Message Digest algorithm from within Perl programs.
.PP
A new \s-1MD5\s0 context object is created with the \fBnew\fR operation.
Multiple simultaneous digest contexts can be maintained, if desired.
The context is updated with the \fBadd\fR operation which adds the
strings contained in the \fI\s-1LIST\s0\fR parameter. Note, however, that
\&\f(CW\*(C`add('foo', 'bar')\*(C'\fR, \f(CW\*(C`add('foo')\*(C'\fR followed by \f(CW\*(C`add('bar')\*(C'\fR and
\&\f(CW\*(C`add('foobar')\*(C'\fR should all give the same result.
.PP
The final message digest value is returned by the \fBdigest\fR operation
as a 16\-byte binary string. This operation delivers the result of
\&\fBadd\fR operations since the last \fBnew\fR or \fBreset\fR operation. Note
that the \fBdigest\fR operation is effectively a destructive, read-once
operation. Once it has been performed, the context must be \fBreset\fR
before being used to calculate another digest value.
.PP
Several convenience functions are also provided. The \fBaddfile\fR
operation takes an open file-handle and reads it until end-of file in
1024 byte blocks adding the contents to the context. The file-handle
can either be specified by name or passed as a type-glob reference, as
shown in the examples below. The \fBhexdigest\fR operation calls
\&\fBdigest\fR and returns the result as a printable string of hexdecimal
digits. This is exactly the same operation as performed by the
\&\fBunpack\fR operation in the examples below.
.PP
The \fBhash\fR operation can act as either a static member function (ie
you invoke it on the \s-1MD5\s0 class as in the synopsis above) or as a
normal virtual function. In both cases it performs the complete \s-1MD5\s0
cycle (reset, add, digest) on the supplied scalar value. This is
convenient for handling small quantities of data. When invoked on the
class a temporary context is created. When invoked through an already
created context object, this context is used. The latter form is
slightly more efficient. The \fBhexhash\fR operation is analogous to
\&\fBhexdigest\fR.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 1
\&    use MD5;
.Ve
.Vb 4
\&    $md5 = new MD5;
\&    $md5->add('foo', 'bar');
\&    $md5->add('baz');
\&    $digest = $md5->digest();
.Ve
.Vb 1
\&    print("Digest is " . unpack("H*", $digest) . "\en");
.Ve
The above example would print out the message
.PP
.Vb 1
\&    Digest is 6df23dc03f9b54cc38a0fc1483df6e21
.Ve
provided that the implementation is working correctly.
.PP
Remembering the Perl motto (\*(L"There's more than one way to do it\*(R"), the
following should all give the same result:
.PP
.Vb 2
\&    use MD5;
\&    $md5 = new MD5;
.Ve
.Vb 1
\&    die "Can't open /etc/passwd ($!)\en" unless open(P, "/etc/passwd");
.Ve
.Vb 5
\&    seek(P, 0, 0);
\&    $md5->reset;
\&    $md5->addfile(P);
\&    $d = $md5->hexdigest;
\&    print "addfile (handle name) = $d\en";
.Ve
.Vb 5
\&    seek(P, 0, 0);
\&    $md5->reset;
\&    $md5->addfile(\e*P);
\&    $d = $md5->hexdigest;
\&    print "addfile (type-glob reference) = $d\en";
.Ve
.Vb 8
\&    seek(P, 0, 0);
\&    $md5->reset;
\&    while (<P>)
\&    {
\&        $md5->add($_);
\&    }
\&    $d = $md5->hexdigest;
\&    print "Line at a time = $d\en";
.Ve
.Vb 5
\&    seek(P, 0, 0);
\&    $md5->reset;
\&    $md5->add(<P>);
\&    $d = $md5->hexdigest;
\&    print "All lines at once = $d\en";
.Ve
.Vb 8
\&    seek(P, 0, 0);
\&    $md5->reset;
\&    while (read(P, $data, (rand % 128) + 1))
\&    {
\&        $md5->add($data);
\&    }
\&    $d = $md5->hexdigest;
\&    print "Random chunks = $d\en";
.Ve
.Vb 6
\&    seek(P, 0, 0);
\&    $md5->reset;
\&    undef $/;
\&    $data = <P>;
\&    $d = $md5->hexhash($data);
\&    print "Single string = $d\en";
.Ve
.Vb 1
\&    close(P);
.Ve
.SH "NOTE"
.IX Header "NOTE"
The \s-1MD5\s0 extension may be redistributed under the same terms as Perl.
The \s-1MD5\s0 algorithm is defined in \s-1RFC1321\s0. The basic C code implementing
the algorithm is derived from that in the \s-1RFC\s0 and is covered by the
following copyright:
.Sp
Copyright (C) 1991\-2, \s-1RSA\s0 Data Security, Inc. Created 1991. All
rights reserved.
.Sp
License to copy and use this software is granted provided that it
is identified as the \*(L"\s-1RSA\s0 Data Security, Inc. \s-1MD5\s0 Message-Digest
Algorithm\*(R" in all material mentioning or referencing this software
or this function.
.Sp
License is also granted to make and use derivative works provided
that such works are identified as \*(L"derived from the \s-1RSA\s0 Data
Security, Inc. \s-1MD5\s0 Message-Digest Algorithm\*(R" in all material
mentioning or referencing the derived work.
.Sp
\&\s-1RSA\s0 Data Security, Inc. makes no representations concerning either
the merchantability of this software or the suitability of this
software for any particular purpose. It is provided \*(L"as is\*(R"
without express or implied warranty of any kind.
.Sp
These notices must be retained in any copies of any part of this
documentation and/or software.
.PP
This copyright does not prohibit distribution of any version of Perl
containing this extension under the terms of the \s-1GNU\s0 or Artistic
licences.
.SH "AUTHOR"
.IX Header "AUTHOR"
The \s-1MD5\s0 interface was written by Neil Winton
(\f(CW\*(C`N.Winton@axion.bt.co.uk\*(C'\fR).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1).
