.\" Automatically generated by Pod::Man version 1.15
.\" Mon Apr 23 13:10:17 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "Agent::Channel::Handle 3"
.TH Agent::Channel::Handle 3 "perl v5.6.1" "2001-03-14" "User Contributed Perl Documentation"
.UC
.SH "NAME"
Log::Agent::Channel::Handle \- I/O handle logging channel for Log::Agent
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& require Log::Agent::Channel::Handle;
.Ve
.Vb 6
\& my $driver = Log::Agent::Channel::Handle->make(
\&     -prefix     => "prefix",
\&     -stampfmt   => "own",
\&     -showpid    => 1,
\&     -handle     => \e*FILE,
\& );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The handle channel performs logging to an already opened I/O handle,
along with the necessary prefixing and stamping of the messages.
.PP
The creation routine \fImake()\fR takes the following arguments:
.if n .Ip "\f(CW""""\-handle""""\fR => \fIhandle\fR" 4
.el .Ip "\f(CW\-handle\fR => \fIhandle\fR" 4
.IX Item "-handle => handle"
Specifies the I/O \fIhandle\fR to use.  It can be given as a \s-1GLOB\s0 reference,
such as \f(CW\*(C`\e*FILE\*(C'\fR, or as an \f(CW\*(C`IO::Handle\*(C'\fR object.
.Sp
\&\fB\s-1NOTE\s0\fR: Auto-flushing is not enabled on the \fIhandle\fR.  Even when the
channel is closed, the \fIhandle\fR is left as-is: we simply stop sending
log messages to it.
.if n .Ip "\f(CW""""\-no_newline""""\fR => \fIflag\fR" 4
.el .Ip "\f(CW\-no_newline\fR => \fIflag\fR" 4
.IX Item "-no_newline => flag"
When set to \fItrue\fR, never append any \*(L"\en\*(R" (on Unix) or \*(L"\er\en\*(R" (on Windows)
to log messages.
.Sp
Internally, Log::Agent relies on the channel to delimit logged lines
appropriately, so this flag is not used.  However, it might be useful
for \f(CW\*(C`Log::Agent::Logger\*(C'\fR users.
.Sp
Default is \fIfalse\fR, meaning newline markers are systematically appended.
.if n .Ip "\f(CW""""\-no_prefixing""""\fR => \fIflag\fR" 4
.el .Ip "\f(CW\-no_prefixing\fR => \fIflag\fR" 4
.IX Item "-no_prefixing => flag"
When set to \fItrue\fR, disable the prefixing logic entirely, i.e. the
following options are ignored completely: \f(CW\*(C`\-prefix\*(C'\fR, \f(CW\*(C`\-showpid\*(C'\fR,
\&\f(CW\*(C`\-no_ucfirst\*(C'\fR, \f(CW\*(C`\-stampfmt\*(C'\fR.
.Sp
Default is \fIfalse\fR.
.if n .Ip "\f(CW""""\-no_ucfirst""""\fR => \fIflag\fR" 4
.el .Ip "\f(CW\-no_ucfirst\fR => \fIflag\fR" 4
.IX Item "-no_ucfirst => flag"
When set to \fItrue\fR, don't upper-case the first letter of the log message
entry when there's no prefix inserted before the logged line.  When there
is a prefix, a \*(L":\*(R" character follows, and therefore the leading letter
of the message should not be upper-cased anyway.
.Sp
Default is \fIfalse\fR, meaning uppercasing is performed.
.if n .Ip "\f(CW""""\-prefix""""\fR => \fIprefix\fR" 4
.el .Ip "\f(CW\-prefix\fR => \fIprefix\fR" 4
.IX Item "-prefix => prefix"
The application prefix string to prepend to messages.
.if n .Ip "\f(CW""""\-showpid""""\fR => \fIflag\fR" 4
.el .Ip "\f(CW\-showpid\fR => \fIflag\fR" 4
.IX Item "-showpid => flag"
If set to true, the \s-1PID\s0 of the process will be appended within square
brackets after the prefix, to all messages.
.Sp
Default is \fIfalse\fR.
.if n .Ip "\f(CW""""\-stampfmt""""\fR => (\fIname\fR | \fI\s-1CODE\s0\fR)" 4
.el .Ip "\f(CW\-stampfmt\fR => (\fIname\fR | \fI\s-1CODE\s0\fR)" 4
.IX Item "-stampfmt => (name | CODE)"
Specifies the time stamp format to use. By default, my \*(L"own\*(R" format is used.
See the Log::Agent::Stamping manpage for a description of the available format names.
.Sp
You may also specify a \s-1CODE\s0 ref: that routine will be called every time
we need to compute a time stamp. It should not expect any parameter, and
should return a string.
.SH "CAVEAT"
.IX Header "CAVEAT"
Beware of \fIchdir()\fR.  If your program uses \fIchdir()\fR, you should always specify
logfiles by using absolute paths, otherwise you run the risk of having
your relative paths become invalid: there is no anchoring done at the time
you specify them.  This is especially true when configured for rotation,
since the logfiles are recreated as needed and you might end up with many
logfiles scattered throughout all the directories you \fIchdir()\fRed to.
.SH "AUTHOR"
.IX Header "AUTHOR"
Raphael Manfredi \fI<Raphael_Manfredi@pobox.com>\fR
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fILog::Agent::Logger\fR\|(3), \fILog::Agent::Channel\fR\|(3).
