.\" Automatically generated by Pod::Man version 1.15
.\" Mon Apr 23 12:02:16 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "HTML::Mason::Tests 3"
.TH HTML::Mason::Tests 3 "perl v5.6.1" "2000-12-13" "User Contributed Perl Documentation"
.UC
.SH "NAME"
\&\s-1HTML:\s0:Mason::Tests \- Test harness for testing Mason
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use HTML::Mason::Tests;
.Ve
.Vb 13
\& my $group = HTML::Mason::Tests->new( name => 'name of group', description => 'tests something' );
\& $group->add_test( name => 'foo',
\&                   description => 'tests foo',
\&                   component => <<'EOF'
\& <%args>
\& $foo => 1
\& </%args>
\& <% $foo %>
\& EOF
\&                   expect => <<'EOF',
\& 1
\& EOF
\&                 );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is designed to automate as much as possible of the Mason
test suite.  It does tasks like write component files to disk, call
them, compare the actual results to the expected results, and more.
In addition, it also is capable of printing out useful information
about test failures when run in verbose mode.  See the \s-1ADDITIONAL\s0 \s-1RUN\s0
\&\s-1MODES\s0 section for more information.
.PP
It also makes sure that any given group of tests provides all the
information needed to run them (test names, components and results,
etc.).
.PP
Now you have no excuse for writing new tests (and that goes double for
me!).
.SH "METHODS"
.IX Header "METHODS"
.Sh "new"
.IX Subsection "new"
Takes the following parameters:
.Ip "\(bu name (required)"
.IX Item "name (required)"
The name of the entire group of tests.
.Ip "\(bu description (required)"
.IX Item "description (required)"
What this group tests.
.Sh "add_support"
.IX Subsection "add_support"
Takes the following parameters:
.Ip "\(bu path (required)" 4
.IX Item "path (required)"
The path that other components will expect this component to be
reachable at.  All paths are prepended with the group name.  So '/bar'
as a support component in the 'foo' group's ultimate path would be
\&'/foo/bar'.
.Ip "\(bu component" 4
.IX Item "component"
Text of the support component.  This parameter must have a value
unless the skip_component parameter is true.
.Ip "\(bu skip_component" 4
.IX Item "skip_component"
If true, then the test harness will not write a component to disk for
this test.
.Sh "add_test"
.IX Subsection "add_test"
Takes the following parameters:
.Ip "\(bu name (required)" 4
.IX Item "name (required)"
The name of this test.
.Ip "\(bu description (required)" 4
.IX Item "description (required)"
What this test is testing.
.Ip "\(bu component (required)" 4
.IX Item "component (required)"
Text of the component.
.Ip "\(bu path (optional)" 4
.IX Item "path (optional)"
The path that this component should written to.  As with support
components, this path is prepended with the group's name.  If no path
is given, the value of the name parameter is used.
.Ip "\(bu call_path (optional)" 4
.IX Item "call_path (optional)"
The path that should be used to call the component.  If none is given,
then the value is the same as the path option, if that exists,
otherwise it is /<group name>/<test name>.  If a value is given, it is
still prepended by /<group name>/.
.Ip "\(bu call_args (optional)" 4
.IX Item "call_args (optional)"
The arguments that should be passed to the component, in list or hash
reference form. If none is given, no arguments are passed.
.Ip "\(bu parser_params" 4
.IX Item "parser_params"
This is a hash reference of parameters to be passed to the Parser->new
method.
.Ip "\(bu interp_params" 4
.IX Item "interp_params"
This is a hash reference of parameters to be passed to the Interp->new
method.
.Ip "\(bu interp" 4
.IX Item "interp"
Provide an \s-1HTML:\s0:Mason::Interp object to be used for the test.
.PP
One of the following three options is required:
.Ip "\(bu expect" 4
.IX Item "expect"
The text expected as a result of calling the component.  This
parameter is _not_ required when running in Create mode.
.Ip "\(bu expect_error" 4
.IX Item "expect_error"
A regex containing that will be matched against the error returned
from the component execution.
.Ip "\(bu skip_expect" 4
.IX Item "skip_expect"
This causes the component to be run but its output is ignored.
However, if the component execution causes an error this will cause
the test to fail.  This is used in a few situations where it is
necessary to just run a component as part the preparation for another
test.
.Sh "run"
.IX Subsection "run"
Run the tests in the group.
.Sh "Class methods"
.IX Subsection "Class methods"
These methods are provided since some tests may need to know these
values.
.Sh "base_path"
.IX Subsection "base_path"
The base path under which the component root and data directory for
the tests are created.
.Sh "comp_root"
.IX Subsection "comp_root"
Returns the component root directory.
.Sh "data_dir"
.IX Subsection "data_dir"
Return the data directory
.Sh "check_output ( actual => \f(CW$actual_output\fP, expect => \f(CW$expected_output\fP )"
.IX Subsection "check_output ( actual => $actual_output, expect => $expected_output )"
Given the parameters shown above, this method will check to see if the
two are equal.  If they're not equal, it will print out an error
message attempting to highlight the difference.
.SH "ADDITIONAL RUN MODES"
.IX Header "ADDITIONAL RUN MODES"
The following additional modes are available for running tests.
.Sh "Verbose mode"
.IX Subsection "Verbose mode"
To turn this on, set the environment variables \s-1MASON_VERBOSE\s0 or
\&\s-1MASON_DEBUG\s0 as true or run the tests as 'make test TEST_VERBOSE=1'.
In this mode, the \f(CW\*(C`run\*(C'\fR method will output information about tests as
they are run.  If a test fails, then it will also show the cause of
the failure.
.Sh "Debug mode"
.IX Subsection "Debug mode"
To turn this on, set the \s-1MASON_DEBUG\s0 environment variable to a true
value.  In this mode, the \f(CW\*(C`run\*(C'\fR method will print detailed
information of its actions.  This mode includes the output printed in
\&\s-1VERBOSE\s0 mode.
.Sh "Create mode"
.IX Subsection "Create mode"
If the individual tests are run from the command line with the
\&'\-\-create' flag, then instead of checking the output of a component,
the test harness will simply output its results.  This allows you to
cut and paste these results back into the test file (assuming they are
correct!).
