.\" Automatically generated by Pod::Man version 1.15
.\" Mon Apr 23 08:13:43 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "Array::IntSpan 3"
.TH Array::IntSpan 3 "perl v5.6.1" "2000-02-24" "User Contributed Perl Documentation"
.UC
.SH "NAME"
Array::IntSpan \- a Module for handling arrays using IntSpan techniques
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Array::IntSpan;
.Ve
.Vb 1
\&  my $foo = Array::IntSpan->new([0, 59, 'F'], [60, 69, 'D'], [80, 89, 'B']);
.Ve
.Vb 4
\&  print "A score of 84% results in a ".$foo->lookup(84).".\en";
\&  unless (defined($foo->lookup(70))) {
\&    print "The grade for the score 70% is currently undefined.\en";
\&  }
.Ve
.Vb 2
\&  $foo->set_range(70, 79, 'C');
\&  print "A score of 75% now results in a ".$foo->lookup(75).".\en";
.Ve
.Vb 4
\&  $foo->set_range(0, 59, undef);
\&  unless (defined($foo->lookup(40))) {
\&    print "The grade for the score 40% is now undefined.\en";
\&  }
.Ve
.Vb 3
\&  $foo->set_range(87, 89, 'B+');
\&  $foo->set_range(85, 100, 'A');
\&  $foo->set_range(100, 1_000_000, 'A+');
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Array::IntSpan\*(C'\fR brings the speed advantages of \f(CW\*(C`Set::IntSpan\*(C'\fR (written by Steven McDougall) to
arrays.  Uses include manipulating grades, routing tables, or any other situation where you have
mutually exclusive ranges of integers that map to given values.
.PP
\&\f(CW\*(C`Array::IntSpan::IP\*(C'\fR is also provided with the distribution.  It lets you use \s-1IP\s0 addresses in any
of three forms (dotted decimal, network string, and integer) for the indices into the array.  See
the \s-1POD\s0 for that module for more information.
.Sh "Installation instructions"
.IX Subsection "Installation instructions"
Standard \f(CW\*(C`Make::Maker\*(C'\fR approach or just copy \f(CW\*(C`Array/IntSpan.pm\*(C'\fR into
\&\f(CW\*(C`site/lib/Array/IntSpan.pm\*(C'\fR and \f(CW\*(C`Array/IntSpan/IP.pm\*(C'\fR into \f(CW\*(C`site/lib/Array/IntSpan/IP.pm\*(C'\fR.
.SH "METHODS"
.IX Header "METHODS"
.Sh "new"
.IX Subsection "new"
The \f(CW\*(C`new\*(C'\fR method takes an optional list of array elements.  The elements should be in the form
\&\f(CW\*(C`[start_index, end_index, value]\*(C'\fR.  They should be in sorted order and there should be no
overlaps.  The internal method \f(CW\*(C`_check_structure\*(C'\fR will be called to verify the data is correct.
If you wish to avoid the performance penalties of checking the structure, you can use
\&\f(CW\*(C`Data::Dumper\*(C'\fR to dump an object and use that code to reconstitute it.
.Sh "set_range"
.IX Subsection "set_range"
This method takes three parameters \- the \f(CW\*(C`start_index\*(C'\fR, the \f(CW\*(C`end_index\*(C'\fR, and the \f(CW\*(C`value\*(C'\fR.  If
you wish to erase a range, specify \f(CW\*(C`undef\*(C'\fR for the \f(CW\*(C`value\*(C'\fR.  It properly deals with overlapping
ranges and will replace existing data as appropriate.  If the new range lies after the last
existing range, the method will execute in O(1) time.  If the new range lies within the existing
ranges, the method executes in O(n) time, where n is the number of ranges.  The code is not
completely optimized and will make up to three calls to \f(CW\*(C`splice\*(C'\fR if the new range intersects with
existing ranges.  It does not consolidate contiguous ranges that have the same \f(CW\*(C`value\*(C'\fR.
.PP
If you have a large number of inserts to do, it would be beneficial to sort them first.  Sorting
is O(n \fIlg\fR\|(n)), and since appending is O(1), that will be considerably faster than the O(n^2) time
for inserting n unsorted elements.
.PP
The method returns \f(CW\*(C`0\*(C'\fR if there were no overlapping ranges and \f(CW\*(C`1\*(C'\fR if there were.
.Sh "lookup"
.IX Subsection "lookup"
This method takes as a single parameter the \f(CW\*(C`index\*(C'\fR to look up.  If there is an appropriate range,
the method will return the associated value.  Otherwise, it returns \f(CW\*(C`undef\*(C'\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
Toby Everett, teverett@alascom.att.com
