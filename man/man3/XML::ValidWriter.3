.\" Automatically generated by Pod::Man version 1.15
.\" Mon Apr 23 13:39:31 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "XML::ValidWriter 3"
.TH XML::ValidWriter 3 "perl v5.6.1" "2000-12-22" "User Contributed Perl Documentation"
.UC
.SH "NAME"
\&\s-1XML:\s0:ValidWriter \- \s-1DOCTYPE\s0 driven valid \s-1XML\s0 output
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 8
\&   ## As a normal perl object:
\&   $writer = XML::ValidWriter->new(
\&      DOCTYPE => $xml_doc_type,
\&      OUTPUT => \e*FH
\&   ) ;
\&   $writer->startTag( 'b1' ) ;
\&   $writer->startTag( 'c2' ) ;
\&   $writer->end ;
.Ve
.Vb 5
\&   ## Writing to a scalar:
\&   $writer = XML::ValidWriter->new(
\&      DOCTYPE => $xml_doc_type,
\&      OUTPUT => \e$buf
\&   ) ;
.Ve
.Vb 6
\&   ## Or, in scripting mode:
\&   use XML::Doctype         NAME => a, SYSTEM_ID => 'a.dtd' ;
\&   use XML::ValidWriter qw( :all :dtd_tags ) ;
\&   b1 ;                # Emits <a><b1>
\&   c2( attr=>"val" ) ; # Emits </b1><b2><c2 attr="val">
\&   endAllTags ;        # Emits </c2></b2></a>
.Ve
.Vb 2
\&   ## If you've got an XML::Doctype object handy:
\&   use XML::ValidWriter qw( :dtd_tags ), DOCTYPE => $doctype ;
.Ve
.Vb 3
\&   ## If you've saved a preparsed DTD as a perl module
\&   use FooML::Doctype::v1_0001 ;
\&   use XML::ValidWriter qw( :dtd_tags ) ;
.Ve
.Vb 8
\&   #
\&   # This all assumes that the DTD contains:
\&   #
\&   #   <!ELEMENT a ( b1, b2?, b3* ) >
\&   #      <!ATTLIST   a aa1 CDATA       #REQUIRED >
\&   #   <!ELEMENT b1 ( c1 ) >
\&   #   <!ELEMENT b2 ( c2 ) >
\&   #
.Ve
.SH "STATUS"
.IX Header "STATUS"
Alpha.  Use and patch, don't depend on things not changing drastically.
.PP
Many methods supplied by \s-1XML:\s0:Writer are not yet supplied here.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module uses the \s-1DTD\s0 contained in an \s-1XML:\s0:Doctype to enable compile-
and run-time checks of \s-1XML\s0 output validity.  It also provides methods and
functions named after the elements mentioned in the \s-1DTD\s0.  If an
\&\s-1XML:\s0:ValidWriter uses a \s-1DTD\s0 that mentions the element type \s-1TABLE\s0, that
instance will provide the methods
.PP
.Vb 4
\&   $writer->TABLE( $content, ...attrs... ) ;
\&   $writer->start_TABLE( ...attrs... ) ;
\&   $writer->end_TABLE() ;
\&   $writer->empty_TABLE( ...attrs... ) ;
.Ve
\&.  These are created for undeclared elements\*(--those elements not explicitly
declared with an <!ELEMENT ..> declaration\*(--as well.  If an element
type name conflicts with a method, it will not override the internal method.
.PP
When an \s-1XML:\s0:Doctype is parsed, the name of the doctype defines the root
node of the document.  This name can be changed, though, see the XML::Doctype manpage
for details.
.PP
In addition to the object-oriented \s-1API\s0, a function \s-1API\s0 is also provided.
This allows you to import most of the methods of \s-1XML:\s0:ValidWriter as functions
using standard import specifications:
.PP
.Vb 1
\&   use XML::ValidWriter qw( :all ) ; ## Could list function names instead
.Ve
\&\f(CW\*(C`:all\*(C'\fR does not import the functions named after elements mentioned in
the \s-1DTD\s0, you need to import those tags using \f(CW\*(C`:dtd_tags\*(C'\fR:
.PP
.Vb 2
\&   use XML::Doctype NAME => 'foo', SYSTEM_ID => 'fooml.dtd' ;
\&   use XML::ValidWriter qw( :all :dtd_tags ) ;
.Ve
or
.PP
.Vb 3
\&   BEGIN {
\&      $doctype = XML::Doctype->new( ... ) ;
\&   }
.Ve
.Vb 1
\&   use XML::ValidWriter DOCTYPE => $doctype, qw( :all :dtd_tags ) ;
.Ve
.Sh "\s-1XML:\s0:Writer \s-1API\s0 compatibility"
.IX Subsection "XML::Writer API compatibility"
Much of the interface is patterned
after \s-1XML:\s0:Writer so that it can possibly be used as a drop-in
replacement.  It will take awhile before this module emulates enough
of \s-1XML:\s0:Writer to be a drop-in replacement in situations where the
more advanced \s-1XML:\s0:Writer methods are used.  If you find you need
a method not suported here, write it and send it in!
.PP
This was not derived from \s-1XML:\s0:Writer because \s-1XML:\s0:Writer does not
expose it's stack.  Even if it did, it's might be difficult to store
enough state in it's stack.
.PP
Unlike \s-1XML:\s0:Writer, this does not call in all of the \s-1IO:\s0:* family, and
method dispatch should be faster.  DTD-specific methods are also supported
(see the AUTOLOAD entry elsewhere in this document).
.Sh "Quick and Easy Unix Filter Apps"
.IX Subsection "Quick and Easy Unix Filter Apps"
For quick applications that provide Unix filter application
functionality, \s-1XML:\s0:ValidWriter and \s-1XML:\s0:Doctype cooperate to allow you
to
.Ip "1" 4
.IX Item "1"
Parse a \s-1DTD\s0 at compile-time and set that as the default \s-1DTD\s0 for
the current package.  This is done using the
.Sp
.Vb 1
\&   use XML::Doctype NAME => 'FooML, SYSTEM_ID => 'fooml.dtd' ;
.Ve
syntax.
.Ip "2" 4
.IX Item "2"
Define and export a set of functions corresponding to start and end tags for
all declared and undeclared ELEMENTs in the \s-1DTD\s0.  This is done by using
the \f(CW\*(C`:dtd_tags\*(C'\fR export symbol like so:
.Sp
.Vb 2
\&   use XML::Doctype     NAME => 'FooML, SYSTEM_ID => 'fooml.dtd' ;
\&   use XML::ValidWriter qw(:dtd_tags) ;
.Ve
If the elements a, b_c, and d-e are referred to in the \s-1DTD\s0, the following
functions will be exported:
.Sp
.Vb 3
\&   a()        end_a()       # like startTag( 'a', ... ) and endTag( 'a' )
\&   b_c()      end_b_c()
\&   d_e()      end_d_e()     {'d-e'}()     {'end_d-e'}()
.Ve
These functions emit only tags, unlike the similar functions found
in \s-1CGI\s0.pm and \s-1XML:\s0:Generator, which also allow you to pass content
in as parameters.
.Sp
See below for details on conflict resolution in the mapping of entity
names containing /\eW/ to Perl subroutine names.
.Sp
If the elements declared in the \s-1DTD\s0 might conflict with functions
in your package namespace, simple put them in some safe namespace:
.Sp
.Vb 3
\&   package FooML ;
\&   use XML::Doctype         NAME => 'FooML', SYSTEM_ID => 'fooml.dtd' ;
\&   use XML::ValidWriter qw(:dtd_tags) ;
.Ve
.Vb 1
\&   package Whatever ;
.Ve
The advantage of importing these subroutine names is that perl
can then detect use of unknown tags at compile time.
.Sp
If you don't want to use the default \s-1DTD\s0, use the \f(CW\*(C`\-dtd\*(C'\fR option:
.Sp
.Vb 2
\&   BEGIN { $dtd = XML::Doctype->new( .... ) }
\&   use XML::ValidWriter qw(:dtd_tags), -dtd => \e$dtd ;
.Ve
.Ip "3" 4
.IX Item "3"
Use the default \s-1DTD\s0 to validate emitted \s-1XML\s0.  \fIstartTag()\fR and \fIendTag()\fR
will check the tag being emitted against the list of currently open
tags and either emit a minimal set of missing end and start tags
necessary to achieve document validity or produce errors or warnings.
.Sp
Since the functions created by the \f(CW\*(C`:dtd_tags\*(C'\fR export symbol are wrappers
around \fIstartTag()\fR and \fIendTag()\fR, they provide this functionality as well.
.Sp
So, if you have a \s-1DTD\s0 like
.Sp
.Vb 1
\&   <!ELEMENT a ( b1, b2?, b3* ) >
.Ve
.Vb 1
\&       <!ATTLIST   a aa1 CDATA       #REQUIRED >
.Ve
.Vb 3
\&   <!ELEMENT b1 ( c1 ) >
\&   <!ELEMENT b2 ( c2 ) >
\&   <!ELEMENT b3 ( c3 ) >
.Ve
you can do this:
.Sp
.Vb 2
\&   use XML::Doctype     NAME => 'a', SYSTEM_ID => 'a.dtd' ;
\&   use XML::ValidWriter ':dtd_tags' ;
.Ve
.Vb 1
\&   getDoctype->element_decl('a')->attdef('aa1')->default_on_write('foo') ;
.Ve
.Vb 10
\&   a ;
\&      b1 ;
\&         c1 ;
\&         end_c1 ;
\&      end_b1 ;
\&      b3 ;
\&         c3( -attr => val ) ;
\&         end_c3 ;
\&      end_b3 ;
\&   end_a ;
.Ve
and emit a document like
.Sp
.Vb 8
\&   <a aa1="foo">
\&      <b1>
\&         <c1 />
\&      </b1>
\&      <b3>
\&         <c3 attr => "val" />
\&      </b3>
\&   </a>
.Ve
\&.
.SH "OUTPUT OPTIMIZATION"
.IX Header "OUTPUT OPTIMIZATION"
\&\s-1XML\s0 is a very simple langauge and does not offer a lot of room for
optimization.  As the spec says \*(L"Terseness in \s-1XML\s0 markup is of
minimal importance.\*(R"  \s-1XML:\s0:ValidWriter does optimize the following
on output:
.PP
\&\f(CW\*(C`<a...></a>\*(C'\fR   becomes '<a... />'
.PP
Spurious emissions of \f(CW\*(C`]]><![CDATA[\*(C'\fR are supressed.
.PP
\&\s-1XML:\s0:ValidWriter chooses whether or not to use a <![CDATA[...]]> section
or simply escape '<' and '&'.  If you are emitting content for
an element in multiple 
calls to the characters entry elsewhere in this document, the first call decides whether or not to use
\&\s-1CDATA\s0, so it's to your advantage to emit as much in the first call
as possible.  You can do
.PP
.Vb 1
\&   characters( @lots_of_segments ) ;
.Ve
if it helps.
.SH "METHODS AND FUNCTIONS"
.IX Header "METHODS AND FUNCTIONS"
All of the routines in this module can be called as either functions
or methods unless otherwise noted.
.PP
To call these routines as functions use either the \s-1DOCTYPE\s0 or
:dtd_tags options in the parameters to the use statement:
.PP
.Vb 2
\&   use XML::ValidWriter DOCTYPE => XML::Doctype->new( ... ) ;
\&   use XML::ValidWriter qw( :dtd_tags ) ;
.Ve
This associates an \s-1XML:\s0:ValidWriter and an \s-1XML:\s0:Doctype with the
package.  These are used by the routines when called as functions.
.Ip "new" 4
.IX Item "new"
.Vb 1
\&   $writer = XML::ValidWriter->new( DTD => $dtd, OUTPUT => \e*FH ) ;
.Ve
Creates an \s-1XML:\s0:ValidWriter.
.Sp
The value passed for \s-1OUTPUT\s0 may be:
.RS 4
.Ip "a \s-1SCALAR\s0 ref" 4
.IX Item "a SCALAR ref"
if you want to direct output to append to a scalar.  This scalar is
truncated whenever the \s-1XML:\s0:ValidWriter object is \fIreset()\fR or
\&\fIDESTROY()\fRed
.Ip "a file handle glob ref or a reference to an \s-1IO\s0 object" 4
.IX Item "a file handle glob ref or a reference to an IO object"
\&\s-1XML:\s0:ValidWriter does not load \s-1IO\s0.  This is
the only mode compatible with \s-1XML:\s0:Writer.
.Ip "a file name" 4
.IX Item "a file name"
A simple scalar is taken to be a filename to be created or truncated
and emitted to.  This file will be closed when the \s-1XML:\s0:ValidWriter object
is reset or deatroyed.
.RE
.RS 4
.Sp
\&\s-1NOTE:\s0 if you leave \s-1OUTPUT\s0 undefined, then the currently \fIselect()\fRed
output is used at each emission (ie calling \fIselect()\fR can alter the
destination mid-stream).  This eases writing command line filter
applications, the \fIselect()\fR interaction is unintentional, and please
don't depend on it.  I reserve the right to cache the \fIselect()\fRed
filehandle at creation time or at time of first emission at some
point in the future.
.RE
.Ip "import" 4
.IX Item "import"
Can't think of why you'd call this method directly, it gets called
when you use this module:
.Sp
.Vb 1
\&   use XML::ValidWriter qw( :all ) ;
.Ve
In addition to the normal functionality of exporting functions like
\&\fIstartTag()\fR and \fIendTag()\fR, \s-1XML:\s0:ValidWriter's \fIimport()\fR can create
functions corresponding to all elements in a \s-1DTD\s0.  This is done using
the special \f(CW\*(C`:dtd_tags\*(C'\fR export symbol.  For example,
.Sp
.Vb 2
\&   use XML::Doctype     NAME => 'FooML', SYSTEM_ID => 'fooml.dtd' ;
\&   use XML::ValidWriter qw( :dtd_tags ) ;
.Ve
where fooml.dtd referse to a tag type of 'blurb' causes these
functions to be imported:
.Sp
.Vb 4
\&   blurb()         # calls defaultWriter->startTag( 'blurb', @_ ) ;
\&   blurb_element() # calls defaultWriter->dataElement( 'blurb', @_ ) ;
\&   empty_blurb()   # calls defaultWriter->emptyTag( 'blurb', @_ ) ;
\&   end_blurb()     # calls defaultWriter->endTag( 'blurb' ) ;
.Ve
The range of characters for element types is much larger than
the range of characters for bareword perl subroutine names, which
are limited to [a-zA-Z0\-9_].  In this case, \s-1XML:\s0:ValidWriter will
export an oddly named function that you can use a symbolic reference
to call (you will need \f(CW\*(C`no strict 'refs' ;\*(C'\fR if you are doing
a \f(CW\*(C`use strict ;\*(C'\fR):
.Sp
.Vb 1
\&   &{"space-1999:moonbase"}( ...attributes ... ) ;
.Ve
\&.  \s-1XML:\s0:ValidWriter will also try to fold the name in to bareword
space by converting /\eW/ symbols to '_'.
If the resulting function name,
.Sp
.Vb 1
\&   space_1999_moonbase( ...attributes... ) ;
.Ve
has not been generated and is not the name of an element type, then
it will also be exported.
.Sp
If you are using a \s-1DTD\s0 that might introduce function names that
conflict with existing ones, simple export them in to their own
namespace:
.Sp
.Vb 1
\&   package ML ;
.Ve
.Vb 2
\&   use XML::Doctype     NAME => 'foo', SYSTEM_ID => 'fooml.dtd' ;
\&   use XML::ValidWriter qw( :dtd_tags ) ;
.Ve
.Vb 1
\&   package main ;
.Ve
.Vb 1
\&   use XML::ValidWriter qw( :all ) ;
.Ve
.Vb 4
\&   ML::foo ;
\&   ML::c2 ;
\&   ML::c1 ;
\&   ML::end_a ;
.Ve
I gave serious thought to converting ':' in element names to '::' in
function declarations, which might work well in the functions-in-their-own-
namespace case, but not in the default case, since Perl does not
(yet) have relative namespaces. Another alternative is to allow a
mapping of \s-1XML\s0 namespaces to Perl namespaces to be done.
.Ip "characters" 4
.IX Item "characters"
.Vb 2
\&   characters( "escaped text", "& more" ) ;
\&   $writer->characters( "escaped text", "& more" ) ;
.Ve
Emits character data.  Character data will be escaped before output, by either
transforming '<' and '&' to &lt; and &amp;, or by enclosing in a
\&'\f(CW\*(C`<![CDATA[...]]>\*(C'\fR' bracket, depending on which will be more
human-readable, according to the module.
.Ip "dataElement" 4
.IX Item "dataElement"
.Vb 6
\&   $writer->dataElement( $tag ) ;
\&   $writer->dataElement( $tag, $content ) ;
\&   $writer->dataElement( $tag, $content, attr1 => $val1, ... ) ;
\&   dataElement( $tag ) ;
\&   dataElement( $tag, $content ) ;
\&   dataElement( $tag, $content, attr1 => $val1, ... ) ;
.Ve
Does the equivalent to
.Sp
.Vb 4
\&   ## Split the optional args in to attributes and elements arrays.
\&   $writer->startTag( $tag, @attributes ) ;
\&   $writer->characters( $content ) ;
\&   $writer->endTag( $tag ) ;
.Ve
This function is exportable as \fIdataElement()\fR, and is also exported
for each element 'foo' found in the \s-1DTD\s0 as \fIfoo()\fR.
.Ip "defaultWriter" 4
.IX Item "defaultWriter"
.Vb 2
\&   $writer = defaultWriter ;       ## Not a method!
\&   $writer = defaultWriter( 'Foo::Bar' ) ;
.Ve
Returns the default \s-1XML:\s0:ValidWriter for the given package, or the current
package if none is specified.  This is useful for getting at
methods like \f(CW\*(C`reset\*(C'\fR that are not also functions.
.Sp
Croaks if no default writer has been defined (see the import entry elsewhere in this document).
.Ip "doctype" 4
.IX Item "doctype"
.Vb 2
\&   # Using the writer's associated DTD:
\&   doctype ;
.Ve
.Vb 4
\&   # Ignoring the writer's associated DTD:
\&   doctype( $type ) ;
\&   doctype( $type, undef, $system ) ;
\&   doctype( $type, $public, $system ) ;
.Ve
.Vb 2
\&   $writer->doctype ;
\&   ...etc
.Ve
See the internalDoctype entry elsewhere in this document to emit the entire \s-1DTD\s0 in the document.
.Sp
This checks to make sure that no doctype or elements have been emitted.
.Sp
A warning is emitted if standalone=\*(L"yes\*(R" was specified in the <?xml..?>
declaration and a system id is specified.  This is extremely likely to
be an error.  If you need to silence the warning, write me (see below).
.Sp
Passing '' or '0' (zero) as a \f(CW$public_id\fR or as a \f(CW$system_id\fR also generates
a warning, as these are extremely likely to be errors.
.Ip "emptyTag" 4
.IX Item "emptyTag"
.Vb 2
\&   emptyTag( $tag[, attr1 => $val1... ] ) ;
\&   $writer->emptyTag( $tag[, attr1 => $val1... ] ) ;
.Ve
Emits an empty tag like '<foo />'.  The extra space is for compatibility
with \s-1XHTML\s0.
.Ip "endTag" 4
.IX Item "endTag"
.Vb 4
\&   endTag ;
\&   endTag( 'a' ) ;
\&   $writer->endTag ;
\&   $writer->endTag( 'a' ) ;
.Ve
Prints one or more end tags.  The tag name is optional and defaults to the
most recently emitted start tag if not present.
.Sp
This will emit as many close tags as necessary to close the supplied tag
name, or will emit an error if the tag name specified is not open in the
output document.
.Ip "end" 4
.IX Item "end"
.Vb 1
\&   $writer->end ;      # Not a function!!
.Ve
Emits all necessary end tags to close the document.  Available as a method
only, since 'end' is a little to generic to be exported as a function
name, \s-1IMHO\s0.  See 'endAllTags' for the plain function equivalent function.
.Ip "endAllTags" 4
.IX Item "endAllTags"
.Vb 2
\&   endAllTags ;
\&   $writer->endAllTags ;
.Ve
A plain function that emits all necessart end tags to close the document.
Corresponds to the method \f(CW\*(C`end\*(C'\fR, but is exportable as a function/
.Ip "exportDTDTags" 4
.IX Item "exportDTDTags"
.Vb 2
\&   $writer->exportDTDTags() ;
\&   $writer->exportDTDTags( $to_pkg ) ;
.Ve
Exports the tags found in the \s-1DTD\s0 to the caller's namespace.
.Ip "getDataMode" 4
.IX Item "getDataMode"
.Vb 2
\&   $m = getDataMode ;
\&   $m = $writer->getDataMode ;
.Ve
Returns \s-1TRUE\s0 if the writer is in \s-1DATA_MODE\s0.
.Ip "getDoctype" 4
.IX Item "getDoctype"
.Vb 2
\&   $dtd = getDoctype ;
\&   $dtd = $writer->getDoctype ;
.Ve
This is used to get the writer's \s-1XML:\s0:Doctype object.
.Ip "getOutput" 4
.IX Item "getOutput"
.Vb 2
\&   $fh = getOutput ;
\&   $fh = $writer->getOutput ;
.Ve
Gets the filehandle an \s-1XML:\s0:ValidWriter sends output to.
.Ip "rawCharacters" 4
.IX Item "rawCharacters"
.Vb 2
\&   rawCharacters( "<unescaped text>", "& more text" ) ;
\&   $writer->rawCharacters( "<unescaped text>", "& more text" ) ;
.Ve
This allows you to emit raw text without any escape processing.  The text
is not examined for tags, so you can invalidate your document and even
corrupt it's well-formedness.
.Ip "reset" 4
.IX Item "reset"
.Vb 1
\&   $writer->reset ;        # Not a function!
.Ve
Resets a writer to be initialized, but not have emitted anything.
.Sp
This is useful if you need to abort output, but want to reuse the
\&\s-1XML:\s0:ValidWriter.
.Ip "setDataMode" 4
.IX Item "setDataMode"
.Vb 2
\&   setDataMode( 1 ) ;
\&   $writer->setDataMode( 1 ) ;
.Ve
Enable or disable data mode.
.Ip "setDoctype" 4
.IX Item "setDoctype"
.Vb 2
\&   setDoctype $doctype ;
\&   $writer->setDoctype( $doctype ) ;
.Ve
This is used to set the doctype object.
.Ip "select_xml" 4
.IX Item "select_xml"
.Vb 1
\&   select_xml OUTHANDLE ;  # Nnot a method!!
.Ve
Selects a filehandle to send the \s-1XML\s0 output to when not using the object
oriented interface.  This is similar to perl's builtin select,
but only affects startTag and endTag functions, (not methods).
.Sp
This is only needed if you want to interleave output to the selected 
output files (usually \s-1STDOUT\s0, see the select entry in the perlfunc manpage and to an
\&\s-1XML\s0 file on another filehandle.
.Sp
If you want to redirect all output (yours and \s-1XML:\s0:Writer's) to the same
file, just use Perl's built-in \fIselect()\fR, since startTag and endTag
emit to the currently selected filehandle by default.
.Sp
Like select, this returns the old value.
.Ip "setOutput" 4
.IX Item "setOutput"
.Vb 2
\&   setOutput( \e*FH ) ;
\&   $writer->setOutput( \e*FH ) ;
.Ve
Sets the filehandle an \s-1XML:\s0:ValidWriter sends output to.
.Ip "startTag" 4
.IX Item "startTag"
.Vb 3
\&   startTag( 'a', attr => val ) ;  # use default XML::ValidWriter for
\&                                   # current package.
\&   $writer->startTag( 'a', attr => val ) ;
.Ve
Emits a named start tag with optional attributes.  If the named tag
cannot be a child of the most recently started tag, then any tags
that need to be opened between that one and the named tag are opened.
.Sp
If the named tag cannot be enclosed within the most recently opened
tag, no matter how deep, then \fIstartTag()\fR tries to end as few started tags
as necessary to allow the named tag to be emitted within a tag already on the
stack.
.Sp
This warns (once) if no <?xml?> declaration has been emitted.  It does not
check to see if a <!DOCTYPE...> has been emitted.  It dies if an attempt
is made to emit a second root element.
.Ip "xmlDecl([[$encoding][, \f(CW$standalone\fR])" 4
.IX Item "xmlDecl([[$encoding][, $standalone])"
.Vb 4
\&   xmlDecl ;
\&   xmlDecl( "UTF-8" ) ;
\&   xmlDecl( "UTF-8", "yes" ) ;
\&   $writer->xmlDecl( ... ) ;
.Ve
Emits an \s-1XML\s0 declaration.  Must be called before any of the other
output routines.
.Sp
If \f(CW$encoding\fR is not defined, it is not output.  This is slightly
different than \s-1XML:\s0:Writer, which outputs '\s-1UTF-8\s0' if you pass in
undef, 0, or ''.
.Sp
If \f(CW$encoding\fR is '' or 0, then it is output as "\*(L" or \*(R"0"
and a warning is generated.
.Sp
If \f(CW$standalone\fR is defined and is not 'no', 0, or '', it is output as 'yes'.
If it is 'no', then it is output as 'no'.  If it's 0 or '' it is not
output.
.Ip "\s-1AUTOLOAD\s0" 4
.IX Item "AUTOLOAD"
This function is called whenever a function or method is not found
in \s-1XML:\s0:ValidWriter.
.Sp
If it was a method being called, and the desired method name is a start
or end tag found in the \s-1DTD\s0, then a method is cooked up on the fly.
.Sp
These methods are slower than normal methods, but they are cached so
that they don't need to be recompiled.  The speed penalty is probably
not significant since they do I/O and are thus usually orders of
magnitude slower than normal Perl methods.
.Ip "\s-1DESTROY\s0" 4
.IX Item "DESTROY"
\&\s-1DESTROY\s0 is called when an \s-1XML:\s0:ValidWriter is cleaned up.  This is used
to automatically close all tags that remain open.  This will not work
if you have closed the output filehandle that the ValidWriter was
using.
.Sp
This method will also warn if anything was emitted bit no root node was
emitted.  This warning can be silenced by calling
.Sp
.Vb 1
\&   $writer->reset() ;
.Ve
when you abandon output.
.SH "AUTHOR"
.IX Header "AUTHOR"
Barrie Slaymaker <barries@slaysys.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This module is Copyright 2000, Barrie Slaymaker.  All rights reserved.
.PP
This module is licensed under the \s-1GPL\s0, version 2.  Please contact me if this
does not suit your needs.
