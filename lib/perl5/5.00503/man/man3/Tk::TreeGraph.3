.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH TreeGraph 3 "perl 5.005, patch 03" "15/May/2000" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
Tk::TreeGraph \- Tk widget to draw a tree in a Canvas
.SH "SYNOPSIS"
.PP
.Vb 2
\& use Tk ;
\& use Tk::TreeGraph ;
.Ve
.Vb 1
\& use strict ;
.Ve
.Vb 1
\& my $mw = MainWindow-> new ;
.Ve
.Vb 1
\& my $tg = $mw -> Scrolled('TreeGraph') ->pack(-expand => 1, -fill => 'both');
.Ve
.Vb 1
\& $tg -> addLabel (text => 'some tree');
.Ve
.Vb 1
\& my $ref = [qw/some really_silly text/];
.Ve
.Vb 5
\& $tg -> addNode 
\&  (
\&   nodeId => '1.0', 
\&   text => $ref
\&  ) ;
.Ve
.Vb 6
\& # EITHER add the arrow and the node
\& $tg -> addDirectArrow
\&  (
\&   from => '1.0', 
\&   to => '1.1'
\&  ) ;
.Ve
.Vb 5
\& $tg->addNode
\&  (
\&   nodeId => '1.1',
\&   text => ['some','text']
\&  ) ;
.Ve
.Vb 8
\& # OR add a node after another one, in this case the widget 
\& # will draw the arrow
\& $tg->addNode
\&  (
\&   after =>'1.0',
\&   nodeId => '1.1',
\&   text => ['some','text']
\&  );
.Ve
.Vb 7
\& $tg->arrowBind
\&  (
\&   button => '<1>',
\&   color => 'orange',
\&   command =>  sub{my %h = @_;
\&                   warn "clicked 1 arrow $h{from} -> $h{to}\en";}
\&  );
.Ve
.Vb 7
\& $tg->nodeBind
\&  (
\&   button => '<2>',
\&   color => 'red',
\&   command => sub {my %h = @_;
\&                   warn "clicked 2 node $h{nodeId}\en";}
\&  );
.Ve
.Vb 2
\& $tg->command( on => 'arrow', label => 'dummy 2', 
\&                 command => sub{warn "arrow menu dummy2\en";});
.Ve
.Vb 2
\& $tg->arrowBind(button => '<3>', color => 'green', 
\&              command => sub{$tg->popupMenu(@_);});
.Ve
.Vb 2
\& $tg->command(on => 'node', label => 'dummy 1', 
\&                 command => sub{warn "node menu dummy1\en";});
.Ve
.Vb 2
\& $tg->nodeBind(button => '<3>', color => 'green', 
\&              command => sub{$tg->popupMenu(@_);});
.Ve
.Vb 3
\& # adjust scrolled area with some margin
\& my @array = $tg->bbox("all") ;
\& $tg->configure(-scrollregion => [0, 0, $array[2] + 50, $array[3] + 50 ]);
.Ve
.Vb 1
\& MainLoop ; # Tk's
.Ve
.SH "DESCRIPTION"
Tk::TreeGraph is a Canvas specialized to draw trees on a Canvas using
arrows and nodes. A node is simply some text imbedded in a rectangular shape.
.PP
TreeGraph is able to draw the following items:
.Ip "\(bu" 4
node: some text in a rectangular shape.
.Ip "\(bu" 4
direct arrow: an arrow to go from one node to the following one.
.Ip "\(bu" 4
slanted arrow: an arrow to make a new branch.
.Ip "\(bu" 4
shortcuts arrow: an arrow to represent a shortcut between 2 nodes from
different branches.
.PP
TreeGraph also provides :
.Ip "\(bu" 4
a binding on nodes on button 1 to \*(L'select\*(R' them.
.Ip "\(bu" 4
Methods to bind nodes and arrows on user's call-back.
.SH "CAVEATS"
You might say that the tree is a weird tree since it is drawn downward
and assymetric and adding branches leaves a some void between them.
.PP
You'd be right. I'm not a specialist in tree drawing algorithms but
the crude algorithm used here works quite fine with drawing id trees
for VCS system. But as usual, I'm always listening for suggestions or
even better, patches ;\-) .
.PP
Note that the tree MUST be drawn from top to bottom and from left to
right. Unless you may get a very confusing drawing of a tree.
.SH "About Scrolling"
First versions of TreeGraph used to tinker with a \-scrollregion option
each time addNode was called. This was not consistent since the
scrollbars are added by the user when calling TreeGraph (using
\fIScrolled\fR\|('TreeGraph')). Hence from now on, it will be the
responsability of the user to set a satisfying \-scrollregion.
.PP
The user may write this after all nodes are drawn to set the scrollregion :
.PP
.Vb 2
\& my @array = $tg->bbox("all") ;
\& $tg->configure(-scrollregion => [0, 0, $array[2] + 50, $array[3] + 50 ]);
.Ve
Furthermore, since configure will called only once, the resulting code
will be faster.
.SH "Widget Options"
.Ip "\(bu" 4
-nodeColor: Color of the node rectangle.
.Ip "\(bu" 4
-nodeTextColor: Color of the text within the nodes
.Ip "\(bu" 4
-labelColor
.Ip "\(bu" 4
-arrowColor
.Ip "\(bu" 4
-shortcutColor: Color of the shortcut arrow (default \*(L'orange')
.Ip "\(bu" 4
-shortcutStyle: Style of the shortcut arrow. The arrow can be drawn as 
a \*(L'straight\*(R' arrow or a \*(L'spline\*(R'. (default \*(L'straight')
.Ip "\(bu" 4
-nodeTag: boolean. By default the nodeId is added at the beginning of
the node text.
.Ip "\(bu" 4
-arrowDeltaY: length of direct arrows (downward). default 40
.Ip "\(bu" 4
-branchSeparation: minimum width between 2 branches of the tree (default 120) 
.Ip "\(bu" 4
-x_start: x coordinate of the root of the tree. (default 100)
.Ip "\(bu" 4
-y_start: y coordinate of the root of the tree.(default 100)
.SH "Drawing Methods added to Canvas"
You draw the tree node after node with addNode using the \*(L'after\*(R' 
parameter. Then the object will infer the kind of arrow needed between the
2 nodes. Using the \*(L'after\*(R' parameter, you no longer need
to call youself the addSlantedArrow or addDirectArrow methods.
.Sh "\fIaddNode\fR\|(...)"
.Ip "\(bu" 4
nodeId: string to identify this node.
.Ip "\(bu" 4
text: text string or array ref. This text will be written inside the rectangle
.Ip "\(bu" 4
after: Either a [x,y] array ref setting the coordinate of the root
of the tree (this can be used to draw the a first tree in the canvas and/or
to draw a second tree in the canvas). If after is a nodeId, an arrow
(direct or slanted) will be drawn from the \*(L'after\*(R' node to this new node.
.PP
Will add a new node (made of a rectangle with the text inside). 
.PP
Note that this method will add the nodeId on top of the passed text
('text\*(R' parameter).
.Sh "\fImodifyNode\fR\|(...)"
.Ip "\(bu" 4
nodeId: string to identify the node to modify (mandatory).
.Ip "\(bu" 4
text: text string or array ref. This text will be overwritten inside
the rectangle. Note that modifyNode will refuse to change the text if
the new text has more lines than the older text (because the text
would not fit in the rectangle).
.Ip "\(bu" 4
nodeColor: new color of the outline of the rectangle.
.Ip "\(bu" 4
nodeTextColor: new color of the text of the node.
.Ip "\(bu" 4
nodeFill: new color filling the rectangle.
.PP
Will modify an existing node. Note that the geometry of the node will not
be changed.
.Sh "\fIflashNode\fR\|(...)"
.Ip "\(bu" 4
nodeId: string to identify the node to modify (mandatory).
.Ip "\(bu" 4
time: time in ms between each flash (default 500 ms)
.Ip "\(bu" 4
nodeColor: new color of the outline of the rectangle.
.Ip "\(bu" 4
nodeTextColor: new color of the text of the node.
.Ip "\(bu" 4
nodeFill: new color filling the rectangle.
.PP
Will make an existing node flash. Calling a second time this method on
a node will make the flashing stop.
.Sh "\fIaddDirectArrow\fR\|(...)"
You can use this method if you want to change the default aspect of
the direct arrow. In this case do not use the \*(L'after\*(R' parameter of the
\fIaddNode()\fR method.
.Ip "\(bu" 4
from: node id where the arrow starts
.Ip "\(bu" 4
to: node id where the arrow ends
.PP
Add a new straight (i.e. vertical) arrow starting from a node. Note that
the \*(L'from\*(R' nodeId must be defined. The \*(L'to\*(R' nodeId must \s-1NOT\s0 be defined.
(Remember that you must draw the tree from top to bottom)
.Sh "\fIaddSlantedArrow\fR\|(...)"
You can use this method if you want to change the default aspect of
the slanted arrow. In this case do not use the \*(L'after\*(R' parameter of the
\fIaddNode()\fR method.
.PP
Parameters are:
.Ip "\(bu" 4
from: node id where the arrow starts
.Ip "\(bu" 4
to: node id where the arrow ends
.PP
Add a new branch connecting node \*(L'id\*(R' to node \*(L'id2\*(R'.  Note that the
\&'from\*(R' nodeId must be defined. The \*(L'to\*(R' nodeId must \s-1NOT\s0 be defined.
(Remember that you must draw the tree from left to right)
.Sh "\fIaddLabel\fR\|(...)"
Put some text on the top of the graph.
.Ip "\(bu" 4
text: text to be inserted on the top of the graph.
.Sh "\fIaddShortcutInfo\fR\|(...)"
.Ip "\(bu" 4
from: node id where the arrow starts
.Ip "\(bu" 4
to: node id where the arrow ends
.PP
Declare that a shortcut arrow will be drawn from node \*(L'arrow_start\*(R' and 
\&'arrow_end\*(R'.
.Sh "\fIaddAllShortcuts()\fR"
This method is to be called once all nodes, direct arrow and branch arrows
are drawn and all relevant calls to addShortcutInfo are done.
 
It will draw shortcut arrows between the ids declared with 
the addShortcutInfo method.
.Sh "\fIclear()\fR"
Clear the graph.
.SH "Management methods"
.Sh "\fInodeBind\fR\|(...)"
.Ip "\(bu" 4
button: button name to bind (e.g. \*(L'<1>') 
.Ip "\(bu" 4
color: color of the node when it is clicked on.
.Ip "\(bu" 4
command: sub ref 
.PP
Bind the \*(L'button\*(R' on all nodes. When \*(L'button\*(R' is clicked, the node
text color will change to \*(L'color\*(R' and the callback sub will be called
with these parameters: 
.PP
.Vb 1
\& (on => 'node', nodeId => $nodeId)
.Ve
.Sh "\fIarrowBind\fR\|(...)"
.Ip "\(bu" 4
button: button name to bind (e.g. \*(L'<1>') 
.Ip "\(bu" 4
color: color of the node when it is clicked on.
.Ip "\(bu" 4
command: sub ref 
.PP
Bind the \*(L'button\*(R' on arrows. When \*(L'button\*(R' is clicked, the arrow color will
change to \*(L'color\*(R' and the callback sub will be called with these parameters:
.PP
.Vb 5
\& (
\&   on   => 'arrow', 
\&   from => nodeId_on_arrow_start, 
\&   to   => nodeId_on_arrow_tip
\& ) 
.Ve
.Sh "\fIunselectAllNodes()\fR"
Unselect all previously selected nodes (see button <1> binding)
.Sh "\fIgetSelectedNodes()\fR"
Return an array containing nodeIds of all nodes currently selected.
.Sh "\fIgetNodeRectangle\fR\|(...)"
Returns the rectangle reference of the passed nodeId or of the 
node selected by the user.
.PP
Parameters are :
.Ip "\(bu" 4
nodeId: nodeId attached to the rectangle
.Sh "\fIcommand\fR\|(...)"
This will add a new entry on a Popup menu which can be raised on a node
or an arrow.
.PP
Parameters are :
.Ip "\(bu" 4
on: either \*(L'node\*(R' or \*(L'arrow\*(R'
.Ip "\(bu" 4
label: Label of the Popup menu entry
.Ip "\(bu" 4
command: sub ref runned when the menu is invoked
.PP
The callback will be invoked with these parameters when the command is
set for \fBnodes\fR :
.PP
.Vb 1
\& (on => 'node', nodeId => $nodeId)
.Ve
The callback will be invoked with these parameters when the command is
set for \fBarrows\fR :
.PP
.Vb 5
\& (
\&   on   => 'arrow', 
\&   from => nodeId_on_arrow_start, 
\&   to   => nodeId_on_arrow_tip
\& ) 
.Ve
.SH "Private methods"
These functions are documented only for people wanting to improve or
inherit this widget.
.Sh "\fIsetArrow\fR\|(...)"
.Ip "\(bu" 4
color: color of the arrow when selected.
.PP
Reset any previously selected arrow to default color and set the current 
arrow to the color. This function should be used with a bind.
.PP
Returns (from => \f(CW$endNodeId\fR, to => \f(CW$tipNodeId\fR) to specify the nodes 
the arrow is attached to.
.Sh "\fIsetNode()\fR"
.Ip "\(bu" 4
color: color of the arrow when selected.
.Ip "\(bu" 4
nodeId: nodeId to select (optional, default to the node under the mouse 
pointer)
.PP
Set node either from passed nodeId or from the mouse pointer.
When a node is set, only the text is highlighted
.PP
Returns the nodeId of the current node (i.e. the node clicked by the user
if this function was used in a bind)
.Sh "\fItoggleNode\fR\|(...)"
.Ip "\(bu" 4
color: color of the arrow when selected.
.Ip "\(bu" 4
nodeId: nodeId to select (optional, default to the node under the mouse 
pointer)
.PP
Will toggle the node rectangle between \*(L'color\*(R' and default.
.SH "AUTHOR"
Dominique Dumont, Dominique_Dumont@grenoble.hp.com
.PP
Copyright (c) 1998-2000 Dominique Dumont. All rights reserved.
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "SEE ALSO"
\fIperl\fR\|(1), \fITk\fR\|(3), \fITk::Canvas\fR\|(3)

.rn }` ''
.IX Title "TreeGraph 3"
.IX Name "Tk::TreeGraph - Tk widget to draw a tree in a Canvas"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Header "CAVEATS"

.IX Header "About Scrolling"

.IX Header "Widget Options"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Header "Drawing Methods added to Canvas"

.IX Subsection "\fIaddNode\fR\|(...)"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Subsection "\fImodifyNode\fR\|(...)"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Subsection "\fIflashNode\fR\|(...)"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Subsection "\fIaddDirectArrow\fR\|(...)"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Subsection "\fIaddSlantedArrow\fR\|(...)"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Subsection "\fIaddLabel\fR\|(...)"

.IX Item "\(bu"

.IX Subsection "\fIaddShortcutInfo\fR\|(...)"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Subsection "\fIaddAllShortcuts()\fR"

.IX Subsection "\fIclear()\fR"

.IX Header "Management methods"

.IX Subsection "\fInodeBind\fR\|(...)"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Subsection "\fIarrowBind\fR\|(...)"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Subsection "\fIunselectAllNodes()\fR"

.IX Subsection "\fIgetSelectedNodes()\fR"

.IX Subsection "\fIgetNodeRectangle\fR\|(...)"

.IX Item "\(bu"

.IX Subsection "\fIcommand\fR\|(...)"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Header "Private methods"

.IX Subsection "\fIsetArrow\fR\|(...)"

.IX Item "\(bu"

.IX Subsection "\fIsetNode()\fR"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Subsection "\fItoggleNode\fR\|(...)"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Header "AUTHOR"

.IX Header "SEE ALSO"

