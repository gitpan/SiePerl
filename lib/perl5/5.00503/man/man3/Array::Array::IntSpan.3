.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH Array::IntSpan 3 "perl 5.005, patch 03" "24/Feb/2000" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
Array::IntSpan \- a Module for handling arrays using IntSpan techniques
.SH "SYNOPSIS"
.PP
.Vb 1
\&  use Array::IntSpan;
.Ve
.Vb 1
\&  my $foo = Array::IntSpan->new([0, 59, 'F'], [60, 69, 'D'], [80, 89, 'B']);
.Ve
.Vb 4
\&  print "A score of 84% results in a ".$foo->lookup(84).".\en";
\&  unless (defined($foo->lookup(70))) {
\&    print "The grade for the score 70% is currently undefined.\en";
\&  }
.Ve
.Vb 2
\&  $foo->set_range(70, 79, 'C');
\&  print "A score of 75% now results in a ".$foo->lookup(75).".\en";
.Ve
.Vb 4
\&  $foo->set_range(0, 59, undef);
\&  unless (defined($foo->lookup(40))) {
\&    print "The grade for the score 40% is now undefined.\en";
\&  }
.Ve
.Vb 3
\&  $foo->set_range(87, 89, 'B+');
\&  $foo->set_range(85, 100, 'A');
\&  $foo->set_range(100, 1_000_000, 'A+');
.Ve
.SH "DESCRIPTION"
\f(CWArray::IntSpan\fR brings the speed advantages of \f(CWSet::IntSpan\fR (written by Steven McDougall) to
arrays.  Uses include manipulating grades, routing tables, or any other situation where you have
mutually exclusive ranges of integers that map to given values.
.PP
\f(CWArray::IntSpan::IP\fR is also provided with the distribution.  It lets you use IP addresses in any
of three forms (dotted decimal, network string, and integer) for the indices into the array.  See
the POD for that module for more information.
.Sh "Installation instructions"
Standard \f(CWMake::Maker\fR approach or just copy \f(CWArray/IntSpan.pm\fR into
\f(CWsite/lib/Array/IntSpan.pm\fR and \f(CWArray/IntSpan/IP.pm\fR into \f(CWsite/lib/Array/IntSpan/IP.pm\fR.
.SH "METHODS"
.Sh "new"
The \f(CWnew\fR method takes an optional list of array elements.  The elements should be in the form
\f(CW[start_index, end_index, value]\fR.  They should be in sorted order and there should be no
overlaps.  The internal method \f(CW_check_structure\fR will be called to verify the data is correct.
If you wish to avoid the performance penalties of checking the structure, you can use
\f(CWData::Dumper\fR to dump an object and use that code to reconstitute it.
.Sh "set_range"
This method takes three parameters \- the \f(CWstart_index\fR, the \f(CWend_index\fR, and the \f(CWvalue\fR.  If
you wish to erase a range, specify \f(CWundef\fR for the \f(CWvalue\fR.  It properly deals with overlapping
ranges and will replace existing data as appropriate.  If the new range lies after the last
existing range, the method will execute in \fIO\fR\|(1) time.  If the new range lies within the existing
ranges, the method executes in \fIO\fR\|(n) time, where n is the number of ranges.  The code is not
completely optimized and will make up to three calls to \f(CWsplice\fR if the new range intersects with
existing ranges.  It does not consolidate contiguous ranges that have the same \f(CWvalue\fR.
.PP
If you have a large number of inserts to do, it would be beneficial to sort them first.  Sorting
is \fIO\fR\|(n lg(n)), and since appending is \fIO\fR\|(1), that will be considerably faster than the \fIO\fR\|(n^2) time
for inserting n unsorted elements.
.PP
The method returns \f(CW0\fR if there were no overlapping ranges and \f(CW1\fR if there were.
.Sh "lookup"
This method takes as a single parameter the \f(CWindex\fR to look up.  If there is an appropriate range,
the method will return the associated value.  Otherwise, it returns \f(CWundef\fR.
.SH "AUTHOR"
Toby Everett, teverett@alascom.att.com

.rn }` ''
.IX Title "Array::IntSpan 3"
.IX Name "Array::IntSpan - a Module for handling arrays using IntSpan techniques"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Subsection "Installation instructions"

.IX Header "METHODS"

.IX Subsection "new"

.IX Subsection "set_range"

.IX Subsection "lookup"

.IX Header "AUTHOR"

