.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH PropertySet 3 "perl 5.005, patch 03" "25/Feb/1998" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
OLE::PropertySet \- Handles Property Sets
.PP
$Revision: 1.1.1.1 $ \f(CW$Date:\fR 1998/02/25 21:13:00 $
.SH "SYNOPSIS"
.PP
.Vb 2
\& use OLE::Storage();
\& use OLE::PropertySet();
.Ve
.Vb 2
\& $Var = OLE::Storage -> NewVar;
\& $Doc = OLE::Storage -> open ($Startup, $Var, "testfile.doc");
.Ve
.Ip "direct mode" 4
\fI$\s-1PS\s0\fR = \s-1OLE::\s0PropertySet->load (\fI$Startup\fR, \fI$Var\fR, \fI$pps\fR, \fI$Doc\fR)
.Sp
\fI@list\fR = string { \fI$\s-1PS\s0\fR \-> property (2, 5, 6) }
.Ip "tie mode" 4
\fI$\s-1PS\s0\fR = tie \fI%\s-1PS\s0\fR, \s-1OLE::\s0PropertySet, \fI$Startup\fR, \fI$Var\fR, \fI$pps\fR, \fI$Doc\fR
.Sp
\fI@list\fR = string { \fI$\s-1PS\s0\fR{2}, \fI$\s-1PS\s0\fR{5}, \fI$\s-1PS\s0\fR{6} }
.SH "DESCRIPTION"
OLE::PropertySet gives read access to property sets. These are streams,
that e.g. are residing inside of Structured Storage documents. Because
property set technology is not limited to these documents borders, this
package was designed to connect easily to Structured Storage documents 
and to arbitrary property set streams.
.PP
To understand the use of this package, I recommend highly to study the tool 
\*(L"ldat\*(R".
.Ip "dictionary" 4
\f(CW1\fR||\f(CWO\fR == \fI$\s-1PS\s0\fR \-> dictionary (\fI\e%dict\fR [,\f(CW1\fR])
.Sp
Stores the dictionary of PropertySet \fI$\s-1PS\s0\fR in hash \fI%dict\fR. The 
dictionary is a hash array having the property identifier numbers as
keys and the identifier names as values. By default the default dictionaries 
defined in \s-1OLE::\s0PropertySet are also printed out. To leave them out, 
specify the optional parameter 1.
.Sp
Normally you will not need this method, but use \fIidset()\fR instead.
.Ip "idset" 4
\f(CW1\fR||\f(CWO\fR == \fI$\s-1PS\s0\fR \-> idset (\fI\e%idset\fR [,\f(CW1\fR]);
.Sp
Stores the idset of PropertySet \fI$\s-1PS\s0\fR in hash \fI%idset\fR. The idset
is a hash array based on the really available property identifiers.
\f(CW%idset\fR has property identifier numbers as keys and the identifier
names according to the PropertySets dictionary as values. The optional
parameter spares out the default dictionary (see dictionary).
.Sp
\fBNote\fR: Some or all id names can be empty, if they cannot be figured 
out. Nevertheless the ids are valid.
.Ip "idstr" 4
\fI$idstr\fR||\f(CWundef\fR = \fI$\s-1PS\s0\fR \-> idstr ($id [,\f(CW1\fR])
.Sp
Returns the property identifier string for property \f(CW$id\fR according to
the PropertySets dictionary. The optional parameter spares out the default
dictionary (see dictionary).
.Ip "load" 4
.Ip "\fI$\s-1PS\s0\fR||\f(CW0\fR ==" 8
1. load (\fI$Startup\fR, \fI$Var\fR, \fI$pps\fR, \fI$Doc\fR [,\f(CWfilter\fR])
.Sp
2. load (\fI$Startup\fR, \fI$Var\fR, \fI$name\fR, \fI\e$buf\fR [,\f(CWfilter\fR])
.Ip "" 4
\fIload()\fR is the constructor of \s-1OLE::\s0PropertySet. You can call it
either with a Property Storage id \fI$pps\fR and a Structured Storage 
document handle \fI$Doc\fR as parameters, or with an PropertySetName \fI$name\fR
and a reference to a PropertySetBuffer \fI\e$buf\fR.
.Ip "NewVar" 4
\fI$Var\fR == \fI$\s-1PS\s0\fR \-> NewVar ()
.Sp
Creates a new Variable handling object and returns it. (see also: open)
.Ip "property" 4
\fIProperty\fR||\fIscalar\fR = \fI$\s-1PS\s0\fR \-> property (\fI$id1\fR [,\fI$id2\fR [...]])
.Sp
Returns a \fI$Property\fR or a list of \fI@Properties\fR. (See 
\s-1OLE::\s0Storage::Property to look what to do with it / them). If you applied a
filter when loading \fI$\s-1PS\s0\fR, property returns a scalar or a list of scalars.
.Ip "type" 4
\fI$type\fR||0 = PropertySet \-> type (\fI$Doc\fR, \fI$pps\fR)
.Sp
\fI$type\fR||0 = PropertySet \-> type ($name)
.Sp
Returns the type of a PropertySet according to its name. The type is
a \s-1OLE::\s0PropertySet internal. It can be used to determine, if a property
is a PropertySet or not. Momentarily are existing:
.Sp
.Vb 5
\& type    meaning
\& ---------------------------------------------------
\& 0x01    property is a "\e05" PropertySet
\& 0x10    property is a "\e01CompObj" fake PropertySet
\& 0x00    property is no PropertySet at all
.Ve
.SH "SEE ALSO"
the \fIOLE::Storage::Property\fR manpage, demonstration program \*(L"ldat\*(R"
.SH "AUTHOR"
Martin Schwartz <\fIschwartz@cs.tu-berlin.de\fR>. 

.rn }` ''
.IX Title "PropertySet 3"
.IX Name "OLE::PropertySet - Handles Property Sets"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Item "direct mode"

.IX Item "tie mode"

.IX Header "DESCRIPTION"

.IX Item "dictionary"

.IX Item "idset"

.IX Item "idstr"

.IX Item "load"

.IX Item "\fI$\s-1PS\s0\fR||\f(CW0\fR =="

.IX Item ""

.IX Item "NewVar"

.IX Item "property"

.IX Item "type"

.IX Header "SEE ALSO"

.IX Header "AUTHOR"

