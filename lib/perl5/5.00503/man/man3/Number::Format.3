.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH Format 3 "perl 5.005, patch 03" "30/Nov/1998" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
Number::Format \- Perl extension for formatting numbers
.SH "SYNOPSIS"
.PP
.Vb 18
\&  use Number::Format;
\&  my $x = new Number::Format %args;
\&  $formatted = $x->round($number, $precision);
\&  $formatted = $x->format_number($number, $precision, $trailing_zeroes);
\&  $formatted = $x->format_negative($number, $picture);
\&  $formatted = $x->format_picture($number, $picture);
\&  $formatted = $x->format_price($number, $precision);
\&  $formatted = $x->format_bytes($number, $precision);
\&  $number    = $x->unformat_number($formatted);
\&  
\&  use Number::Format qw(:subs);
\&  $formatted = round($number, $precision);
\&  $formatted = format_number($number, $precision, $trailing_zeroes);
\&  $formatted = format_negative($number, $picture);
\&  $formatted = format_picture($number, $picture);
\&  $formatted = format_price($number, $precision);
\&  $formatted = format_bytes($number, $precision);
\&  $number    = unformat_number($formatted);
.Ve
.SH "REQUIRES"
Perl, version 5.003 or higher.
.PP
POSIX.pm will be used if present to determine locale settings.
.PP
Carp.pm is used for some error reporting.
.SH "DESCRIPTION"
These functions provide an easy means of formatting numbers in a
manner suitable for displaying to the user.
.PP
There are two ways to use this package.	 One is to declare an object
of type Number::Format, which you can think of as a formatting engine.
The various functions defined here are provided as object methods.
The constructor \f(CWnew()\fR can be used to set the parameters of the
formatting engine.  Valid parameters are:
.PP
.Vb 10
\&  THOUSANDS_SEP     - character inserted between groups of 3 digits
\&  DECIMAL_POINT     - character separating integer and fractional parts
\&  MON_THOUSANDS_SEP - like THOUSANDS_SEP, but used for format_price
\&  MON_DECIMAL_POINT - like DECIMAL_POINT, but used for format_price
\&  INT_CURR_SYMBOL   - character(s) denoting currency (see format_price())
\&  DECIMAL_DIGITS    - number of digits to the right of dec point (def 2)
\&  DECIMAL_FILL      - boolean; whether to add zeroes to fill out decimal
\&  NEG_FORMAT        - format to display negative numbers (def ``-x'')
\&  KILO_SUFFIX       - suffix to add when format_bytes formats kilobytes
\&  MEGA_SUFFIX       - suffix to add when format_bytes formats megabytes
.Ve
They may be specified in upper or lower case, with or without a
leading hyphen ( \- ).
.PP
The defaults for \f(CWTHOUSANDS_SEP\fR, \f(CWDECIMAL_POINT\fR,
\f(CWMON_THOUSANDS_SEP\fR, \f(CWMON_DECIMAL_POINT\fR, and \f(CWINT_CURR_SYMBOL\fR
come from the POSIX locale information (see the \fIperllocale\fR manpage), if
available.  If your POSIX locale does not provide \f(CWMON_THOUSANDS_SEP\fR
and/or \f(CWMON_DECIMAL_POINT\fR fields, then the \f(CWTHOUSANDS_SEP\fR and/or
\f(CWDECIMAL_POINT\fR values are used for those parameters.  Some systems
(e.g. Win32 ports of Perl) do not include POSIX support.  In those
systems, the POSIX system is bypassed.
.PP
If any of the above parameters are not specified when you invoke
\f(CWnew()\fR, then the values are taken from package global variables of
the same name (e.g.  \f(CW$DECIMAL_POINT\fR is the default for the
\f(CWDECIMAL_POINT\fR parameter).  If you use the \f(CW:vars\fR keyword on your
\f(CWuse Number::Format\fR line (see non-object-oriented example below) you
will import those variables into your namesapce and can assign values
as if they were your own local variables.  The default values for all
the parameters are:
.PP
.Vb 10
\&  THOUSANDS_SEP     = ','
\&  DECIMAL_POINT     = '.'
\&  MON_THOUSANDS_SEP = ','
\&  MON_DECIMAL_POINT = '.'
\&  INT_CURR_SYMBOL   = 'USD '
\&  DECIMAL_DIGITS    = 2
\&  DECIMAL_FILL      = 0
\&  NEG_FORMAT        = '-x'
\&  KILO_SUFFIX       = 'K'
\&  MEGA_SUFFIX       = 'M'
.Ve
Note however that when you first call one of the functions in this
module \fIwithout\fR using the object-oriented interface, further setting
of those global variables will have no effect on non-OO calls.	It is
recommended that you use the object-oriented interface instead for
fewer headaches and a cleaner design.
.PP
The \f(CWDECIMAL_FILL\fR and \f(CWDECIMAL_DIGITS\fR values are not set by the
Locale system, but are definable by the user.  They affect the output
of \f(CWformat_number()\fR.	Setting \f(CWDECIMAL_DIGITS\fR is like giving that
value as the \f(CW$precision\fR argument to that function.  Setting
\f(CWDECIMAL_FILL\fR to a true value causes \f(CWformat_number()\fR to append
zeroes to the right of the decimal digits until the length is the
specified number of digits.
.PP
\f(CWNEG_FORMAT\fR is only used by \f(CWformat_negative()\fR and is a string
containing the letter \*(L'x\*(R', where that letter will be replaced by a
positive representation of the number being passed to that function.
\f(CWformat_number()\fR and \f(CWformat_price()\fR utilize this feature by
calling \f(CWformat_negative()\fR if the number was less than 0.
.PP
\f(CWKILO_SUFFIX\fR and \f(CWMEGA_SUFFIX\fR are used by \f(CWformat_bytes()\fR when
the value is over 1024 or 1024*1024, respectively.  The default values
are \*(L"K\*(R" and \*(L"M\*(R".
.PP
The only restrictions on \f(CWDECIMAL_POINT\fR and \f(CWTHOUSANDS_SEP\fR are that
they must not be digits, must not be identical, and must each be one
character.  There are no restrictions on \f(CWINT_CURR_SYMBOL\fR.
.PP
For example, a German user might include this in their code:
.PP
.Vb 5
\&  use Number::Format;
\&  my $de = new Number::Format(-thousands_sep   => '.',
\&                              -decimal_point   => ',',
\&                              -int_curr_symbol => 'DEM');
\&  my $formatted = $de->format_number($number);
.Ve
Or, if you prefer not to use the object oriented interface, you can do
this instead:
.PP
.Vb 5
\&  use Number::Format qw(:subs :vars);
\&  $THOUSANDS_SEP   = '.';
\&  $DECIMAL_POINT   = ',';
\&  $INT_CURR_SYMBOL = 'DEM';
\&  my $formatted = format_number($number);
.Ve
.SH "EXPORTS"
Nothing is exported by default.	 To export the functions or the global
variables defined herein, specify the function \fIname\fR\|(s) on the import
list of the \f(CWuse Number::Format\fR statement.  To export all functions
defined herein, use the special tag \f(CW:subs\fR.  To export the
variables, use the special tag \f(CW:vars\fR; to export both subs and vars
you can use the tag \f(CW:all\fR.
.SH "METHODS"
.Ip "new( %args )" 4
Creates a new Number::Format object.  Valid keys for \f(CW%args\fR are any of
the parameters described above.	 Keys may be in all uppercase or all
lowercase, and may optionally be preceded by a hyphen (\-) character.
Example:
.Sp
.Vb 3
\&  my $de = new Number::Format(-thousands_sep   => '.',
\&                              -decimal_point   => ',',
\&                              -int_curr_symbol => 'DEM');
.Ve
.Ip "round($number, $precision)" 4
Rounds the number to the specified precision.  If \f(CW$precision\fR is
omitted, the value of the \f(CWDECIMAL_DIGITS\fR parameter is used (default
value 2).  Both input and output are numeric (the function uses math
operators rather than string manipulation to do its job), The value of
\f(CW$precision\fR may be any integer, positive or negative. Examples:
.Sp
.Vb 4
\&  round(3.14159)       yields    3.14
\&  round(3.14159, 4)    yields    3.1416
\&  round(42.00, 4)      yields    42
\&  round(1234, -2)      yields    1200
.Ve
Since this is a mathematical rather than string oriented function,
there will be no trailing zeroes to the right of the decimal point,
and the \f(CWDECIMAL_POINT\fR and \f(CWTHOUSANDS_SEP\fR variables are ignored.
To format your number using the \f(CWDECIMAL_POINT\fR and \f(CWTHOUSANDS_SEP\fR
variables, use \f(CWformat_number()\fR instead.
.Ip "format_number($number, $precision, $trailing_zeroes)" 4
Formats a number by adding \f(CWTHOUSANDS_SEP\fR between each set of 3
digits to the left of the decimal point, substituting \f(CWDECIMAL_POINT\fR
for the decimal point, and rounding to the specified precision using
\f(CWround()\fR.  Note that \f(CW$precision\fR is a \fImaximum\fR precision
specifier; trailing zeroes will only appear in the output if
\f(CW$trailing_zeroes\fR is provided, or the parameter \f(CWDECIMAL_FILL\fR is
set, with a value that is true (not zero, undef, or the empty string).
If \f(CW$precision\fR is omitted, the value of the \f(CWDECIMAL_DIGITS\fR
parameter (default value of 2) is used.  Examples:
.Sp
.Vb 6
\&  format_number(12345.6789)      yields   '12,345.68'
\&  format_number(123456.789, 2)   yields   '123,456.79'
\&  format_number(1234567.89, 2)   yields   '1,234,567.89'
\&  format_number(1234567.8, 2)    yields   '1,234,567.8'
\&  format_number(1234567.8, 2, 1) yields   '1,234,567.80'
\&  format_number(1.23456789, 6)   yields   '1.234568'
.Ve
Of course the output would have your values of \f(CWTHOUSANDS_SEP\fR and
\f(CWDECIMAL_POINT\fR instead of \*(L',\*(R' and \*(L'.\*(R' respectively.
.Ip "format_negative($number, $picture)" 4
Formats a negative number.  Picture should be a string that contains
the letter \f(CWx\fR where the number should be inserted.  For example, for
standard negative numbers you might use ``\f(CW-x\fR'\*(R', while for
accounting purposes you might use ``\f(CW(x)\fR'\*(R'.  If the specified number
begins with a ``\-'\*(R' character, that will be removed before formatting,
but formatting will occur whether or not the number is negative.
.Ip "format_picture($number, $picture)" 4
Returns a string based on \f(CW$picture\fR with the \f(CW#\fR characters
replaced by digits from \f(CW$number\fR.  If the length of the integer part
of \f(CW$number\fR is too large to fit, the \f(CW#\fR characters are replaced with
asterisks (\f(CW*\fR) instead.  Examples:
.Sp
.Vb 5
\&  format_picture(100.023, 'USD ##,###.##')   yields   'USD    100.02'
\&  format_picture(1000.23, 'USD ##,###.##')   yields   'USD  1,000.23'
\&  format_picture(10002.3, 'USD ##,###.##')   yields   'USD 10,002.30'
\&  format_picture(100023,  'USD ##,###.##')   yields   'USD **,***.**'
\&  format_picture(1.00023, 'USD #.###,###')   yields   'USD 1.002,300'
.Ve
The comma (,) and period (.) you see in the picture examples should
match the values of \f(CWTHOUSANDS_SEP\fR and \f(CWDECIMAL_POINT\fR,
respectively, for proper operation.  However, the \f(CWTHOUSANDS_SEP\fR
characters in \f(CW$picture\fR need not occur every three digits; the
\fIonly\fR use of that variable by this function is to remove leading
commas (see the first example above).  There may not be more than one
instance of \f(CWDECIMAL_POINT\fR in \f(CW$picture\fR.
.Ip "format_price($number, $precision)" 4
Returns a string containing \f(CW$number\fR formatted similarly to
\f(CWformat_number()\fR, except that the decimal portion may have trailing
zeroes added to make it be exactly \f(CW$precision\fR characters long, and
the currency string will be prefixed.
.Sp
If the \f(CWINT_CURR_SYMBOL\fR attribute of the object is the empty string, no
currency will be added.
.Sp
If \f(CW$precision\fR is not provided, the default of 2 will be used.
Examples:
.Sp
.Vb 3
\&  format_price(12.95)   yields   'USD 12.95'
\&  format_price(12)      yields   'USD 12.00'
\&  format_price(12, 3)   yields   '12.000'
.Ve
The third example assumes that \f(CWINT_CURR_SYMBOL\fR is the empty string.
.Ip "format_bytes($number, $precision)" 4
Returns a string containing \f(CW$number\fR formatted similarly to
\f(CWformat_number()\fR, except that if the number is over 1024, it will be
divided by 1024 and \*(L"K\*(R" appended to the end; or if it is over 1048576
(1024*1024), it will be divided by 1048576 and \*(L"M\*(R" appended to the
end.  Negative values will result in an error.
.Sp
If \f(CW$precision\fR is not provided, the default of 2 will be used.
Examples:
.Sp
.Vb 3
\&  format_bytes(12.95)   yields   '12.95'
\&  format_bytes(2048)    yields   '2K'
\&  format_bytes(1048576) yields   '1M'
.Ve
.Ip "unformat_number($formatted)" 4
Converts a string as returned by \f(CWformat_number()\fR,
\f(CWformat_price()\fR, or \f(CWformat_picture()\fR, and returns the
corresponding value as a numeric scalar.  Returns \f(CWundef\fR if the
number does not contain any digits.  Examples:
.Sp
.Vb 4
\&  unformat_number('USD 12.95')   yields   12.95
\&  unformat_number('USD 12.00')   yields   12
\&  unformat_number('foobar')      yields   undef
\&  unformat_number('1234-567@.8') yields   1234567.8
.Ve
The value of \f(CWDECIMAL_POINT\fR is used to determine where to separate
the integer and decimal portions of the input.	All other non-digit
characters, including but not limited to \f(CWINT_CURR_SYMBOL\fR and
\f(CWTHOUSANDS_SEP\fR, are removed.
.Sp
If the number matches the pattern of \f(CWNEG_FORMAT\fR \fIor\fR there is a
``\-'\*(R' character before any of the digits, then a negative number is
returned.
.Sp
If the number ends with the \f(CWKILO_SUFFIX\fR or \f(CWMEGA_SUFFIX\fR
characters, then the number returned will be multiplied by 1024 or
1024*1024 as appropriate.
.SH "AUTHOR"
William R. Ward, wrw@bayview.com
.SH "SEE ALSO"
\fIperl\fR\|(1).

.rn }` ''
.IX Title "Format 3"
.IX Name "Number::Format - Perl extension for formatting numbers"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "REQUIRES"

.IX Header "DESCRIPTION"

.IX Header "EXPORTS"

.IX Header "METHODS"

.IX Item "new( %args )"

.IX Item "round($number, $precision)"

.IX Item "format_number($number, $precision, $trailing_zeroes)"

.IX Item "format_negative($number, $picture)"

.IX Item "format_picture($number, $picture)"

.IX Item "format_price($number, $precision)"

.IX Item "format_bytes($number, $precision)"

.IX Item "unformat_number($formatted)"

.IX Header "AUTHOR"

.IX Header "SEE ALSO"

