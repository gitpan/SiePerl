.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH Simple 3 "perl 5.005, patch 03" "2/Apr/2000" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
XML::Simple \- Trivial API for reading and writing XML (esp config files)
.SH "SYNOPSIS"
.PP
.Vb 1
\&    use XML::Simple;
.Ve
.Vb 1
\&    my $ref = XMLin([<xml file or string>] [, <options>]);
.Ve
.Vb 1
\&    my $xml = XMLout($hashref [, <options>]);
.Ve
.SH "QUICK START"
Say you have a script called \fBfoo\fR and a file of configuration options
called \fBfoo.xml\fR containing this:
.PP
.Vb 13
\&  <config logdir="/var/log/foo/" debugfile="/tmp/foo.debug">
\&    <server name="sahara" osname="solaris" osversion="2.6">
\&      <address>10.0.0.101</address>
\&      <address>10.0.1.101</address>
\&    </server>
\&    <server name="gobi" osname="irix" osversion="6.5">
\&      <address>10.0.0.102</address>
\&    </server>
\&    <server name="kalahari" osname="linux" osversion="2.0.34">
\&      <address>10.0.0.103</address>
\&      <address>10.0.1.103</address>
\&    </server>
\&  </config>
.Ve
The following lines of code in \fBfoo\fR:
.PP
.Vb 1
\&  use XML::Simple;
.Ve
.Vb 1
\&  my $config = XMLin();
.Ve
will \*(L'slurp\*(R' the configuration options into the hashref \f(CW$config\fR (because no
arguments are passed to \f(CWXMLin()\fR the name and location of the XML file will
be inferred from name and location of the script).  You can dump out the
contents of the hashref using Data::Dumper:
.PP
.Vb 1
\&  use Data::Dumper;
.Ve
.Vb 1
\&  print Dumper($config);
.Ve
which will produce something like this (formatting has been adjusted for
brevity):
.PP
.Vb 21
\&  {
\&      'logdir'        => '/var/log/foo/',
\&      'debugfile'     => '/tmp/foo.debug',
\&      'server'        => {
\&          'sahara'        => {
\&              'osversion'     => '2.6',
\&              'osname'        => 'solaris',
\&              'address'       => [ '10.0.0.101', '10.0.1.101' ]
\&          },
\&          'gobi'          => {
\&              'osversion'     => '6.5',
\&              'osname'        => 'irix',
\&              'address'       => '10.0.0.102'
\&          },
\&          'kalahari'      => {
\&              'osversion'     => '2.0.34',
\&              'osname'        => 'linux',
\&              'address'       => [ '10.0.0.103', '10.0.1.103' ]
\&          }
\&      }
\&  }
.Ve
Your script could then access the name of the log directory like this:
.PP
.Vb 1
\&  print $config->{logdir};
.Ve
similarly, the second address on the server \*(L'kalahari\*(R' could be referenced as:
.PP
.Vb 1
\&  print $config->{server}->{kalahari}->{address}->[1];
.Ve
What could be simpler?  (Rhetorical).
.PP
For simple requirements, that's really all there is to it.  If you want to
store your XML in a different directory or file, or pass it in as a string or
even pass it in via some derivative of an IO::Handle, you'll need to check out
the section on \fIOPTIONS\fR.  If you want to turn off or tweak the array folding feature (that
neat little transformation that produced \f(CW$config\fR\->{server}) you'll find options
for that as well.
.PP
If you want to generate XML (for example to write a modified version of
\f(CW$config\fR back out as XML), check out \f(CWXMLout()\fR.
.PP
If your needs are not so simple, this may not be the module for you.  In that
case, you might want to read the section on \fIWHERE TO FROM HERE?\fR.
.SH "DESCRIPTION"
The XML::Simple module provides a simple API layer on top of the XML::Parser
module.  Two functions are exported: \f(CWXMLin()\fR and \f(CWXMLout()\fR.
.PP
The most common approach is to simply call these two functions directly, but an
optional object oriented interface (see the section on \fIOPTIONAL OO INTERFACE\fR below)
allows them to be called as methods of an \fBXML::Simple\fR object.
.Sh "\fIXMLin()\fR"
Parses \s-1XML\s0 formatted data and returns a reference to a data structure which
contains the same information in a more readily accessible form.  (Skip
down to the section on \fI\s-1EXAMPLES\s0\fR below, for more sample code).
.PP
\f(CWXMLin()\fR accepts an optional \s-1XML\s0 specifier followed by zero or more \*(L'name =>
value\*(R' option pairs.  The \s-1XML\s0 specifier can be one of the following:
.Ip "A filename" 4
If the filename contains no directory components \f(CWXMLin()\fR will look for the
file in each directory in the searchpath (see the section on \fI\s-1OPTIONS\s0\fR below).  eg:
.Sp
.Vb 1
\&  $ref = XMLin('/etc/params.xml');
.Ve
.Ip "undef" 4
If there is no \s-1XML\s0 specifier, \f(CWXMLin()\fR will check the script directory and
each of the searchpath directories for a file with the same name as the script
but with the extension \*(L'.xml\*(R'.  Note: if you wish to specify options, you
must specify the value \*(L'undef\*(R'.  eg:
.Sp
.Vb 1
\&  $ref = XMLin(undef, forcearray => 1);
.Ve
.Ip "A string of \s-1XML\s0" 4
A string containing \s-1XML\s0 (recognised by the presence of \*(L'<\*(R' and \*(L'>\*(R' characters)
will be parsed directly.  eg:
.Sp
.Vb 1
\&  $ref = XMLin('<opt username="bob" password="flurp" />');
.Ve
.Ip "An \s-1IO::\s0Handle object" 4
An \s-1IO::\s0Handle object will be read to \s-1EOF\s0 and its contents parsed. eg:
.Sp
.Vb 2
\&  $fh = new IO::File('/etc/params.xml');
\&  $ref = XMLin($fh);
.Ve
.Sh "\fIXMLout()\fR"
Takes a data structure (generally a hashref) and returns an \s-1XML\s0 encoding of
that structure.  If the resulting \s-1XML\s0 is parsed using \f(CWXMLin()\fR, it will
return a data structure equivalent to the original. 
.PP
When translating hashes to \s-1XML\s0, hash keys which have a leading \*(L'\-\*(R' will be
silently skipped.  This is the approved method for marking elements of a
data structure which should be ignored by \f(CWXMLout\fR.  (Note: If these items
were not skipped the key names would be emitted as element or attribute names
with a leading \*(L'\-\*(R' which would not be valid \s-1XML\s0).
.Sh "Caveats"
Some care is required in creating data structures which will be passed to
\f(CWXMLout()\fR.  Hash keys from the data structure will be encoded as either \s-1XML\s0
element names or attribute names.  Therefore, you should use hash key names 
which conform to the relatively strict \s-1XML\s0 naming rules:
.PP
Names in \s-1XML\s0 must begin with a letter.  The remaining characters may be
letters, digits, hyphens (\-), underscores (_) or full stops (.).  It is also
allowable to include one colon (:) in an element name but this should only be
used when working with namespaces \- a facility well beyond the scope of
\fB\s-1XML::\s0Simple\fR.
.PP
You can use other punctuation characters in hash values (just not in hash
keys) however \fB\s-1XML::\s0Simple\fR does not support dumping binary data.
.PP
If you break these rules, the current implementation of \f(CWXMLout()\fR will 
simply emit non-compliant \s-1XML\s0 which will be rejected if you try to read it
back in.  (A later version of \fB\s-1XML::\s0Simple\fR might take a more proactive
approach).
.PP
Note also that although you can nest hashes and arrays to arbitrary levels,
recursive data structures are not supported and will cause \f(CWXMLout()\fR to die.
.PP
Refer to the section on \fI\s-1WHERE\s0 \s-1TO\s0 \s-1FROM\s0 \s-1HERE\s0?\fR if \f(CWXMLout()\fR is too simple for your needs.
.SH "OPTIONS"
\fBXML::Simple\fR supports a number of options (in fact as each release of
\fBXML::Simple\fR adds more options, the module's claim to the name \*(L'Simple\*(R'
becomes more tenuous).  If you find yourself repeatedly having to specify
the same options, you might like to investigate the section on \fIOPTIONAL OO INTERFACE\fR
below.
.PP
Both \f(CWXMLin()\fR and \f(CWXMLout()\fR expect a single argument followed by a list of
options.  An option takes the form of a \*(L'name => value\*(R' pair.  The options
listed below are marked with \*(L'\fBin\fR\*(R' if they are recognised by \f(CWXMLin()\fR and
\&\*(R'\fBout\fR\*(R' if they are recognised by \f(CWXMLout()\fR.
.Ip "keyattr => [ list ] (\fBin+out\fR)" 4
This option controls the \*(L'array folding\*(R' feature which translates nested
elements from an array to a hash.  For example, this \s-1XML\s0:
.Sp
.Vb 4
\&    <opt>
\&      <user login="grep" fullname="Gary R Epstein" />
\&      <user login="stty" fullname="Simon T Tyson" />
\&    </opt>
.Ve
would, by default, parse to this:
.Sp
.Vb 12
\&    {
\&      'user' => [
\&                  {
\&                    'login' => 'grep',
\&                    'fullname' => 'Gary R Epstein'
\&                  },
\&                  {
\&                    'login' => 'stty',
\&                    'fullname' => 'Simon T Tyson'
\&                  }
\&                ]
\&    }
.Ve
If the option \*(L'keyattr => \*(L"login"\*(R' were used to specify that the \*(L'login\*(R'
attribute is a key, the same \s-1XML\s0 would parse to:
.Sp
.Vb 10
\&    {
\&      'user' => {
\&                  'stty' => {
\&                              'fullname' => 'Simon T Tyson'
\&                            },
\&                  'grep' => {
\&                              'fullname' => 'Gary R Epstein'
\&                            }
\&                }
\&    }
.Ve
The key attribute names should be supplied in an arrayref if there is more
than one.  \f(CWXMLin()\fR will attempt to match attribute names in the order
supplied.  \f(CWXMLout()\fR will use the first attribute name supplied when
\&'unfolding\*(R' a hash into an array.
.Sp
Note: the keyattr option controls the folding of arrays.  By default a single
nested element will be rolled up into a scalar rather than an array and
therefore will not be folded.  Use the \*(L'forcearray\*(R' option (below) to force
nested elements to be parsed into arrays and therefore candidates for folding
into hashes.
.Sp
The default value for \*(L'keyattr\*(R' is ['name\*(R', \*(L'key\*(R', \*(L'id'].  Setting this option
to an empty list will disable the array folding feature.
.Ip "keyattr => { list } (\fBin+out\fR)" 4
This alternative method of specifiying the key attributes allows more fine grained
control over which elements are folded and on which attributes.  For example the 
option \*(L'keyattr => { package => \*(L'id\*(R' } will cause any package elements to be folded
on the \*(L'id\*(R' attribute.  No other elements which have an \*(L'id\*(R' attribute will be
folded at all. 
.Sp
Two further variations are made possible by prefixing a \*(L'+\*(R' or a \*(L'\-\*(R' character
to the attribute name:
.Sp
The option \*(L'keyattr => { user => \*(L"+login\*(R" }\*(R' will cause this \s-1XML\s0:
.Sp
.Vb 4
\&    <opt>
\&      <user login="grep" fullname="Gary R Epstein" />
\&      <user login="stty" fullname="Simon T Tyson" />
\&    </opt>
.Ve
to parse to this data structure:
.Sp
.Vb 12
\&    {
\&      'user' => {
\&                  'stty' => {
\&                              'fullname' => 'Simon T Tyson',
\&                              'login'    => 'stty'
\&                            },
\&                  'grep' => {
\&                              'fullname' => 'Gary R Epstein',
\&                              'login'    => 'grep'
\&                            }
\&                }
\&    }
.Ve
The \*(L'+\*(R' indicates that the value of the key attribute should be copied rather than
moved to the folded hash key.
.Sp
A \*(L'\-\*(R' prefix would produce this result:
.Sp
.Vb 12
\&    {
\&      'user' => {
\&                  'stty' => {
\&                              'fullname' => 'Simon T Tyson',
\&                              '-login'    => 'stty'
\&                            },
\&                  'grep' => {
\&                              'fullname' => 'Gary R Epstein',
\&                              '-login'    => 'grep'
\&                            }
\&                }
\&    }
.Ve
As described earlier, \f(CWXMLout\fR will ignore hash keys starting with a \*(L'\-\*(R'.
.Ip "searchpath => [ list ] (\fBin\fR)" 4
Where the \s-1XML\s0 is being read from a file, and no path to the file is specified,
this attribute allows you to specify which directories should be searched.
.Sp
If the first parameter to \f(CWXMLin()\fR is undefined, the default searchpath
will contain only the directory in which the script itself is located.
Otherwise the default searchpath will be empty.  
.Sp
Note: the current directory (\*(R'.') is \fBnot\fR searched unless it is the directory
containing the script.
.Ip "forcearray => 1 (\fBin\fR)" 4
This option should be set to \*(L'1\*(R' to force nested elements to be represented
as arrays even when there is only one.  Eg, with forcearray enabled, this
\s-1XML\s0:
.Sp
.Vb 3
\&    <opt>
\&      <name>value</name>
\&    </opt>
.Ve
would parse to this:
.Sp
.Vb 5
\&    {
\&      'name' => [
\&                  'value'
\&                ]
\&    }
.Ve
instead of this (the default):
.Sp
.Vb 3
\&    {
\&      'name' => 'value'
\&    }
.Ve
This option is especially useful if the data structure is likely to be written
back out as \s-1XML\s0 and the default behaviour of rolling single nested elements up
into attributes is not desirable. 
.Sp
If you are using the array folding feature, you should almost certainly enable
this option.  If you do not, single nested elements will not be parsed to
arrays and therefore will not be candidates for folding to a hash.  (Given that
the default value of \*(L'keyattr\*(R' enables array folding, the default value of this
option should probably also have been enabled too \- sorry).
.Ip "forcearray => [ name(s) ] (\fBin\fR)" 4
This alternative form of the \*(L'forcearray\*(R' option allows you to specify a list
of element names which should always be forced into an array representation,
rather than the \*(L'all or nothing\*(R' approach above.
.Ip "cache => [ cache scheme(s) ] (\fBin\fR)" 4
Because loading the \fB\s-1XML::\s0Parser\fR module and parsing an \s-1XML\s0 file can consume a
significant number of \s-1CPU\s0 cycles, it is often desirable to cache the output of
\f(CWXMLin()\fR for later reuse.
.Sp
When parsing from a named file, \fB\s-1XML::\s0Simple\fR supports a number of caching
schemes.  The \*(L'cache\*(R' option may be used to specify one or more schemes (using
an anonymous array).  Each scheme will be tried in turn in the hope of finding
a cached pre-parsed representation of the \s-1XML\s0 file.  If no cached copy is
found, the file will be parsed and the first cache scheme in the list will be
used to save a copy of the results.  The following cache schemes have been
implemented:
.Ip "storable" 8
Utilises \fBStorable.pm\fR to read/write a cache file with the same name as the
\s-1XML\s0 file but with the extension .stor
.Ip "memshare" 8
When a file is first parsed, a copy of the resulting data structure is retained
in memory in the \fB\s-1XML::\s0Simple\fR module's namespace.  Subsequent calls to parse
the same file will return a reference to this structure.  This cached version
will persist only for the life of the Perl interpreter (which in the case of
mod_perl for example, may be some significant time).
.Sp
Because each caller receives a reference to the same data structure, a change
made by one caller will be visible to all.  For this reason, the reference
returned should be treated as read-only.
.Ip "memcopy" 8
This scheme works identically to \*(L'memshare\*(R' (above) except that each caller
receives a reference to a new data structure which is a copy of the cached
version.  Copying the data structure will add a little processing overhead,
therefore this scheme should only be used where the caller intends to modify
the data structure (or wishes to protect itself from others who might).  This
scheme uses \fBStorable.pm\fR to perform the copy.
.Ip "keeproot => 1 (\fBin+out\fR)" 4
In its attempt to return a data structure free of superfluous detail and
unnecessary levels of indirection, \f(CWXMLin()\fR normally discards the root
element name.  Setting the \*(L'keeproot\*(R' option to \*(L'1\*(R' will cause the root element
name to be retained.  So after executing this code:
.Sp
.Vb 1
\&  $config = XMLin('<config tempdir="/tmp" />', keeproot => 1)
.Ve
You'll be able to reference the tempdir as
\f(CW$config->{config}->{tempdir}\fR instead of the default
\f(CW$config->{tempdir}\fR.
.Sp
Similarly, setting the \*(L'keeproot\*(R' option to \*(L'1\*(R' will tell \f(CWXMLout()\fR that the
data structure already contains a root element name and it is not necessary to
add another.
.Ip "rootname => \*(N'string\*(T' (\fBout\fR)" 4
By default, when \f(CWXMLout()\fR generates \s-1XML\s0, the root element will be named
\&'opt\*(R'.  This option allows you to specify an alternative name.
.Sp
Specifying either undef or the empty string for the rootname option will
produce \s-1XML\s0 with no root elements.  In most cases the resulting \s-1XML\s0 fragment
will not be \*(L'well formed\*(R' and therefore could not be read back in by \f(CWXMLin()\fR.
Nevertheless, the option has been found to be useful in certain circumstances.
.Ip "contentkey => \*(N'keyname\*(T' (\fBin+out\fR)" 4
When \f(CWXMLin()\fR parses elements which have text content as well as attributes,
the text content must be represented as a hash value rather than a simple
scalar.  This option allows you to specify a name for the hash key to override
the default \*(L'content\*(R'.  So for example:
.Sp
.Vb 1
\&  XMLin('<opt one="1">Text</opt>', contentkey => 'text')
.Ve
will parse to:
.Sp
.Vb 1
\&  { 'one' => 1, 'text' => 'Text' }
.Ve
instead of:
.Sp
.Vb 1
\&  { 'one' => 1, 'content' => 'Text' }
.Ve
\f(CWXMLout()\fR will also honour the value of this option when converting a hashref
to \s-1XML\s0.
.Ip "xmldecl => 1  or  xmldecl => \*(N'string\*(T'  (\fBout\fR)" 4
If you want the output from \f(CWXMLout()\fR to start with the optional \s-1XML\s0
declaration, simply set the option to \*(L'1\*(R'.  The default \s-1XML\s0 declaration is:
.Sp
.Vb 1
\&        <?xml version='1' standalone='yes'?>
.Ve
If you want some other string (for example to declare an encoding value), set
the value of this option to the complete string you require.
.Ip "outputfile => <file specifier> (\fBout\fR)" 4
The default behaviour of \f(CWXMLout()\fR is to return the \s-1XML\s0 as a string.  If you
wish to write the \s-1XML\s0 to a file, simply supply the filename using the
\&'outputfile\*(R' option.  Alternatively, you can supply an \s-1IO\s0 handle object instead
of a filename.
.Ip "noescape => 1 (\fBout\fR)" 4
By default, \f(CWXMLout()\fR will translate the characters \*(L'<\*(R', \*(L'>\*(R', \*(L'&\*(R' and
\&'"\*(R' to \*(L'&lt;\*(R', \*(L'&gt;\*(R', \*(L'&amp;\*(R' and \*(L'&quot\*(R' respectively.  Use this option to
suppress escaping (presumably because you've already escaped the data in some
more sophisticated manner).
.SH "OPTIONAL OO INTERFACE"
The default values for the options described above are unlikely to suit
everyone.  The object oriented interface allows you to effectively override
\fBXML::Simple\fR's defaults with your preferred values.  It works like this:
.PP
First create an XML::Simple parser object with your preferred defaults:
.PP
.Vb 1
\&  my $xs = new XML::Simple(forcearray => 1, keeproot => 1);
.Ve
Now call \f(CWXMLin()\fR or \f(CWXMLout()\fR as a method of that object:
.PP
.Vb 2
\&  my $ref = $xs->XMLin($xml);
\&  my $xml = $xs->XMLout($ref);
.Ve
You can also specify options when you make the method calls and these values
will be merged with the values specified when the object was created.  Values
specified in a method call take precedence.
.SH "ERROR HANDLING"
The XML standard is very clear on the issue of non-compliant documents.  An
error in parsing any single element (for example a missing end tag) must cause
the whole document to be rejected.  \fBXML::Simple\fR will die with an
appropriate message if it encounters a parsing error.
.PP
If dying is not appropriate for your application, you should arrange to call
\f(CWXMLin()\fR in an eval block and look for errors in $@.  eg:
.PP
.Vb 2
\&    my $config = eval { XMLin() };
\&    PopUpMessage($@) if($@);
.Ve
Note, there is a common misconception that use of \fBeval\fR will significantly
slow down a script.  While that may be true when the code being eval'd is in a
string, it is not true of code like the sample above.
.SH "EXAMPLES"
When \f(CWXMLin()\fR reads the following very simple piece of XML:
.PP
.Vb 1
\&    <opt username="testuser" password="frodo"></opt>
.Ve
it returns the following data structure:
.PP
.Vb 4
\&    {
\&      'username' => 'testuser',
\&      'password' => 'frodo'
\&    }
.Ve
The identical result could have been produced with this alternative XML:
.PP
.Vb 1
\&    <opt username="testuser" password="frodo" />
.Ve
Or this (although see \*(L'forcearray\*(R' option for variations):
.PP
.Vb 4
\&    <opt>
\&      <username>testuser</username>
\&      <password>frodo</password>
\&    </opt>
.Ve
Repeated nested elements are represented as anonymous arrays:
.PP
.Vb 9
\&    <opt>
\&      <person firstname="Joe" lastname="Smith">
\&        <email>joe@smith.com</email>
\&        <email>jsmith@yahoo.com</email>
\&      </person>
\&      <person firstname="Bob" lastname="Smith">
\&        <email>bob@smith.com</email>
\&      </person>
\&    </opt>
.Ve
.Vb 17
\&    {
\&      'person' => [
\&                    {
\&                      'email' => [
\&                                   'joe@smith.com',
\&                                   'jsmith@yahoo.com'
\&                                 ],
\&                      'firstname' => 'Joe',
\&                      'lastname' => 'Smith'
\&                    },
\&                    {
\&                      'email' => 'bob@smith.com',
\&                      'firstname' => 'Bob',
\&                      'lastname' => 'Smith'
\&                    }
\&                  ]
\&    }
.Ve
Nested elements with a recognised key attribute are transformed (folded) from
an array into a hash keyed on the value of that attribute:
.PP
.Vb 5
\&    <opt>
\&      <person key="jsmith" firstname="Joe" lastname="Smith" />
\&      <person key="tsmith" firstname="Tom" lastname="Smith" />
\&      <person key="jbloggs" firstname="Joe" lastname="Bloggs" />
\&    </opt>
.Ve
.Vb 16
\&    {
\&      'person' => {
\&                    'jbloggs' => {
\&                                   'firstname' => 'Joe',
\&                                   'lastname' => 'Bloggs'
\&                                 },
\&                    'tsmith' => {
\&                                  'firstname' => 'Tom',
\&                                  'lastname' => 'Smith'
\&                                },
\&                    'jsmith' => {
\&                                  'firstname' => 'Joe',
\&                                  'lastname' => 'Smith'
\&                                }
\&                  }
\&    }
.Ve
The <anon> tag can be used to form anonymous arrays:
.PP
.Vb 6
\&    <opt>
\&      <head><anon>Col 1</anon><anon>Col 2</anon><anon>Col 3</anon></head>
\&      <data><anon>R1C1</anon><anon>R1C2</anon><anon>R1C3</anon></data>
\&      <data><anon>R2C1</anon><anon>R2C2</anon><anon>R2C3</anon></data>
\&      <data><anon>R3C1</anon><anon>R3C2</anon><anon>R3C3</anon></data>
\&    </opt>
.Ve
.Vb 10
\&    {
\&      'head' => [
\&                  [ 'Col 1', 'Col 2', 'Col 3' ]
\&                ],
\&      'data' => [
\&                  [ 'R1C1', 'R1C2', 'R1C3' ],
\&                  [ 'R2C1', 'R2C2', 'R2C3' ],
\&                  [ 'R3C1', 'R3C2', 'R3C3' ]
\&                ]
\&    }
.Ve
Anonymous arrays can be nested to arbirtrary levels and as a special case, if
the surrounding tags for an XML document contain only an anonymous array the
arrayref will be returned directly rather than the usual hashref:
.PP
.Vb 5
\&    <opt>
\&      <anon><anon>Col 1</anon><anon>Col 2</anon></anon>
\&      <anon><anon>R1C1</anon><anon>R1C2</anon></anon>
\&      <anon><anon>R2C1</anon><anon>R2C2</anon></anon>
\&    </opt>
.Ve
.Vb 5
\&    [
\&      [ 'Col 1', 'Col 2' ],
\&      [ 'R1C1', 'R1C2' ],
\&      [ 'R2C1', 'R2C2' ]
\&    ]
.Ve
.SH "WHERE TO FROM HERE?"
\fBXML::Simple\fR is by nature very simple.  
.Ip "\(bu" 4
The parsing process liberally disposes of \*(L'surplus\*(R' whitespace \- some 
applications will be sensitive to this.
.Ip "\(bu" 4
Slurping data into a hash will implicitly discard information about attribute
order.  Normally this would not be a problem because any items for which order
is important would typically be encoded as elements rather than attributes.
However \fB\s-1XML::\s0Simple\fR's aggressive slurping and folding algorithms can
defeat even these techniques.
.Ip "\(bu" 4
\s-1XML\s0 elements containing both text content and nested elements (eg: marked-up
text) are not parsed in a useful way.
.Ip "\(bu" 4
The \s-1API\s0 offers little control over the output of \f(CWXMLout()\fR.  In particular,
it is not especially likely that feeding the output from \f(CWXMLin()\fR into
\f(CWXMLout()\fR will reproduce the original \s-1XML\s0 (although passing the output from
\f(CWXMLout()\fR into \f(CWXMLin()\fR should reproduce the original data structure).
.Ip "\(bu" 4
\f(CWXMLout()\fR does not currently support encodings (although it shouldn't stand
in your way if you feed it encoded data).
.Ip "\(bu" 4
If you're attempting to get the output from \f(CWXMLout()\fR to conform to a
specific \s-1DTD\s0, you're almost certainly using the wrong tool for the job.
.PP
If any of these points are a problem for you, then \fB\s-1XML::\s0Simple\fR is probably
not the right module for your application.  The following section is intended
to give pointers which might help you select a more powerful tool \- it's a bit
sketchy right now but submissions are welcome.
.Ip "\s-1XML::\s0Parser" 4
\fB\s-1XML::\s0Simple\fR is built on top of \fB\s-1XML::\s0Parser\fR, so if you have \fB\s-1XML::\s0Simple\fR
working you already have \fB\s-1XML::\s0Parser\fR installed.  This is a comprehensive,
fast, industrial strength (non-validating) parsing tool built on top of James
Clark's \*(L'expat\*(R' library.  It does support converting \s-1XML\s0 into a Perl tree
structure but for arbritrarily large documents you're probably better off
defining handler routines for \fB\s-1XML::\s0Parser\fR to call as each element is parsed.
The distribution includes a number of sample applications.
.Ip "\s-1XML::DOM\s0" 4
The data structure returned by \fB\s-1XML::\s0Simple\fR was designed for convenience
rather than standards compliance.  \fB\s-1XML::DOM\s0\fR is a parser built on top of
\fB\s-1XML::\s0Parser\fR, which returns a \*(L'Document\*(R' object conforming to the \s-1API\s0 of the
Document Object Model as described at http://www.w3.org/\s-1TR/REC\s0\-\s-1DOM\s0\-Level-1 .
This Document object can then be examined, modified and written back out to a
file or converted to a string. 
.Ip "\s-1XML::\s0Grove" 4
Compliance with the Document Object Model might be particularly useful when
porting code to or from another language.  However, if you're looking for a
simpler, \*(L'perlish\*(R' object interface, take a look at \fB\s-1XML::\s0Grove\fR.
.Ip "\s-1XML::\s0Twig" 4
\s-1XML::\s0Twig offers a tree-oriented interface to a document while still allowing
the processing of documents of any size. It allows processing chunks of
documents in tree-mode which can then be flushed or purged from the memory.
The \s-1XML::\s0Twig page is at http://standards.ieee.org/resources/spasystem/twig/
.Ip "libxml-perl" 4
\fBlibxml-perl\fR is a collection of Perl modules, scripts, and documents for
working with \s-1XML\s0 in Perl. The distribution includes PerlSAX \- a Perl
implementation of the \s-1SAX\s0 \s-1API\s0.  It also include \fB\s-1XML::\s0PatAct\fR modules for
processing \s-1XML\s0 by defining patterns and associating them with actions.  For more
details see http://bitsko.slc.ut.us/libxml-perl/ .
.Ip "\s-1XML::\s0Writer" 4
\fB\s-1XML::\s0Writer\fR is a helper module for Perl programs that write a \s-1XML\s0 documents.
.Ip "\s-1XML::\s0Dumper" 4
\fB\s-1XML::\s0Dumper\fR dumps Perl data to a structured \s-1XML\s0 format. \fB\s-1XML::\s0Dumper\fR can
also read \s-1XML\s0 data that was previously dumped by the module and convert it back
to Perl. 
.PP
Don't forget to check out the Perl \s-1XML\s0 \s-1FAQ\s0 at:
http://www.perlxml.com/faq/perl-xml-faq.html
.SH "STATUS"
This version (1.04) is the current stable version.  
.SH "SEE ALSO"
\fBXML::Simple\fR requires \fBXML::Parser\fR and \fBFile::Spec\fR.  The optional caching
functions require \fBStorable\fR.
.SH "COPYRIGHT"
Copyright 1999 Grant McLean <grantm@web.co.nz>
.PP
This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself. 

.rn }` ''
.IX Title "Simple 3"
.IX Name "XML::Simple - Trivial API for reading and writing XML (esp config files)"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "QUICK START"

.IX Header "DESCRIPTION"

.IX Subsection "\fIXMLin()\fR"

.IX Item "A filename"

.IX Item "undef"

.IX Item "A string of \s-1XML\s0"

.IX Item "An \s-1IO::\s0Handle object"

.IX Subsection "\fIXMLout()\fR"

.IX Subsection "Caveats"

.IX Header "OPTIONS"

.IX Item "keyattr => [ list ] (\fBin+out\fR)"

.IX Item "keyattr => { list } (\fBin+out\fR)"

.IX Item "searchpath => [ list ] (\fBin\fR)"

.IX Item "forcearray => 1 (\fBin\fR)"

.IX Item "forcearray => [ name(s) ] (\fBin\fR)"

.IX Item "cache => [ cache scheme(s) ] (\fBin\fR)"

.IX Item "storable"

.IX Item "memshare"

.IX Item "memcopy"

.IX Item "keeproot => 1 (\fBin+out\fR)"

.IX Item "rootname => \*(N'string\*(T' (\fBout\fR)"

.IX Item "contentkey => \*(N'keyname\*(T' (\fBin+out\fR)"

.IX Item "xmldecl => 1  or  xmldecl => \*(N'string\*(T'  (\fBout\fR)"

.IX Item "outputfile => <file specifier> (\fBout\fR)"

.IX Item "noescape => 1 (\fBout\fR)"

.IX Header "OPTIONAL OO INTERFACE"

.IX Header "ERROR HANDLING"

.IX Header "EXAMPLES"

.IX Header "WHERE TO FROM HERE?"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\s-1XML::\s0Parser"

.IX Item "\s-1XML::DOM\s0"

.IX Item "\s-1XML::\s0Grove"

.IX Item "\s-1XML::\s0Twig"

.IX Item "libxml-perl"

.IX Item "\s-1XML::\s0Writer"

.IX Item "\s-1XML::\s0Dumper"

.IX Header "STATUS"

.IX Header "SEE ALSO"

.IX Header "COPYRIGHT"

