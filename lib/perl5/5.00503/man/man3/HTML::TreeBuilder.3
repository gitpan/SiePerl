.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH lib::HTML::TreeBuilder 3 "perl 5.005, patch 03" "27/Mar/2000" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
HTML::TreeBuilder \- Parser that builds a HTML syntax tree
.SH "SYNOPSIS"
.PP
.Vb 11
\&  foreach my $file_name (@ARGV) {
\&    my $tree = HTML::TreeBuilder->new; # empty tree
\&    $tree->parse_file($file_name);
\&    print "Hey, here's a dump of the parse tree of $file_name:\en";
\&    $tree->dump; # a method we inherit from HTML::Element
\&    print "And here it is, bizarrely rerendered as HTML:\en",
\&      $tree->as_HTML, "\en";
\&    
\&    # Now that we're done with it, we must destroy it.
\&    $tree = $tree->delete;
\&  }
.Ve
.SH "DESCRIPTION"
This class is for HTML syntax trees that get built out of HTML
source.  The way to use it is to:
.PP
1. start a new (empty) HTML::TreeBuilder object,
.PP
2. then use one of the methods from HTML::Parser (presumably with
\f(CW$tree\fR\->\fIparse_file\fR\|($filename) for files, or with
\f(CW$tree\fR\->\fIparse\fR\|($document_content) and \f(CW$tree\fR\->eof if you've got
the content in a string) to parse the HTML
document into the tree \f(CW$tree\fR.
.PP
3. do whatever you need to do with the syntax tree, presumably
involving traversing it looking for some bit of information in it,
.PP
4. and finally, when you're done with the tree, call \f(CW$tree\fR\->delete to
erase the contents of the tree from memory.  This kind of thing
usually isn't necessary with most Perl objects, but it's necessary for
TreeBuilder objects.  See the \fIHTML::Element\fR manpage for a more verbose
explanation of why this is the case.
.SH "METHODS AND ATTRIBUTES"
Objects of this class inherit the methods of both HTML::Parser and
HTML::Element.  The methods inherited from HTML::Parser are used for
building the HTML tree, and the methods inherited from HTML::Element
are what you use to scrutinize the tree.  Besides this
(HTML::TreeBuilder) documentation, you must also carefully read the
HTML::Element documentation, and also skim the HTML::Parser
documentation -- probably only its parse and parse_file methods are of
interest.
.PP
The following methods native to HTML::TreeBuilder all control how
parsing takes place; they should be set \fIbefore\fR you try parsing into
the given object.  You can set the attributes by passing a TRUE or
FALSE value as argument.  E.g., \f(CW$p\fR\->implicit_tags returns the current
setting for the implicit_tags option, \f(CW$p\fR\->\fIimplicit_tags\fR\|(1) turns that
option on, and \f(CW$p\fR\->\fIimplicit_tags\fR\|(0) turns it off.
.Ip "$p->implicit_tags(value)" 4
Setting this attribute to true will instruct the parser to try to
deduce implicit elements and implicit end tags.  If it is false you
get a parse tree that just reflects the text as it stands, which is
unlikely to be useful for anything but quick and dirty parsing.
Default is true.
.Sp
Implicit elements have the \fIimplicit()\fR attribute set.
.Ip "$p->implicit_body_p_tag(value)" 4
This controls an aspect of implicit element behavior, if implicit_tags
is on:  If a text element (\s-1PCDATA\s0) or a phrasal element (such as
\*(L"<em>") is to be inserted under \*(L"<body>\*(R", two things
can happen: if implicit_body_p_tag is true, it's placed under a new,
implicit \*(L"<p>\*(R" tag.  (Past DTDs suggested this was the only
correct behavior, and this is how past versions of this module
behaved.)  But if implicit_body_p_tag is false, nothing is implicated
-- the \s-1PCDATA\s0 or phrasal element is simply placed under
\*(L"<body>\*(R".  Default is false.
.Ip "$p->ignore_unknown(value)" 4
This attribute controls whether unknown tags should be represented as
elements in the parse tree, or whether they should be ignored. 
Default is true (to ignore unknown tags.)
.Ip "$p->ignore_text(value)" 4
Do not represent the text content of elements.  This saves space if
all you want is to examine the structure of the document.  Default is
false.
.Ip "$p->ignore_ignorable_whitespace(value)" 4
If set to true, TreeBuilder will try to delete (and/or to avoid
creating) ignorable whitespace text nodes in the tree.  Default is
true.  (In fact, I'd be interested in hearing if there's ever a case
where you need this off, or where leaving it on leads to incorrect
behavior.)
.Ip "$p->warn(value)" 4
This determines whether syntax errors during parsing should generate
warnings, emitted via Perl's \f(CWwarn\fR function.
.SH "HTML AND ITS DISCONTENTS"
HTML is rather harder to parse than people who write it generally
suspect.
.PP
Here's the problem: HTML is a kind of SGML that permits \*(L"minimization\*(R"
and \*(L"implication\*(R".  In short, this means that you don't have to close
every tag you open (because the opening of a subsequent tag may
implicitly close it), and if you use a tag that can't occur in the
context you seem to using it in, under certain conditions the parser
will be able to realize you mean to leave the current context and
enter the new one, that being the only one that your code could
correctly be interpreted in.
.PP
Now, this would all work flawlessly and unproblematically if: 1) all
the rules that both prescribe and describe HTML were (and had been)
clearly set out, and 2) everyone was aware of these rules and wrote
their code in compliance to them.
.PP
However, it didn't happen that way, and so most HTML pages are
difficult if not impossible to correctly parse with nearly any set of
straightforward SGML rules.  That's why the internals of
HTML::TreeBuilder consist of lots and lots of special cases -- instead
of being just a generic SGML parser with HTML DTD rules plugged in.
.SH "BUGS"
* Currently, it's assumed that \*(L"HTML\*(R" is the top node in the tree, and
that \*(L"HEAD\*(R" and \*(L"BODY\*(R" must be right under \*(L"HTML\*(R".  Framesets are
therefore coerced into being under \*(L"BODY\*(R", even if the document in
question has the \*(L"BODY\*(R" \fIinside\fR a \*(L"NOFRAMES\*(R" element. This may
change in a future version, \fIparticularly\fR if anyone points out a
case where this is troublesome for them.
.PP
* Bad HTML code will, often as not, make for a bad parse tree. 
Regrettable, but unavoidably true.
.SH "BUG REPORTS"
When a document parses in a way different from how you think it
should, I ask that you report this to me as a bug.  The first thing
you should do is copy the document, trim out as much of it as you can
while still producing the bug in question, and \fIthen\fR email me that
mini-document at \f(CWsburke@netadventure.net\fR, with a note as to how it
parses (presumably including its \f(CW$tree\fR\->dump output), and then a
\fIcareful and clear\fR explanation of where you think the parser is
going astray, and how you would prefer that it work instead.
.SH "SEE ALSO"
the \fIHTML::Parser\fR manpage, the \fIHTML::Element\fR manpage
.SH "COPYRIGHT"
Copyright 1995-1998 Gisle Aas; copyright 1999, 2000 Sean M. Burke.
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "AUTHOR"
Original author Gisle Aas <gisle@aas.no>; current maintainer
Sean M. Burke, <sburke@netadventure.net>

.rn }` ''
.IX Title "lib::HTML::TreeBuilder 3"
.IX Name "HTML::TreeBuilder - Parser that builds a HTML syntax tree"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Header "METHODS AND ATTRIBUTES"

.IX Item "$p->implicit_tags(value)"

.IX Item "$p->implicit_body_p_tag(value)"

.IX Item "$p->ignore_unknown(value)"

.IX Item "$p->ignore_text(value)"

.IX Item "$p->ignore_ignorable_whitespace(value)"

.IX Item "$p->warn(value)"

.IX Header "HTML AND ITS DISCONTENTS"

.IX Header "BUGS"

.IX Header "BUG REPORTS"

.IX Header "SEE ALSO"

.IX Header "COPYRIGHT"

.IX Header "AUTHOR"

