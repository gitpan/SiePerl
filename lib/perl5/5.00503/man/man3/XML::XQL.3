.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH XQL 3 "perl 5.005, patch 03" "23/Jul/1999" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
XML::XQL \- A perl module for querying XML tree structures with XQL
.SH "SYNOPSIS"
.PP
.Vb 2
\& use XML::XQL;
\& use XML::XQL::DOM;
.Ve
.Vb 2
\& $parser = new XML::DOM::Parser;
\& $doc = $parser->parsefile ("file.xml");
.Ve
.Vb 3
\& # Return all elements with tagName='title' under the root element 'book'
\& $query = new XML::XQL::Query (Expr => "book/title");
\& @result = $query->solve ($doc);
.Ve
.Vb 2
\& # Or (to save some typing)
\& @result = XML::XQL::solve ("book/title", $doc);
.Ve
.SH "DESCRIPTION"
The XML::XQL module implements the XQL (XML Query Language) proposal
submitted to the XSL Working Group in September 1998.
The spec can be found at: http://www.w3.org/TandS/QL/QL98/pp/xql.html
Most of the contents related to the XQL syntax can also be found in the
XML::XQL::Tutorial that comes with this distribution. 
Note that XQL is not the same as XML\-QL!
.PP
The current implementation only works with the XML::DOM module, but once the
design is stable and the major bugs are flushed out, other extensions might
follow, e.g. for XML::Grove.
.PP
XQL was designed to be extensible and this implementation tries to stick to that.
Users can add their own functions, methods, comparison operators and data types.
Plugging in a new XML tree structure (like XML::Grove) should be a piece of cake.
.PP
To use the XQL module, either
.PP
.Vb 1
\&  use XML::XQL;
.Ve
or
.PP
.Vb 1
\&  use XML::XQL::Strict;
.Ve
The Strict module only provides the core XQL functionality as found in the
XQL spec. By default (i.e. by using XML::XQL) you get \*(L'XQL+\*(R', which has
some additional features.
.PP
See the section \*(L'Additional Features in XQL+\*(R' for the differences.
.PP
This module is still in development. See the To-do list in XQL.pm for what
still needs to be done. Any suggestions are welcome, the sooner these 
implementation issues are resolved, the faster we can all use this module.
.PP
If you find a bug, you would do me great favor by sending it to me in the
form of a test case. See the file t/template.t that comes with this distribution.
.PP
If you have written a cool comparison operator, function, method or XQL data 
type that you would like to share, send it to enno@att.com and I will
add it to this module.
.SH "XML::XQL global functions"
.Ip "solve (\s-1QUERY_STRING\s0, \s-1INPUT_LIST\s0...)" 4
.Sp
.Vb 1
\& @result = XML::XQL::solve ("doc//book", $doc);
.Ve
This is provided as a shortcut for:
.Sp
.Vb 2
\& $query = new XML::XQL::Query (Expr => "doc//book");
\& @result = $query->solve ($doc);
.Ve
.Ip "defineFunction (\s-1NAME\s0, \s-1FUNCREF\s0, \s-1ARGCOUNT\s0 [, \s-1ALLOWED_OUTSIDE\s0 [, \s-1CONST\s0, [\s-1QUERY_ARG\s0]]])" 4
Defines the \s-1XQL\s0 function (at the global level, i.e. for all newly created 
queries) with the specified \s-1NAME\s0. The \s-1ARGCOUNT\s0 parameter can either be a single
number or a reference to a list with numbers. 
A single number expands to [\s-1ARGCOUNT\s0, \s-1ARGCOUNT\s0]. The list contains pairs of 
numbers, indicating the number of arguments that the function allows. The value
\-1 means infinity. E.g. [2, 5, 7, 9, 12, \-1] means that the function can have
2, 3, 4, 5, 7, 8, 9, 12 or more arguments.
The number of arguments is checked when parsing the \s-1XQL\s0 query string.
.Sp
The second parameter must be a reference to a Perl function or an anonymous
sub. E.g. \*(L'\e&my_func\*(R' or \*(L'sub { ... code ... }\*(R'
.Sp
If \s-1ALLOWED_OUTSIDE\s0 (default is 0) is set to 1, the function or method may 
also be used outside subqueries in \fInode queries\fR.
(See NodeQuery parameter in Query constructor)
.Sp
If \s-1CONST\s0 (default is 0) is set to 1, the function is considered to be 
\*(L"constant\*(R". See the section on \fIConstant Function Invocations\fR for details.
.Sp
If \s-1QUERY_ARG\s0 (default is 0) is not \-1, the argument with that index is
considered to be a \*(L'query parameter\*(R'. If the query parameter is a subquery, 
that returns multiple values, the result list of the function invocation will
contain one result value for each value of the subquery. 
E.g. \*(L'\fIlength\fR\|(book/author)\*(R' will return a list of Numbers, denoting the string 
lengths of all the author elements returned by \*(L'book/author\*(R'.
.Sp
Note that only methods (not functions) may appear after a Bang \*(L"!\*(R" operator.
This is checked when parsing the \s-1XQL\s0 query string.
.Sp
See also: defineMethod
.Ip "generateFunction (\s-1NAME\s0, \s-1FUNCNAME\s0, \s-1RETURN_TYPE\s0 [, \s-1ARGCOUNT\s0 [, \s-1ALLOWED_OUTSIDE\s0 [, \s-1CONST\s0 [, \s-1QUERY_ARG\s0]]]])" 4
Generates and defines an \s-1XQL\s0 function wrapper for the Perl function with the
name \s-1FUNCNAME\s0. The function name will be \s-1NAME\s0 in \s-1XQL\s0 query expressions.
The return type should be one of the builtin \s-1XQL\s0 Data Types or a class derived
from \s-1XML::XQL::\s0PrimitiveType (see the section on \fIAdding Data Types\fR.)
See defineFunction for the meaning of \s-1ARGCOUNT\s0, \s-1ALLOWED_OUTSIDE\s0, \s-1CONST\s0 and
\s-1QUERY_ARG\s0.
.Sp
Function values are always converted to Perl strings with xql_toString before
they are passed to the Perl function implementation. The function return value
is cast to an object of type \s-1RETURN_TYPE\s0, or to the empty list [] if the
result is undef. It uses expandType to expand \s-1XQL\s0 primitive type names.
If \s-1RETURN_TYPE\s0 is \*(L"*\*(R", it returns the function 
result as is, unless the function result is undef, in which case it returns [].
.Ip "defineMethod (\s-1NAME\s0, \s-1FUNCREF\s0, \s-1ARGCOUNT\s0 [, \s-1ALLOWED_OUTSIDE\s0])" 4
Defines the \s-1XQL\s0 method (at the global level, i.e. for all newly created 
queries) with the specified \s-1NAME\s0. The \s-1ARGCOUNT\s0 parameter can either be a single
number or a reference to a list with numbers. 
A single number expands to [\s-1ARGCOUNT\s0, \s-1ARGCOUNT\s0]. The list contains pairs of 
numbers, indicating the number of arguments that the method allows. The value
\-1 means infinity. E.g. [2, 5, 7, 9, 12, \-1] means that the method can have
2, 3, 4, 5, 7, 8, 9, 12 or more arguments.
The number of arguments is checked when parsing the \s-1XQL\s0 query string.
.Sp
The second parameter must be a reference to a Perl function or an anonymous
sub. E.g. \*(L'\e&my_func\*(R' or \*(L'sub { ... code ... }\*(R'
.Sp
If \s-1ALLOWED_OUTSIDE\s0 (default is 0) is set to 1, the function or method may 
also be used outside subqueries in \fInode queries\fR.
(See NodeQuery parameter in Query constructor)
.Sp
Note that only methods (not functions) may appear after a Bang \*(L"!\*(R" operator.
This is checked when parsing the \s-1XQL\s0 query string.
.Sp
See also: defineFunction
.Ip "defineComparisonOperators (\s-1NAME\s0 => \s-1FUNCREF\s0 [, \s-1NAME\s0 => \s-1FUNCREF\s0]*)" 4
Defines \s-1XQL\s0 comparison operators at the global level.
The \s-1FUNCREF\s0 parameters must be a references to a Perl function or an anonymous
sub. E.g. \*(L'\e&my_func\*(R' or \*(L'sub { ... code ... }\*(R'
.Sp
E.g. define the operators \f(CW$my_op\fR$ and \f(CW$my_op2\fR$:
.Sp
.Vb 2
\& defineComparisonOperators ('my_op' => \e&my_op,
\&                            'my_op2' => sub { ... insert code here ... });
.Ve
.Ip "defineElementValueConvertor (\s-1TAG_NAME\s0, \s-1FUNCREF\s0)" 4
Defines that the result of the \fIvalue()\fR call for Elements with the specified
\s-1TAG_NAME\s0 uses the specified function. The function will receive
two parameters. The second one is the \s-1TAG_NAME\s0 of the Element node 
and the first parameter is the Element node itself.
\s-1FUNCREF\s0 should be a reference to a Perl function, e.g. \e&my_sub, or
an anonymous sub.
.Sp
E.g. to define that all Elements with tag name \*(L'date-of-birth\*(R' should return
\s-1XML::XQL::\s0Date objects:
.Sp
.Vb 7
\&        defineElementValueConvertor ('date-of-birth', sub {
\&                my $elem = shift;
\&                # Always pass in the node as the second parameter. This is
\&                # the reference node for the object, which is used when
\&                # sorting values in document order.
\&                new XML::XQL::Date ($elem->xql_text, $elem); 
\&        });
.Ve
These convertors can only be specified at a global level, not on a per query
basis. To undefine a convertor, simply pass a \s-1FUNCREF\s0 of undef.
.Ip "defineAttrValueConvertor (\s-1ELEM_TAG_NAME\s0, \s-1ATTR_NAME\s0, \s-1FUNCREF\s0)" 4
Defines that the result of the \fIvalue()\fR call for Attributes with the specified
\s-1ATTR_NAME\s0 and a parent Element with the specified \s-1ELEM_TAG_NAME\s0 
uses the specified function. An \s-1ELEM_TAG_NAME\s0 of \*(L"*\*(R" will match regardless of
the tag name of the parent Element. The function will receive
3 parameters. The third one is the tag name of the parent Element (even if 
\s-1ELEM_TAG_NAME\s0 was \*(L"*"), the second is the \s-1ATTR_NAME\s0 and the first is the 
Attribute node itself.
\s-1FUNCREF\s0 should be a reference to a Perl function, e.g. \e&my_sub, or
an anonymous sub.
.Sp
These convertors can only be specified at a global level, not on a per query
basis. To undefine a convertor, simply pass a \s-1FUNCREF\s0 of undef.
.Ip "defineTokenQ (Q)" 4
Defines the token for the q// string delimiters at a global level.
The default value for \s-1XQL\s0+ is \*(L'q\*(R', for \s-1XML::XQL::\s0Strict it is undef.
A value of undef will deactivate this feature.
.Ip "defineTokenQQ (\s-1QQ\s0)" 4
Defines the token for the qq// string delimiters at a global level.
The default value for \s-1XQL\s0+ is \*(L'qq\*(R', for \s-1XML::XQL::\s0Strict it is undef.
A value of undef will deactivate this feature.
.Ip "expandType (\s-1TYPE\s0)" 4
Used internally to expand type names of \s-1XQL\s0 primitive types.
E.g. it expands \*(L"Number\*(R" to \*(L"\s-1XML::XQL::\s0Number\*(R" and is not case-sensitive, so
\*(L"number\*(R" and \*(L"NuMbEr\*(R" will both expand correctly.
.Ip "defineExpandedTypes (\s-1ALIAS\s0, \s-1FULL_NAME\s0 [, ...])" 4
For each pair of arguments it allows the class name \s-1FULL_NAME\s0 to be abbreviated
with \s-1ALIAS\s0. The definitions are used by \fIexpandType()\fR. 
(\s-1ALIAS\s0 is always converted to lowercase internally, because expandType 
is case-insensitive.)
.Sp
Overriding the \s-1ALIAS\s0 for \*(L"date\*(R", also affects the object type returned by the
the \fIdate()\fR function.
.Ip "setErrorContextDelimiters (\s-1START\s0, \s-1END\s0, \s-1BOLD_ON\s0, \s-1BOLD_OFF\s0)" 4
Sets the delimiters used when printing error messages during query evaluation.
The default delimiters on Unix are `tput smul` (underline on) and `tput rmal`
(underline off). On other systems (that don't have tput), the delimiters are
\*(L">>\*(R" and \*(L"<<\*(R" resp. 
.Sp
When printing the error message, the subexpression that caused the error will
be enclosed by the delimiters, i.e. underlined on Unix.
.Sp
For certain subexpressions the significant keyword, e.g. "$and$" is enclosed in 
the bold delimiters \s-1BOLD_ON\s0 (default: `tput bold` on Unix, "" elsewhere) and 
\s-1BOLD_OFF\s0 (default: (`tput rmul` . `tput smul`) on Unix, "" elsewhere, 
see \f(CW$BoldOff\fR in \s-1XML::XQL::XQL\s0.pm for details.)
.Ip "isEmptyList (\s-1VAR\s0)" 4
Returns 1 if \s-1VAR\s0 is [], else 0. Can be used in user defined functions.
.SH "XML::XQL::Query methods"
The following functions are also available at the query level, i.e. when called
on a Query object they only affect this Query and no others:
.PP
.Vb 2
\& defineFunction, defineMethod, defineComparisonOperators, 
\& defineTokenQ, defineTokenQQ
.Ve
See \*(L'XML::XQL Global functions\*(R' for details.
Another way to define these features for a particular Query is by passing the
appropriate values to the XML::XQL::Query constructor.
.Ip "solve (\s-1INPUT_LIST\s0...)" 4
Note that solve takes a list of nodes which are assumed to be in document order
and must belong to the same document. E.g:
.Sp
.Vb 3
\& $query = new XML::XQL::Query (Expr => "doc//book");
\& @result = $query->solve ($doc);
\& @result2 = $query->solve ($node1, $node2, $node3);
.Ve
.SH "XML::XQL::Query constructor"
Usage, e.g:
.PP
.Vb 9
\& $query = new XML::XQL::Query(
\&        Expr => "book/author",
\&        Func => [ myfunc => \e&my_func,          # define 2 functions
\&                  myfunc2 => \e&my_func2 ],
\&        FuncArgCount => [ myfunc2 => [2, -1] ], # myfunc2 has 2 or more args
\&        AllowedOutSideSubquery => [ myfunc => 1 ],
\&        ConstFunc => [ myfunc2 => 1],
\&        CompareOper => [ mycmp => \e&mycmp ],    # define comparison operator
\&        q => "str");                            # use str// as string delim
.Ve
.Ip "Expr => \s-1STRING\s0" 4
The query expression to be evaluated.
.Ip "NodeQuery => \s-1BOOLEAN\s0" 4
If set to 1, the query is a \fINode Query\fR as opposed to a 
\fIFull Query\fR (which is the default.) 
A node query is a query that is only capable of returning Nodes. 
A full query is capable of returning Node values and non-Node values. 
Non-Node values include \s-1XML\s0 Primitives, element type names, namespace \s-1URI\s0's, 
concatenated text nodes, and node type names. The distinction is significant
because node queries may appear as \s-1XSL\s0 match and select patterns, while full 
queries have use in other applications.
The difference between the two forms of queries is trivial and exists only as 
constraints on the syntax of node queries. 
Node queries may contain nested full queries.
.Ip "Func => [ \s-1FUNCNAME\s0 => \s-1FUNCREF\s0, ...]" 4
Defines one or more functions. \s-1FUNCNAME\s0 is the name as used in the query 
expression. \s-1FUNCREF\s0 can be either a function reference like \e&my_func or
an anonymous sub.
See also: defineFunction
.Ip "Method => [ \s-1FUNCNAME\s0 => \s-1FUNCREF\s0, ...]" 4
Defines one or more methods. \s-1FUNCNAME\s0 is the name as used in the query 
expression. \s-1FUNCREF\s0 can be either a function reference like \e&my_func or
an anonymous sub.
See also: defineMethod
.Ip "FuncArgCount => [ \s-1FUNCNAME\s0 => \s-1ARGCOUNT\s0, ...]" 4
Defines the number of arguments for one or more functions or methods. 
\s-1FUNCNAME\s0 is the name as used in the query expression. 
See also: defineFunction and defineMethod
.Ip "AllowedOutsideSubquery => [ \s-1FUNCNAME\s0 => \s-1BOOLEAN\s0, ...]" 4
Defines whether the specified function or method is allowed outside
subqueries. \s-1FUNCNAME\s0 is the name as used in the query expression. 
See also: defineFunction and defineMethod
.Ip "ConstFunc => [ \s-1FUNCNAME\s0 => \s-1BOOLEAN\s0, ...]" 4
Defines whether the function (not method!) is a \*(L"constant\*(R" function.
\s-1FUNCNAME\s0 is the name as used in the query expression. 
See the section on \fIConstant Function Invocations\fR for a definition of \*(L"constant\*(R"
See also: defineFunction and defineMethod
.Ip "CompareOper => [ \s-1OPERNAME\s0 => \s-1FUNCREF\s0, ...]" 4
Defines the comparison operator with the specified \s-1OPERNAME\s0, e.g. if
\s-1OPERNAME\s0 is \*(L"contains\*(R", you can use \*(L"$contains$\*(R" in the query.
See also: defineComparisonOperators
.Ip "q => \s-1TOKEN\s0" 4
Defines the q// token. See also: defineTokenQ
.Ip "qq => \s-1TOKEN\s0" 4
Defines the qq// token. See also: defineTokenQQ
.Ip "Error => \s-1FUNCREF\s0" 4
Defines the function that is called when errors occur during parsing the
query expression. The default function prints an error message to \s-1STDERR\s0.
.Ip "Debug => \s-1FLAGS\s0" 4
Sets the debug level for the Yapp parser that parses the query expression.
Default value is 0 (don't print anything). The maximum value is 0x17, which
prints a lot of stuff. See the Parse::Yapp manpage for the meaning of the
individual bits.
.Ip "Reserved hash keys" 4
Users may add their own (key, value) pairs to the Query constructor.
Beware that the key \*(L'Tree\*(R' is used internally.
.SH "Additional Features in XQL+"
.Ip "Sequence operators \*(N';\*(T' and \*(N';;\*(T'" 4
The sequence operators \*(L';\*(R' (precedes) and \*(L';;\*(R' (immediately precedes) are
not in the \s-1XQL\s0 spec, but are described in \*(L'The Design of \s-1XQL\s0\*(R' by Jonathan Robie
who is one of the designers of \s-1XQL\s0. It can be found at
http://www.texcel.no/whitepapers/xql-design.html
See also the \s-1XQL\s0 Tutorial for a description of what they mean.
.Ip "q// and qq// String Tokens" 4
String tokens a la q// and qq// are allowed. q// evaluates like Perl's single 
quotes and qq// like Perl's double quotes. Note that the default \s-1XQL\s0 strings do
not allow escaping etc., so it's not possible to define a string with both
single and double quotes. If \*(L'q\*(R' and \*(L'qq\*(R' are not to your liking, you may
redefine them to something else or undefine them altogether, by assigning undef
to them. E.g:
.Sp
.Vb 3
\& # at a global level - shared by all queries (that don't (re)define 'q')
\& XML::XQL::defineTokenQ ('k');
\& XML::XQL::defineTokenQQ (undef);
.Ve
.Vb 4
\& # at a query level - only defined for this query
\& $query = new XML::XQL::Query (Expr => "book/title", q => 'k', qq => undef);
\& 
\&From now on k// works like q// did and qq// doesn't work at all anymore.
.Ve
.Ip "Query strings can have embedded Comments" 4
For example:
.Sp
.Vb 2
\& $queryExpr = "book/title          # this comment is inside the query string
\&               [. = 'Moby Dick']"; # this comment is outside 
.Ve
.Ip "Optional dollar delimiters and case-insensitive \s-1XQL\s0 keywords" 4
The following \s-1XQL\s0 keywords are case-insensitive and the dollar sign delimiters 
may be omitted: \f(CW$and\fR$, \f(CW$or\fR$, \f(CW$not\fR$, \f(CW$union\fR$, \f(CW$intersect\fR$, \f(CW$to\fR$, \f(CW$any\fR$, \f(CW$all\fR$,
\f(CW$eq\fR$, \f(CW$ne\fR$, \f(CW$lt\fR$, \f(CW$gt\fR$, \f(CW$ge\fR$, \f(CW$le\fR$, \f(CW$ieq\fR$, \f(CW$ine\fR$, \f(CW$ilt\fR$, \f(CW$igt\fR$, \f(CW$ige\fR$, \f(CW$ile\fR$.
.Sp
E.g. \f(CW$AND\fR$, \f(CW$And\fR$, \f(CW$aNd\fR$, and, And, aNd are all valid replacements for \f(CW$and\fR$.
.Sp
Note that \s-1XQL\s0+ comparison operators ($match$, \f(CW$no_match\fR$, \f(CW$isa\fR$, \f(CW$can\fR$) still
require dollar delimiters and are case-sensitive.
.Ip "Comparison operator: $match$ or \*(N'=~\*(T'" 4
E.g. \*(L"book/title =~ \*(L'/(Moby|Dick)/']\*(R" will return all book titles containing
Moby or Dick. Note that the match expression needs to be quoted and should
contain the // or m// delimiters for Perl.
.Sp
When casting the values to be matched, both are converted to Text.
.Ip "Comparison operator: $no_match$ or \*(N'!~\*(T'" 4
E.g. \*(L"book/title !~ \*(L'/(Moby|Dick)/']\*(R" will return all book titles that don't 
contain Moby or Dick. Note that the match expression needs to be quoted and 
should contain the // or m// delimiters for Perl.
.Sp
When casting the values to be matched, both are converted to Text.
.Ip "Comparison operator: $isa$" 4
E.g. \*(L'//. \f(CW$isa\fR$ \*(L"\s-1XML::XQL::\s0Date"\*(R' returns all elements for which the \fIvalue()\fR 
function returns an \s-1XML::XQL::\s0Date object. (Note that the \fIvalue()\fR function can
be overridden to return a specific object type for certain elements and 
attributes.) It uses expandType to expand \s-1XQL\s0 primitive type names.
.Ip "Comparison operator: $can$" 4
E.g. \*(L'//. \f(CW$can\fR$ \*(L"swim"\*(R' returns all elements for which the \fIvalue()\fR 
function returns an object that implements the (Perl) \fIswim()\fR method. 
(Note that the \fIvalue()\fR function can be overridden to return a specific object 
type for certain elements and attributes.)
.Ip "Function: once (\s-1QUERY\s0)" 4
E.g. \*(L'\fIonce\fR\|(id("foo"))\*(R' will evaluate the \s-1QUERY\s0 expression only once per query.
Certain query results (like the above example) will always return the same
value within a query. Using \fIonce()\fR will cache the \s-1QUERY\s0 result for the
rest of the query. 
.Sp
Note that \*(L"constant\*(R" function invocations are always cached.
See also the section on \fIConstant Function Invocations\fR
.Ip "Function: subst (\s-1QUERY\s0, \s-1EXPR\s0, \s-1EXPR\s0 [,\s-1MODIFIERS\s0, [\s-1MODE\s0]])" 4
E.g. '\fIsubst\fR\|(book/title, "[M|m]oby", "Dick", "g")' will replace Moby or moby
with Dick globally ("g") in all book title elements. Underneath it uses Perl's
substitute operator s///. Don't worry about which delimiters are used underneath.
The function returns all the book/titles for which a substitution occurred.
The default \s-1MODIFIERS\s0 string is "" (empty.) The function name may be abbreviated 
to "s".
.Sp
For most Node types, it converts the \fIvalue()\fR to a string (with xql_toString)
to match the string and xql_setValue to set the new value in case it matched.
For \s-1XQL\s0 primitives (Boolean, Number, Text) and other data types (e.g. Date) it 
uses xql_toString to match the String and xql_setValue to set the result. 
Beware that performing a substitution on a primitive that was found in the 
original \s-1XQL\s0 query expression, changes the value of that constant.
.Sp
If \s-1MODE\s0 is 0 (default), it treats Element nodes differently by matching and
replacing \fItext blocks\fR occurring in the Element node. A text block is defined
as the concatenation of the raw text of subsequent Text, CDATASection and 
EntityReference nodes. In this mode it skips embedded Element nodes.
If a text block matches, it is replaced by a single Text node, regardless
of the original node \fItype\fR\|(s).
.Sp
If \s-1MODE\s0 is 1, it treats Element nodes like the other nodes, i.e. it converts
the \fIvalue()\fR to a string etc. Note that the default implementation of \fIvalue()\fR
calls \fItext()\fR, which normalizes whitespace and includes embedded Element
descendants (recursively.) This is probably not what you want to use in most
cases, but since I'm not a professional psychic... :\-)
.Ip "Function: map (\s-1QUERY\s0, \s-1CODE\s0)" 4
E.g. \*(L'\fImap\fR\|(book/title, \*(L"s/[M|m]oby/Dick/g; \f(CW$_\fR")\*(R' will replace Moby or moby
with Dick globally ("g") in all book title elements. Underneath it uses Perl's
map operator. The function returns all the book/titles for which a 
change occurred.
.Sp
??? add more specifics
.Ip "Function: eval (\s-1EXPR\s0 [,\s-1TYPE\s0])" 4
Evaluates the Perl expression \s-1EXPR\s0 and returns an object of the specified \s-1TYPE\s0.
It uses expandType to expand \s-1XQL\s0 primitive type names.
If the result of the eval was undef, the empty list [] is returned.
.Sp
E.g. \*(L'\fIeval\fR\|("2 + 5\*(R", \*(L"Number")\*(R' returns a Number object with the value 7, and
     \*(L'\fIeval\fR\|("%\s-1ENV\s0{\s-1USER\s0}")\*(R' returns a Text object with the user name.
.Sp
Consider using \fIonce()\fR to cache the return value, when the invocation will 
return the same result for each invocation within a query.
.Sp
??? add more specifics
.Ip "Function: new (\s-1TYPE\s0 [, \s-1QUERY\s0 [, \s-1PAR\s0] *])" 4
Creates a new object of the specified object \s-1TYPE\s0. The constructor may have any
number of arguments. The first argument of the constructor (the 2nd argument 
of the \fInew()\fR function) is considered to be a \*(L'query parameter\*(R'.
See defineFunction for a definition of \fIquery parameter\fR.
It uses expandType to expand \s-1XQL\s0 primitive type names.
.Ip "Method: DOM_nodeType ()" 4
Returns the \s-1DOM\s0 node type. Note that these are mostly the same as \fInodeType()\fR,
except for CDATASection and EntityReference nodes. \fIDOM_nodeType()\fR returns
4 and 5 respectively, whereas \fInodeType()\fR returns 3, because they are 
considered text nodes.
.Ip "Function wrappers for Perl builtin functions" 4
\s-1XQL\s0 function wrappers have been provided for most Perl builtin functions.
When using a Perl builtin function like \*(L"substr\*(R" in an \s-1XQL\s0+ querry, an
\s-1XQL\s0 function wrapper will be generated on the fly. The arguments to these
functions may be regular \s-1XQL\s0+ subqueries (that return one or more values) for
a \fIquery parameter\fR (see generateFunction for a definition.)
Most wrappers of Perl builtin functions have argument 0 for a query parameter,
except for: chmod (parameter 1 is the query parameter), chown (2) and utime (2).
The following funcitons have no query parameter, which means that all parameters
should be a single value: atan2, rand, srand, sprintf, rename, unlink, system.
.Sp
The function result is casted to the appropriate \s-1XQL\s0 primitive type (Number, 
Text or Boolean), or to an empty list if the result was undef.
.SH "Implementation Details"
.Ip "\s-1XQL\s0 Builtin Data Types" 4
The \s-1XQL\s0 engine uses the following object classes internally. Only Number, 
Boolean and Text are considered \fIprimitive \s-1XQL\s0 types\fR:
.Ip "\(bu \s-1XML::XQL::\s0Number" 8
For integers and floating point numbers.
.Ip "\(bu \s-1XML::XQL::\s0Boolean" 8
For booleans, e.g returned by \fItrue()\fR and \fIfalse()\fR.
.Ip "\(bu \s-1XML::XQL::\s0Text" 8
For string values.
.Ip "\(bu \s-1XML::XQL::\s0Date" 8
For date, time and date/time values. E.g. returned by the \fIdate()\fR function.
.Ip "\(bu \s-1XML::XQL::\s0Node" 8
Superclass of all \s-1XML\s0 node types. E.g. all subclasses of \s-1XML::DOM::\s0Node subclass
from this.
.Ip "\(bu Perl list reference" 8
Lists of values are passed by reference (i.e. using [] delimiters).
The empty list [] has a double meaning. It also means \*(L'undef\*(R' in certain 
situations, e.g. when a function invocation or comparison failed.
.Ip "Type casting in comparisons" 4
When two values are compared in an \s-1XML\s0 comparison (e.g. \f(CW$eq\fR$) the values are
first casted to the same data type. Node values are first replaced by their
\fIvalue()\fR (i.e. the \s-1XQL\s0 \fIvalue()\fR function is used, which returns a Text value by 
default, but may return any data type if the user so chooses.)
The resulting values are then casted to the type of the object with the highest
\fIxql_primType()\fR value. They are as follows: Node (0), Text (1), Number (2),
Boolean (3), Date (4), other data types (4 by default, but this may be
overriden by the user.)
.Sp
E.g. if one value is a Text value and the other is a Number, the Text value is 
cast to a Number and the resulting low-level (Perl) comparison is (for \f(CW$eq\fR$):
.Sp
.Vb 1
\& $number->xql_toString == $text->xql_toString
.Ve
If both were Text values, it would have been
.Sp
.Vb 1
\& $text1->xql_toString eq $text2->xql_toString
.Ve
Note that the \s-1XQL\s0 spec is vague and even conflicting where it concerns type
casting. This implementation resulted after talking to Joe Lapp, one of the
spec writers.
.Ip "Adding Data Types" 4
If you want to add your own data type, make sure it derives from 
\s-1XML::XQL::\s0PrimitiveType and implements the necessary methods.
.Sp
I will add more stuff here to explain it all, but for now, look at the code
for the primitive \s-1XQL\s0 types or the Date class (in Date.pm.)
.Ip "Document Order" 4
The \s-1XQL\s0 spec states that query results always return their values in 
\fIdocument order\fR, which means the order in which they appeared in the original
\s-1XML\s0 document. Values extracted from Nodes (e.g. with \fIvalue()\fR, \fItext()\fR, \fIrawText()\fR,
\fInodeName()\fR, etc.) always have a pointer to the reference node (i.e. the Node
from which the value was extracted.) These pointers are acknowledged when
(intermediate) result lists are sorted. Currently, the only place where a
result list is sorted is in a \f(CW$union\fR$ expression, which is the only place
where the result list can be unordered.
(If you find that this is not true, let me know.)
.Sp
Non-node values that have no associated reference node, always end up at the end
of the result list in the order that they were added.
The \s-1XQL\s0 spec states that the reference node for an \s-1XML\s0 Attribute is the Element
to which it belongs, and that the order of values with the same reference node
is undefined. This means that the order of an Element and its attributes would 
be undefined.
But since the \s-1XML::DOM\s0 module keeps track of the order of the attributes, the
\s-1XQL\s0 engine does the same, and therefore, the attributes of an Element are
sorted and appear after their parent Element in a sorted result list.
.Ip "Constant Function Invocations" 4
If a function always returns the same value when given \*(L"constant\*(R" arguments,
the function is considered to be \*(L"constant\*(R". A \*(L"constant\*(R" argument can be
either an \s-1XQL\s0 primitive (Number, Boolean, Text) or a \*(L"constant\*(R" function
invocation. E.g. 
.Sp
.Vb 5
\& date("12-03-1998")
\& true()
\& sin(0.3)
\& length("abc")
\& date(substr("12-03-1998 is the date", 0, 10))
.Ve
are constant, but not:
.Sp
.Vb 1
\& length(book[2])
.Ve
Results of constant function invocations are cached and calculated only once
for each query. See also the \s-1CONST\s0 parameter in defineFunction.
It is not necessary to wrap constant function invocations in a \fIonce()\fR call.
.Sp
Constant \s-1XQL\s0 functions are: date, true, false and a lot of the \s-1XQL\s0+
wrappers for Perl builtin functions. Function wrappers for certain builtins
are not made constant on purpose to force the invocation to be evaluated
every time, e.g. \*(L'\fImkdir\fR\|("/user/enno/my_dir\*(R", \*(L"0644")\*(R' (although constant
in appearance) may return different results for multiple invocations. 
See \f(CW%PerlFunc\fR in Plus.pm for details.
.Ip "Function: count ([\s-1QUERY\s0])" 4
The \fIcount()\fR function has no parameters in the \s-1XQL\s0 spec. In this implementation
it will return the number of \s-1QUERY\s0 results when passed a \s-1QUERY\s0 parameter.
.Ip "Method: text ([\s-1RECURSE\s0])" 4
When expanding an Element node, the \fItext()\fR method adds the expanded \fItext()\fR value
of sub-Elements. When \s-1RECURSE\s0 is set to 0 (default is 1), it will not include
sub-elements. This is useful e.g. when using the \f(CW$match\fR$ operator in a recursive
context (using the // operator), so it won't return parent Elements when one of
the children matches.
.Ip "Method: rawText ([\s-1RECURSE\s0])" 4
See \fItext()\fR.
.SH "SEE ALSO"
The XQL spec at http://www.w3.org/TandS/QL/QL98/pp/xql.html
.PP
The Design of XQL at http://www.texcel.no/whitepapers/xql-design.html
.PP
The DOM Level 1 specification at http://www.w3.org/TR/REC\-DOM\-Level-1
.PP
The XML spec (Extensible Markup Language 1.0) at http://www.w3.org/TR/REC\-xml
.PP
The XML::Parser and XML::Parser::Expat manual pages.
.SH "AUTHOR"
Please send bugs, comments and suggestions to Enno Derksen <\fIenno@att.com\fR>

.rn }` ''
.IX Title "XQL 3"
.IX Name "XML::XQL - A perl module for querying XML tree structures with XQL"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Header "XML::XQL global functions"

.IX Item "solve (\s-1QUERY_STRING\s0, \s-1INPUT_LIST\s0...)"

.IX Item "defineFunction (\s-1NAME\s0, \s-1FUNCREF\s0, \s-1ARGCOUNT\s0 [, \s-1ALLOWED_OUTSIDE\s0 [, \s-1CONST\s0, [\s-1QUERY_ARG\s0]]])"

.IX Item "generateFunction (\s-1NAME\s0, \s-1FUNCNAME\s0, \s-1RETURN_TYPE\s0 [, \s-1ARGCOUNT\s0 [, \s-1ALLOWED_OUTSIDE\s0 [, \s-1CONST\s0 [, \s-1QUERY_ARG\s0]]]])"

.IX Item "defineMethod (\s-1NAME\s0, \s-1FUNCREF\s0, \s-1ARGCOUNT\s0 [, \s-1ALLOWED_OUTSIDE\s0])"

.IX Item "defineComparisonOperators (\s-1NAME\s0 => \s-1FUNCREF\s0 [, \s-1NAME\s0 => \s-1FUNCREF\s0]*)"

.IX Item "defineElementValueConvertor (\s-1TAG_NAME\s0, \s-1FUNCREF\s0)"

.IX Item "defineAttrValueConvertor (\s-1ELEM_TAG_NAME\s0, \s-1ATTR_NAME\s0, \s-1FUNCREF\s0)"

.IX Item "defineTokenQ (Q)"

.IX Item "defineTokenQQ (\s-1QQ\s0)"

.IX Item "expandType (\s-1TYPE\s0)"

.IX Item "defineExpandedTypes (\s-1ALIAS\s0, \s-1FULL_NAME\s0 [, ...])"

.IX Item "setErrorContextDelimiters (\s-1START\s0, \s-1END\s0, \s-1BOLD_ON\s0, \s-1BOLD_OFF\s0)"

.IX Item "isEmptyList (\s-1VAR\s0)"

.IX Header "XML::XQL::Query methods"

.IX Item "solve (\s-1INPUT_LIST\s0...)"

.IX Header "XML::XQL::Query constructor"

.IX Item "Expr => \s-1STRING\s0"

.IX Item "NodeQuery => \s-1BOOLEAN\s0"

.IX Item "Func => [ \s-1FUNCNAME\s0 => \s-1FUNCREF\s0, ...]"

.IX Item "Method => [ \s-1FUNCNAME\s0 => \s-1FUNCREF\s0, ...]"

.IX Item "FuncArgCount => [ \s-1FUNCNAME\s0 => \s-1ARGCOUNT\s0, ...]"

.IX Item "AllowedOutsideSubquery => [ \s-1FUNCNAME\s0 => \s-1BOOLEAN\s0, ...]"

.IX Item "ConstFunc => [ \s-1FUNCNAME\s0 => \s-1BOOLEAN\s0, ...]"

.IX Item "CompareOper => [ \s-1OPERNAME\s0 => \s-1FUNCREF\s0, ...]"

.IX Item "q => \s-1TOKEN\s0"

.IX Item "qq => \s-1TOKEN\s0"

.IX Item "Error => \s-1FUNCREF\s0"

.IX Item "Debug => \s-1FLAGS\s0"

.IX Item "Reserved hash keys"

.IX Header "Additional Features in XQL+"

.IX Item "Sequence operators \*(N';\*(T' and \*(N';;\*(T'"

.IX Item "q// and qq// String Tokens"

.IX Item "Query strings can have embedded Comments"

.IX Item "Optional dollar delimiters and case-insensitive \s-1XQL\s0 keywords"

.IX Item "Comparison operator: $match$ or \*(N'=~\*(T'"

.IX Item "Comparison operator: $no_match$ or \*(N'!~\*(T'"

.IX Item "Comparison operator: $isa$"

.IX Item "Comparison operator: $can$"

.IX Item "Function: once (\s-1QUERY\s0)"

.IX Item "Function: subst (\s-1QUERY\s0, \s-1EXPR\s0, \s-1EXPR\s0 [,\s-1MODIFIERS\s0, [\s-1MODE\s0]])"

.IX Item "Function: map (\s-1QUERY\s0, \s-1CODE\s0)"

.IX Item "Function: eval (\s-1EXPR\s0 [,\s-1TYPE\s0])"

.IX Item "Function: new (\s-1TYPE\s0 [, \s-1QUERY\s0 [, \s-1PAR\s0] *])"

.IX Item "Method: DOM_nodeType ()"

.IX Item "Function wrappers for Perl builtin functions"

.IX Header "Implementation Details"

.IX Item "\s-1XQL\s0 Builtin Data Types"

.IX Item "\(bu \s-1XML::XQL::\s0Number"

.IX Item "\(bu \s-1XML::XQL::\s0Boolean"

.IX Item "\(bu \s-1XML::XQL::\s0Text"

.IX Item "\(bu \s-1XML::XQL::\s0Date"

.IX Item "\(bu \s-1XML::XQL::\s0Node"

.IX Item "\(bu Perl list reference"

.IX Item "Type casting in comparisons"

.IX Item "Adding Data Types"

.IX Item "Document Order"

.IX Item "Constant Function Invocations"

.IX Item "Function: count ([\s-1QUERY\s0])"

.IX Item "Method: text ([\s-1RECURSE\s0])"

.IX Item "Method: rawText ([\s-1RECURSE\s0])"

.IX Header "SEE ALSO"

.IX Header "AUTHOR"

