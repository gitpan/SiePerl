.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH lib::Games::Worms 3 "perl 5.005, patch 03" "4/Mar/1999" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
Games::Worms -- alife simulator for Conway/Patterson/Beeler worms, etc.
.SH "SYNOPSIS"
.PP
.Vb 4
\&  perl -MGames::Worms -e worms -- -tPS 
\&  perl -MGames::Worms -e worms -- -tPS / / / / > foo1.ps
\&  perl -MGames::Worms -e worms -- -tTk
\&  perl -MGames::Worms -e worms -- -tTek4010 / / / Games::Worms::Random2
.Ve
.SH "BUGS, WARNINGS, AND CAVEATS"
This is an alpha release.  The documentation is incomplete, and the
interface is not yet finalized.
.PP
Occasionally I've seen Perl 5.004_02 for MSWin segfault at global
destruction time.
.PP
The Tk part, I've only tested under pTk.  This's my first hack at Tk,
so lets hope all the code I wrote is portable.  Suggestions welcome!
.PP
I've tested the PostScript part only under GhostScript.
.PP
I've tested the Tek interface under MSKermit.  I hear xterm has a Tek
emulator in it -- I'd be interested to hear if it works well with
Worms's Tek interface.
.SH "DESCRIPTION"
[elaborate]
.PP
Worms is an implementation of an artificial-life game.  It can output
via Perl-Tk, Tek4010, and PostScript.  It is a game not in the sense
of checkers, but in the sense of Conway's Life.
.PP
In a Worms universe, worms crawl around an isometric grid of
triangles, leaving trails behind them, and turning in accordance to
simple rules that are based upon which way they can move at a each
junction.  From the simple rules emerges surprising complexity.
.SH "TO DO"
Allow board-size specifications on the command line.
.PP
Better docs.
.PP
Maybe a GIF output mode?
.PP
More interactive interface in pTk mode?
.PP
Currently the interface is pretty much: specify things on the command
line, then sit back and watch the worms go, until they all die.
Hopefully I (or someone ambitious who knows Tk better than I do) may
add more interactivity to the interface.
.SH "INVOCATION"
Start it up by making a Perl program called \f(CWworms\fR, with the content:
.PP
.Vb 3
\&  !/usr/bin/perl
\&  use Games::Worms;
\&  worms;
.Ve
Then start up with the \f(CW-t\fR switch specifying which interface to use:
.PP
.Vb 6
\&  worms -tTk
\&    ...for Tk mode
\&  worms -tPS
\&    ...for PostScript mode
\&  worms -tTek4010
\&    ...for Tektronics mode
.Ve
Command line arguments thereafter are interpreted as the names of
classes worms should come from.  (Currently, three are provided in
this distribution: the \fIGames::Worms::Random\fR manpage, the \fIGames::Worms::Random2\fR manpage,
and the \fIGames::Worms::Beeler\fR manpage.)  If no arguments are provided, Worms
uses two Random2s and two Beelers.
.PP
For each name you specify, if it contains a slash, the rest of that
name is passed to the worm as an expression of its rules.
.PP
Example specifications:
.PP
.Vb 6
\&  Games::Worms::Beeler
\&  Games::Worms::Random
\&  Games::Worms::Random2
\&  Games::Worms::Beeler/1a2d3caaa4b
\&  Games::Worms::Beeler/1A2B3ACAC4B
\&  Games::Worms::Beeler/1B2B3AAAB4A
.Ve
(A Beeler worm with no rules specified makes up a random rule set when
it starts.  A Random worm obeys no rules.  A Random2 worm is random
but consistent.)
.PP
If you specify a name starting with \*(L'/\*(R', it's interpreted as short for
\&'Games::Worms::Beeler/\*(R'.  In other words,
.PP
.Vb 3
\&  /1a2d3caaa4b   equals   Games::Worms::Beeler/1a2d3caaa4b
\&  /1A2B3ACAC4B   equals   Games::Worms::Beeler/1A2B3ACAC4B
\&  /1B2B3AAAB4A   equals   Games::Worms::Beeler/1B2B3AAAB4A
.Ve
See the \fIScientific American\fR article on Beeler worms for the meaning
of these Beeler worm rule specifications.  I don't have the citation
for the first run of the article, but it's reproduced with nice
addenda in the book cited below.
.PP
If you don't want to bother making that little script called \*(L"worms\*(R",
you can just as well invoke Worms via:
.PP
.Vb 1
\&  perl -MGames::Worms -e worms -- -tTk
.Ve
.Vb 1
\&  perl -MGames::Worms -e worms -- -tPS
.Ve
.Vb 1
\&  perl -MGames::Worms -e worms -- -tTek4010
.Ve
.Vb 3
\&  perl -MGames::Worms -e worms -- -tTek4010
\&    Games::Worms::Random  Games::Worms::Random2
\&    /1a2d3caaa4b /1A2B3ACAC4B /1B2B3AAAB4A
.Ve
.SH "CONCEPTS"
[to be written]
.SH "REFERENCES"
\*(L"Worm Paths\*(R", chapter 17 in: Martin Gardner, 1986, \fIKnotted Doughnuts
and Other Mathematical Entertainments\fR, W. H. Freeman and Company.
.PP
\*(L"Patterson's Worm\*(R", M. Beeler, MIT AI Memo #290.  (early 1970s?)
.PP
\*(L"Worms?\*(R" [sic], David Maynard, Electronic Arts, 1983.  (A game for the
Atari 400 (or 800?), the Commodore 64, and maybe other machines.
Games::Worms isn't based on EOA \*(L"Worms?\*(R", but \*(L"Worms?\*(R" is the best
known implementation of Beeler worms.  It uses them as the basis for
a very interesting and abstract interactive game.)
.SH "GUTS"
Read the source.  It's OOPilicious!
.SH "COPYRIGHT"
Copyright 1999, Sean M. Burke \f(CWsburke@netadventure.net\fR, all rights
reserved.  This program is free software; you can redistribute it
and/or modify it under the same terms as Perl itself.
.SH "AUTHOR"
Sean M. Burke \f(CWsburke@netadventure.net\fR

.rn }` ''
.IX Title "lib::Games::Worms 3"
.IX Name "Games::Worms - alife simulator for Conway/Patterson/Beeler worms, etc."

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "BUGS, WARNINGS, AND CAVEATS"

.IX Header "DESCRIPTION"

.IX Header "TO DO"

.IX Header "INVOCATION"

.IX Header "CONCEPTS"

.IX Header "REFERENCES"

.IX Header "GUTS"

.IX Header "COPYRIGHT"

.IX Header "AUTHOR"

