.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH Calc 3 "perl 5.005, patch 03" "11/Jan/2000" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
Date::Calc \- Gregorian calendar date calculations
.SH "PREFACE"
This package consists of a C library and a Perl module (which uses
the C library, internally) for all kinds of date calculations based
on the Gregorian calendar (the one used in all western countries today),
thereby complying with all relevant norms and standards: ISO/R\ 2015-1971,
DIN\ 1355 and, to some extent, ISO\ 8601 (where applicable).
.PP
(See also http://www.engelschall.com/u/sb/download/Date-Calc/DIN1355/
for a scan of part of the \*(L"DIN\ 1355\*(R" document (in German)).
.PP
The module of course handles year numbers of 2000 and above correctly
("Year 2000\*(R" or \*(L"Y2K\*(R" compliance) -- actually all year numbers from 1
to the largest positive integer representable on your system (which
is at least 32767) can be dealt with.
.PP
Note that this package projects the Gregorian calendar back until the
year 1\ A.D. -- even though the Gregorian calendar was only adopted
in 1582 by most (not all) European countries, in obedience to the
corresponding decree of catholic pope Gregor\ I in that year.
.PP
Some (mainly protestant) countries continued to use the Julian calendar
(used until then) until as late as the beginning of the 20th century.
.PP
Finally, note that this package is not intended to do everything you could
ever imagine automagically for you; it is rather intended to serve as a
toolbox (in the best of UNIX spirit and traditions) which should, however,
always get you where you want to go.
.PP
See the section \*(L"RECIPES\*(R" at the bottom of this document for solutions
to common problems!
.PP
If nevertheless you can't figure out how to solve a particular problem,
please let me know! (See e-mail address at the end of this document.)
.SH "SYNOPSIS"
.PP
.Vb 49
\&  use Date::Calc qw(
\&      Days_in_Year
\&      Days_in_Month
\&      Weeks_in_Year
\&      leap_year
\&      check_date
\&      check_business_date
\&      Day_of_Year
\&      Date_to_Days
\&      Day_of_Week
\&      Week_Number
\&      Week_of_Year
\&      Monday_of_Week
\&      Nth_Weekday_of_Month_Year
\&      Standard_to_Business
\&      Business_to_Standard
\&      Delta_Days
\&      Delta_DHMS
\&      Add_Delta_Days
\&      Add_Delta_DHMS
\&      Add_Delta_YMD
\&      System_Clock
\&      Today
\&      Now
\&      Today_and_Now
\&      Easter_Sunday
\&      Decode_Month
\&      Decode_Day_of_Week
\&      Decode_Language
\&      Decode_Date_EU
\&      Decode_Date_US
\&      Compress
\&      Uncompress
\&      check_compressed
\&      Compressed_to_Text
\&      Date_to_Text
\&      Date_to_Text_Long
\&      English_Ordinal
\&      Calendar
\&      Month_to_Text
\&      Day_of_Week_to_Text
\&      Day_of_Week_Abbreviation
\&      Language_to_Text
\&      Language
\&      Languages
\&      Decode_Date_EU2
\&      Decode_Date_US2
\&      Parse_Date
\&  );
.Ve
.Vb 1
\&  use Date::Calc qw(:all);
.Ve
.Vb 2
\&  Days_in_Year
\&      $days = Days_in_Year($year,$month);
.Ve
.Vb 2
\&  Days_in_Month
\&      $days = Days_in_Month($year,$month);
.Ve
.Vb 2
\&  Weeks_in_Year
\&      $weeks = Weeks_in_Year($year);
.Ve
.Vb 2
\&  leap_year
\&      if (leap_year($year))
.Ve
.Vb 2
\&  check_date
\&      if (check_date($year,$month,$day))
.Ve
.Vb 2
\&  check_business_date
\&      if (check_business_date($year,$week,$dow))
.Ve
.Vb 2
\&  Day_of_Year
\&      $doy = Day_of_Year($year,$month,$day);
.Ve
.Vb 2
\&  Date_to_Days
\&      $days = Date_to_Days($year,$month,$day);
.Ve
.Vb 2
\&  Day_of_Week
\&      $dow = Day_of_Week($year,$month,$day);
.Ve
.Vb 2
\&  Week_Number
\&      $week = Week_Number($year,$month,$day);
.Ve
.Vb 2
\&  Week_of_Year
\&      ($week,$year) = Week_of_Year($year,$month,$day);
.Ve
.Vb 2
\&  Monday_of_Week
\&      ($year,$month,$day) = Monday_of_Week($week,$year);
.Ve
.Vb 3
\&  Nth_Weekday_of_Month_Year
\&      if (($year,$month,$day) =
\&      Nth_Weekday_of_Month_Year($year,$month,$dow,$n))
.Ve
.Vb 3
\&  Standard_to_Business
\&      ($year,$week,$dow) =
\&      Standard_to_Business($year,$month,$day);
.Ve
.Vb 3
\&  Business_to_Standard
\&      ($year,$month,$day) =
\&      Business_to_Standard($year,$week,$dow);
.Ve
.Vb 3
\&  Delta_Days
\&      $Dd = Delta_Days($year1,$month1,$day1,
\&                       $year2,$month2,$day2);
.Ve
.Vb 4
\&  Delta_DHMS
\&      ($Dd,$Dh,$Dm,$Ds) =
\&      Delta_DHMS($year1,$month1,$day1, $hour1,$min1,$sec1,
\&                 $year2,$month2,$day2, $hour2,$min2,$sec2);
.Ve
.Vb 4
\&  Add_Delta_Days
\&      ($year,$month,$day) =
\&      Add_Delta_Days($year,$month,$day,
\&                     $Dd);
.Ve
.Vb 4
\&  Add_Delta_DHMS
\&      ($year,$month,$day, $hour,$min,$sec) =
\&      Add_Delta_DHMS($year,$month,$day, $hour,$min,$sec,
\&                     $Dd,$Dh,$Dm,$Ds);
.Ve
.Vb 4
\&  Add_Delta_YMD
\&      ($year,$month,$day) =
\&      Add_Delta_YMD($year,$month,$day,
\&                    $Dy,$Dm,$Dd);
.Ve
.Vb 3
\&  System_Clock
\&      ($year,$month,$day, $hour,$min,$sec, $doy,$dow,$dst) =
\&      System_Clock();
.Ve
.Vb 2
\&  Today
\&      ($year,$month,$day) = Today();
.Ve
.Vb 2
\&  Now
\&      ($hour,$min,$sec) = Now();
.Ve
.Vb 2
\&  Today_and_Now
\&      ($year,$month,$day, $hour,$min,$sec) = Today_and_Now();
.Ve
.Vb 2
\&  Easter_Sunday
\&      ($year,$month,$day) = Easter_Sunday($year);
.Ve
.Vb 2
\&  Decode_Month
\&      if ($month = Decode_Month($string))
.Ve
.Vb 2
\&  Decode_Day_of_Week
\&      if ($dow = Decode_Day_of_Week($string))
.Ve
.Vb 2
\&  Decode_Language
\&      if ($lang = Decode_Language($string))
.Ve
.Vb 2
\&  Decode_Date_EU
\&      if (($year,$month,$day) = Decode_Date_EU($string))
.Ve
.Vb 2
\&  Decode_Date_US
\&      if (($year,$month,$day) = Decode_Date_US($string))
.Ve
.Vb 2
\&  Compress
\&      $date = Compress($year,$month,$day);
.Ve
.Vb 2
\&  Uncompress
\&      if (($century,$year,$month,$day) = Uncompress($date))
.Ve
.Vb 2
\&  check_compressed
\&      if (check_compressed($date))
.Ve
.Vb 2
\&  Compressed_to_Text
\&      $string = Compressed_to_Text($date);
.Ve
.Vb 2
\&  Date_to_Text
\&      $string = Date_to_Text($year,$month,$day);
.Ve
.Vb 2
\&  Date_to_Text_Long
\&      $string = Date_to_Text_Long($year,$month,$day);
.Ve
.Vb 2
\&  English_Ordinal
\&      $string = English_Ordinal($number);
.Ve
.Vb 2
\&  Calendar
\&      $string = Calendar($year,$month);
.Ve
.Vb 2
\&  Month_to_Text
\&      $string = Month_to_Text($month);
.Ve
.Vb 2
\&  Day_of_Week_to_Text
\&      $string = Day_of_Week_to_Text($dow);
.Ve
.Vb 2
\&  Day_of_Week_Abbreviation
\&      $string = Day_of_Week_Abbreviation($dow);
.Ve
.Vb 2
\&  Language_to_Text
\&      $string = Language_to_Text($lang);
.Ve
.Vb 4
\&  Language
\&      $lang = Language();
\&      Language($lang);
\&      $oldlang = Language($newlang);
.Ve
.Vb 2
\&  Languages
\&      $max_lang = Languages();
.Ve
.Vb 2
\&  Decode_Date_EU2
\&      if (($year,$month,$day) = Decode_Date_EU2($string))
.Ve
.Vb 2
\&  Decode_Date_US2
\&      if (($year,$month,$day) = Decode_Date_US2($string))
.Ve
.Vb 2
\&  Parse_Date
\&      if (($year,$month,$day) = Parse_Date($string))
.Ve
.Vb 2
\&  Version
\&      $string = Date::Calc::Version();
.Ve
.SH "IMPORTANT NOTES"
(See the section \*(L"RECIPES\*(R" at the bottom of this document for
solutions to common problems!)
.Ip "\(bu" 2
\*(L"Year 2000\*(R" ("Y2K") compliance
.Sp
The upper limit for any year number in this module is only given
by the size of the largest positive integer that can be represented
in a variable of the C type \*(L"int\*(R" on your system, which is at least
32767, according to the \s-1ANSI\s0 C standard (exceptions see below).
.Sp
In order to simplify calculations, this module projects the gregorian
calendar back until the year 1\ A.D. -- i.e., back \fB\s-1BEYOND\s0\fR the
year 1582 when this calendar was first decreed by the catholic pope
Gregor\ I!
.Sp
Therefore, \fB\s-1BE\s0 \s-1SURE\s0 \s-1TO\s0 \s-1ALWAYS\s0 \s-1SPECIFY\s0 \*(L"1998\*(R" \s-1WHEN\s0 \s-1YOU\s0 \s-1MEAN\s0 \*(L"1998\*(R"\fR,
for instance, and \fB\s-1DO\s0 \s-1NOT\s0 \s-1WRITE\s0 \*(L"98\*(R" \s-1INSTEAD\s0\fR, because this will
in fact perform a calculation based on the year \*(L"98\*(R" A.D. and
\fB\s-1NOT\s0\fR \*(L"1998\*(R"!
.Sp
The only exceptions from this rule are the functions which contain
the word \*(L"compress\*(R" in their names (which only handle years between
1970 and 2069 and also accept the abbreviations \*(L"00\*(R" to \*(L"99"), and
the functions whose names begin with \*(L"Decode_Date_\*(R" (which map year
numbers below 100 to the range 1970 \- 2069, using a technique known
as \*(L"windowing").
.Ip "\(bu" 2
First index
.Sp
\fB\s-1ALL\s0\fR ranges in this module start with \*(L"\f(CW1\fR\*(R", \fB\s-1NOT\s0\fR \*(L"\f(CW0\fR\*(R"!
.Sp
I.e., the day of month, day of week, day of year, month of year,
week of year, first valid year number and language \fB\s-1ALL\s0\fR start
counting at one, \fB\s-1NOT\s0\fR zero!
.Sp
The only exception is the function \*(L"\f(CWWeek_Number()\fR\*(R", which may
in fact return \*(L"\f(CW0\fR\*(R" when the given date actually lies in the
last week of the \fB\s-1PREVIOUS\s0\fR year.
.Ip "\(bu" 2
Function naming conventions
.Sp
Function names completely in lower case indicate a boolean return value.
.Ip "\(bu" 2
Boolean values
.Sp
Boolean values in this module are always a numeric zero ("\f(CW0\fR") for
\*(L"false\*(R" and a numeric one ("\f(CW1\fR") for \*(L"true\*(R".
.Ip "\(bu" 2
Exception handling
.Sp
The functions in this module will usually die with a corresponding error
message if their input parameters, intermediate results or output values
are out of range.
.Sp
The following functions handle errors differently:
.Sp
.Vb 3
\&  -  check_date()
\&  -  check_business_date()
\&  -  check_compressed()
.Ve
(which return a \*(L"false\*(R" return value when the given input does not represent
a valid date),
.Sp
.Vb 1
\&  -  Nth_Weekday_of_Month_Year()
.Ve
(which returns an empty list if the requested 5th day of week does not exist),
.Sp
.Vb 4
\&  -  Decode_Month()
\&  -  Decode_Day_of_Week()
\&  -  Decode_Language()
\&  -  Compress()
.Ve
(which return \*(L"\f(CW0\fR\*(R" upon failure or invalid input), and
.Sp
.Vb 6
\&  -  Decode_Date_EU()
\&  -  Decode_Date_US()
\&  -  Decode_Date_EU2()
\&  -  Decode_Date_US2()
\&  -  Parse_Date()
\&  -  Uncompress()
.Ve
(which return an empty list upon failure or invalid input).
.Sp
Note that you can always catch an exception thrown by any of the functions
in this module and handle it yourself by enclosing the function call in an
\*(L"\f(CWeval\fR\*(R" with curly brackets and checking the special variable \*(L"\f(CW$@\fR\*(R"
(see the \f(CWeval\fR entry in the \fIperlfunc(1)\fR manpage for details).
.SH "DESCRIPTION"
.Ip "\(bu" 2
\f(CWuse Date::Calc qw( Days_in_Year Days_in_Month ... );\fR
.Ip "\(bu" 2
\f(CWuse Date::Calc qw(:all);\fR
.Sp
You can either specify the functions you want to import explicitly by
enumerating them between the parentheses of the \*(L"\f(CWqw()\fR\*(R" operator, or
you can use the \*(L"\f(CW:all\fR\*(R" tag instead to import \fB\s-1ALL\s0\fR available functions.
.Ip "\(bu" 2
\f(CW$days = Days_in_Year($year,$month);\fR
.Sp
This function returns the sum of the number of days in the months starting
with January up to and including \*(L"\f(CW$month\fR\*(R" in the given year \*(L"\f(CW$year\fR\*(R".
.Sp
I.e., \*(L"\f(CWDays_in_Year(1998,1)\fR\*(R" returns \*(L"\f(CW31\fR\*(R", \*(L"\f(CWDays_in_Year(1998,2)\fR\*(R"
returns \*(L"\f(CW59\fR\*(R", \*(L"\f(CWDays_in_Year(1998,3)\fR\*(R" returns \*(L"\f(CW90\fR\*(R", and so on.
.Sp
Note that \*(L"\f(CWDays_in_Year($year,12)\fR\*(R" returns the number of days in the
given year \*(L"\f(CW$year\fR\*(R", i.e., either \*(L"\f(CW365\fR\*(R" or \*(L"\f(CW366\fR\*(R".
.Ip "\(bu" 2
\f(CW$days = Days_in_Month($year,$month);\fR
.Sp
This function returns the number of days in the given month \*(L"\f(CW$month\fR\*(R" of
the given year \*(L"\f(CW$year\fR\*(R".
.Sp
The year must always be supplied, even though it is only needed when the
month is February, in order to determine wether it is a leap year or not.
.Sp
I.e., \*(L"\f(CWDays_in_Month(1998,1)\fR\*(R" returns \*(L"\f(CW31\fR\*(R", \*(L"\f(CWDays_in_Month(1998,2)\fR\*(R"
returns \*(L"\f(CW28\fR\*(R", \*(L"\f(CWDays_in_Month(2000,2)\fR\*(R" returns \*(L"\f(CW29\fR\*(R",
\*(L"\f(CWDays_in_Month(1998,3)\fR\*(R" returns \*(L"\f(CW31\fR\*(R", and so on.
.Ip "\(bu" 2
\f(CW$weeks = Weeks_in_Year($year);\fR
.Sp
This function returns the number of weeks in the given year \*(L"\f(CW$year\fR\*(R",
i.e., either \*(L"\f(CW52\fR\*(R" or \*(L"\f(CW53\fR\*(R".
.Ip "\(bu" 2
\f(CWif (leap_year($year))\fR
.Sp
This function returns \*(L"true\*(R" ("\f(CW1\fR") if the given year \*(L"\f(CW$year\fR\*(R" is
a leap year and \*(L"false\*(R" ("\f(CW0\fR") otherwise.
.Ip "\(bu" 2
\f(CWif (check_date($year,$month,$day))\fR
.Sp
This function returns \*(L"true\*(R" ("\f(CW1\fR") if the given three numerical
values \*(L"\f(CW$year\fR\*(R", \*(L"\f(CW$month\fR\*(R" and \*(L"\f(CW$day\fR\*(R" constitute a valid date,
and \*(L"false\*(R" ("\f(CW0\fR") otherwise.
.Ip "\(bu" 2
\f(CWif (check_business_date($year,$week,$dow))\fR
.Sp
This function returns \*(L"true\*(R" ("\f(CW1\fR") if the given three numerical
values \*(L"\f(CW$year\fR\*(R", \*(L"\f(CW$week\fR\*(R" and \*(L"\f(CW$dow\fR\*(R" constitute a valid date
in business format, and \*(L"false\*(R" ("\f(CW0\fR") otherwise.
.Sp
\fBBeware\fR that this function does \fB\s-1NOT\s0\fR compute wether a given date
is a business day (i.e., Monday to Friday)!
.Sp
To do so, use \*(L"\f(CW(Day_of_Week($year,$month,$day) < 6)\fR\*(R" instead.
.Ip "\(bu" 2
\f(CW$doy = Day_of_Year($year,$month,$day);\fR
.Sp
This function returns the (relative) number of the day of the given date
in the given year.
.Sp
E.g., \*(L"\f(CWDay_of_Year($year,1,1)\fR\*(R" returns \*(L"\f(CW1\fR\*(R",
\*(L"\f(CWDay_of_Year($year,2,1)\fR\*(R" returns \*(L"\f(CW32\fR\*(R", and
\*(L"\f(CWDay_of_Year($year,12,31)\fR\*(R" returns either \*(L"\f(CW365\fR\*(R" or \*(L"\f(CW366\fR\*(R".
.Ip "\(bu" 2
\f(CW$days = Date_to_Days($year,$month,$day);\fR
.Sp
This function returns the (absolute) number of the day of the given date,
where counting starts at the 1st of January of the year 1\ A.D.
.Sp
I.e., \*(L"\f(CWDate_to_Days(1,1,1)\fR\*(R" returns \*(L"\f(CW1\fR\*(R", \*(L"\f(CWDate_to_Days(1,12,31)\fR\*(R"
returns \*(L"\f(CW365\fR\*(R", \*(L"\f(CWDate_to_Days(2,1,1)\fR\*(R" returns \*(L"\f(CW366\fR\*(R",
\*(L"\f(CWDate_to_Days(1998,5,1)\fR\*(R" returns \*(L"\f(CW729510\fR\*(R", and so on.
.Ip "\(bu" 2
\f(CW$dow = Day_of_Week($year,$month,$day);\fR
.Sp
This function returns the number of the day of week of the given date.
.Sp
The function returns \*(L"\f(CW1\fR\*(R" for Monday, \*(L"\f(CW2\fR\*(R" for Tuesday and so on
until \*(L"\f(CW7\fR\*(R" for Sunday.
.Sp
Note that in the Hebrew calendar (on which the Christian calendar is based),
the week starts with Sunday and ends with the Sabbath or Saturday (where
according to the Genesis (as described in the Bible) the Lord rested from
creating the world).
.Sp
In medieval times, catholic popes have decreed the Sunday to be the official
day of rest, in order to dissociate the Christian from the Hebrew belief.
.Sp
Nowadays, the Sunday \fB\s-1AND\s0\fR the Saturday are commonly considered (and
used as) days of rest, usually referred to as the \*(L"week-end\*(R".
.Sp
Consistent with this practice, current norms and standards (such as
\s-1ISO/R\s0\ 2015-1971, \s-1DIN\s0\ 1355 and \s-1ISO\s0\ 8601) define the Monday
as the first day of the week.
.Ip "\(bu" 2
\f(CW$week = Week_Number($year,$month,$day);\fR
.Sp
This function returns the number of the week the given date lies in.
.Sp
If the given date lies in the \fB\s-1LAST\s0\fR week of the \fB\s-1PREVIOUS\s0\fR year,
\*(L"\f(CW0\fR\*(R" is returned.
.Sp
If the given date lies in the \fB\s-1FIRST\s0\fR week of the \fB\s-1NEXT\s0\fR year,
\*(L"\f(CWWeeks_in_Year($year) + 1\fR\*(R" is returned.
.Ip "\(bu" 2
\f(CW($week,$year) = Week_of_Year($year,$month,$day);\fR
.Sp
This function returns the number of the week the given date lies in,
as well as the year that week belongs to.
.Sp
I.e., if the given date lies in the \fB\s-1LAST\s0\fR week of the \fB\s-1PREVIOUS\s0\fR year,
\*(L"\f(CW(Weeks_in_Year($year-1), $year-1)\fR\*(R" is returned.
.Sp
If the given date lies in the \fB\s-1FIRST\s0\fR week of the \fB\s-1NEXT\s0\fR year,
\*(L"\f(CW(1, $year+1)\fR\*(R" is returned.
.Sp
Otherwise, \*(L"\f(CW(Week_Number($year,$month,$day), $year)\fR\*(R" is returned.
.Ip "\(bu" 2
\f(CW($year,$month,$day) = Monday_of_Week($week,$year);\fR
.Sp
This function returns the date of the first day of the given week, i.e.,
the Monday.
.Sp
\*(L"\f(CW$year\fR\*(R" must be greater than or equal to \*(L"\f(CW1\fR\*(R", and \*(L"\f(CW$week\fR\*(R" must
lie in the range \*(L"\f(CW1\fR\*(R" to \*(L"\f(CWWeeks_in_Year($year)\fR\*(R".
.Sp
Note that you can write
\*(L"\f(CW($year,$month,$day) = Monday_of_Week(Week_of_Year($year,$month,$day));\fR\*(R"
in order to calculate the date of the Monday of the same week as the
given date.
.Ip "\(bu" 2
\f(CWif (($year,$month,$day) = Nth_Weekday_of_Month_Year($year,$month,$dow,$n))\fR
.Sp
This function calculates the date of the \*(L"\f(CW$n\fR"th day of week \*(L"\f(CW$dow\fR\*(R"
in the given month \*(L"\f(CW$month\fR\*(R" and year \*(L"\f(CW$year\fR\*(R"; such as, for example,
the 3rd Thursday of a given month and year.
.Sp
This can be used to send a notification mail to the members of a group
which meets regularly on every 3rd Thursday of a month, for instance.
.Sp
(See the section \*(L"\s-1RECIPES\s0\*(R" near the end of this document for a code
snippet to actually do so.)
.Sp
\*(L"\f(CW$year\fR\*(R" must be greater than or equal to \*(L"\f(CW1\fR\*(R", \*(L"\f(CW$month\fR\*(R" must lie
in the range \*(L"\f(CW1\fR\*(R" to \*(L"\f(CW12\fR\*(R", \*(L"\f(CW$dow\fR\*(R" must lie in the range \*(L"\f(CW1\fR\*(R"
to \*(L"\f(CW7\fR\*(R" and \*(L"\f(CW$n\fR\*(R" must lie in the range \*(L"\f(CW1\fR\*(R" to \*(L"\f(CW5\fR\*(R", or a fatal
error (with appropriate error message) occurs.
.Sp
The function returns an empty list when the 5th of a given day of week
does not exist in the given month and year.
.Ip "\(bu" 2
\f(CW($year,$week,$dow) = Standard_to_Business($year,$month,$day);\fR
.Sp
This function converts a given date from standard notation (year,
month, day (of month)) to business notation (year, week, day of week).
.Ip "\(bu" 2
\f(CW($year,$month,$day) = Business_to_Standard($year,$week,$dow);\fR
.Sp
This function converts a given date from business notation (year,
week, day of week) to standard notation (year, month, day (of month)).
.Ip "\(bu" 2
\f(CW$Dd = Delta_Days($year1,$month1,$day1, $year2,$month2,$day2);\fR
.Sp
This function returns the difference in days between the two given
dates.
.Sp
The result is positive if the two dates are in chronological order,
i.e., if date #1 comes chronologically \fB\s-1BEFORE\s0\fR date #2, and negative
if the order of the two dates is reversed.
.Sp
The result is zero if the two dates are identical.
.Ip "\(bu" 2
\f(CW($Dd,$Dh,$Dm,$Ds) = Delta_DHMS($year1,$month1,$day1, $hour1,$min1,$sec1, $year2,$month2,$day2, $hour2,$min2,$sec2);\fR
.Sp
This function returns the difference in days, hours, minutes and seconds
between the two given dates with times.
.Sp
All four return values will be positive if the two dates are in chronological
order, i.e., if date #1 comes chronologically \fB\s-1BEFORE\s0\fR date #2, and negative
(in all four return values!) if the order of the two dates is reversed.
.Sp
This is so that the two functions \*(L"\f(CWDelta_DHMS()\fR\*(R" and \*(L"\f(CWAdd_Delta_DHMS()\fR\*(R"
(description see further below) are complementary, i.e., mutually inverse:
.Sp
.Vb 1
\&  Add_Delta_DHMS(@date1,@time1, Delta_DHMS(@date1,@time1, @date2,@time2))
.Ve
yields \*(L"\f(CW(@date2,@time2)\fR\*(R" again, whereas
.Sp
.Vb 2
\&  Add_Delta_DHMS(@date2,@time2,
\&      map(-$_, Delta_DHMS(@date1,@time1, @date2,@time2)))
.Ve
yields \*(L"\f(CW(@date1,@time1)\fR\*(R", and
.Sp
.Vb 1
\&  Delta_DHMS(@date1,@time1, Add_Delta_DHMS(@date1,@time1, @delta))
.Ve
yields \*(L"\f(CW@delta\fR\*(R" again.
.Sp
The result is zero (in all four return values) if the two dates and times
are identical.
.Ip "\(bu" 2
\f(CW($year,$month,$day) = Add_Delta_Days($year,$month,$day, $Dd);\fR
.Sp
This function has two principal uses:
.Sp
First, it can be used to calculate a new date, given an initial date and
an offset (which may be positive or negative) in days, in order to answer
questions like \*(L"today plus 90 days -- which date gives that?\*(R".
.Sp
(In order to add a weeks offset, simply multiply the weeks offset with
\*(L"\f(CW7\fR\*(R" and use that as your days offset.)
.Sp
Second, it can be used to convert the canonical representation of a date,
i.e., the number of that day (where counting starts at the 1st of January
in 1\ A.D.), back into a date given as year, month and day.
.Sp
Because counting starts at \*(L"\f(CW1\fR\*(R", you will actually have to subtract \*(L"\f(CW1\fR\*(R"
from the canonical date in order to get back the original date:
.Sp
.Vb 1
\&  $canonical = Date_to_Days($year,$month,$day);
.Ve
.Vb 1
\&  ($year,$month,$day) = Add_Delta_Days(1,1,1, $canonical - 1);
.Ve
Moreover, this function is the inverse of the function \*(L"\f(CWDelta_Days()\fR":
.Sp
.Vb 1
\&  Add_Delta_Days(@date1, Delta_Days(@date1, @date2))
.Ve
yields \*(L"\f(CW@date2\fR\*(R" again, whereas
.Sp
.Vb 1
\&  Add_Delta_Days(@date2, -Delta_Days(@date1, @date2))
.Ve
yields \*(L"\f(CW@date1\fR\*(R", and
.Sp
.Vb 1
\&  Delta_Days(@date1, Add_Delta_Days(@date1, $delta))
.Ve
yields \*(L"\f(CW$delta\fR\*(R" again.
.Ip "\(bu" 2
\f(CW($year,$month,$day, $hour,$min,$sec) = Add_Delta_DHMS($year,$month,$day, $hour,$min,$sec, $Dd,$Dh,$Dm,$Ds);\fR
.Sp
This function serves to add a days, hours, minutes and seconds offset to a
given date and time, in order to answer questions like \*(L"today and now plus
7 days but minus 5 hours and then plus 30 minutes, what date and time gives
that?":
.Sp
.Vb 1
\&  ($y,$m,$d,$H,$M,$S) = Add_Delta_DHMS(Today_and_Now(), +7,-5,+30,0);
.Ve
.Ip "\(bu" 2
\f(CW($year,$month,$day) = Add_Delta_YMD($year,$month,$day, $Dy,$Dm,$Dd);\fR
.Sp
This function serves to add a years, months and days offset to a given date.
.Sp
(In order to add a weeks offset, simply multiply the weeks offset with \*(L"\f(CW7\fR\*(R"
and add this number to your days offset.)
.Sp
Note that the three offsets for years, months and days are applied separately
from each other, in reverse order.
.Sp
(This also allows them to have opposite signs.)
.Sp
In other words, first the days offset is applied (using the function
\*(L"\f(CWAdd_Delta_Days()\fR\*(R", internally), then the months offset, and finally
the years offset.
.Sp
If the resulting date happens to fall on a day beyond the end of the
resulting month, like the 31st of April or the 29th of February (in
non-leap years), then the day is replaced by the last valid day of
that month in that year (e.g., the 30th of April or 28th of February).
.Sp
\fB\s-1BEWARE\s0\fR that this behaviour differs from that of previous versions
of this module!
.Sp
(Formerly, only the 29th of February in non-leap years was checked for
(which \- in contrast to the current version \- was replaced by the 1st
of March). Other possible invalid dates were not checked (and returned
unwittingly), constituting a severe bug of previous versions.)
.Sp
\fB\s-1BEWARE\s0\fR also that because of this replacement, but even more because
a year and a month offset is not equivalent to a fixed number of days,
the transformation performed by this function is \fB\s-1NOT\s0 \s-1REVERSIBLE\s0\fR!
.Sp
This is in contrast to the functions \*(L"\f(CWAdd_Delta_Days()\fR\*(R" and
\*(L"\f(CWAdd_Delta_DHMS()\fR\*(R", which for this very reason have inverse functions
(namely \*(L"\f(CWDelta_Days()\fR\*(R" and \*(L"\f(CWDelta_DHMS()\fR"), whereas there exists no
inverse for this function.
.Sp
Note that for this same reason, even
.Sp
.Vb 2
\&  @date = Add_Delta_YMD(
\&          Add_Delta_YMD(@date, $Dy,$Dm,$Dd), -$Dy,-$Dm,-$Dd);
.Ve
will (in general!) \fB\s-1NOT\s0\fR return the initial date \*(L"\f(CW@date\fR\*(R"!
.Sp
(This might work in some cases, though.)
.Sp
Note that this is \fB\s-1NOT\s0\fR a program bug but \fB\s-1NECESSARILY\s0\fR so because of
the varying lengths of years and months!
.Ip "\(bu" 2
\f(CW($year,$month,$day, $hour,$min,$sec, $doy,$dow,$dst) = System_Clock();\fR
.Sp
If your operating system supports the corresponding system calls
("\f(CWtime()\fR\*(R" and \*(L"\f(CWlocaltime()\fR"), this function will return
the information provided by your system clock, i.e., the current
date and time, the number of the day of year, the number of the
day of week and a flag signaling wether daylight savings time
is currently in effect or not.
.Sp
The ranges of values returned (and their meanings) are as follows:
.Sp
.Vb 9
\&                $year   :   should at least cover 1900..2038
\&                $month  :   1..12
\&                $day    :   1..31
\&                $hour   :   0..23
\&                $min    :   0..59
\&                $sec    :   0..59    (0..61 on some systems)
\&                $doy    :   1..366
\&                $dow    :   1..7
\&                $dst    :  -1..1
.Ve
The day of week ("\f(CW$dow\fR") will be \*(L"\f(CW1\fR\*(R" for Monday, \*(L"\f(CW2\fR\*(R" for
Tuesday and so on until \*(L"\f(CW7\fR\*(R" for Sunday.
.Sp
The daylight savings time flag ("\f(CW$dst\fR") will be \*(L"\f(CW-1\fR\*(R" if this
information is not available on your system, \*(L"\f(CW0\fR\*(R" for no daylight
savings time (i.e., normal time) and \*(L"\f(CW1\fR\*(R" when daylight savings
time is in effect.
.Sp
If your operating system does not provide the necessary system calls,
calling this function will result in a fatal \*(L"not available on this
system\*(R" error message.
.Sp
If you want to handle this exception yourself, use \*(L"\f(CWeval\fR\*(R" as follows:
.Sp
.Vb 2
\&  eval { ($year,$month,$day, $hour,$min,$sec, $doy,$dow,$dst) =
\&    System_Clock(); };
.Ve
.Vb 5
\&  if ($@)
\&  {
\&      # Handle missing system clock
\&      # (For instance, ask user to enter this information manually)
\&  }
.Ve
Note that curlies ("{\*(R" and \*(L"}") are used here to delimit the statement to
be \*(L"eval"ed (which is the way to catch exceptions in Perl), and not quotes
(which is a way to evaluate Perl expressions at runtime).
.Ip "\(bu" 2
\f(CW($year,$month,$day) = Today();\fR
.Sp
This function returns a subset of the values returned by the function
\*(L"\f(CWSystem_Clock()\fR\*(R" (see above for details), namely the current year,
month and day.
.Sp
A fatal \*(L"not available on this system\*(R" error message will appear if the
corresponding system calls are not supported by your current operating
system.
.Ip "\(bu" 2
\f(CW($hour,$min,$sec) = Now();\fR
.Sp
This function returns a subset of the values returned by the function
\*(L"\f(CWSystem_Clock()\fR\*(R" (see above for details), namely the current time
(hours, minutes and full seconds).
.Sp
A fatal \*(L"not available on this system\*(R" error message will appear if the
corresponding system calls are not supported by your current operating
system.
.Ip "\(bu" 2
\f(CW($year,$month,$day, $hour,$min,$sec) = Today_and_Now();\fR
.Sp
This function returns a subset of the values returned by the function
\*(L"\f(CWSystem_Clock()\fR\*(R" (see above for details), namely the current date
(year, month, day) and time (hours, minutes and full seconds).
.Sp
A fatal \*(L"not available on this system\*(R" error message will appear if the
corresponding system calls are not supported by your current operating
system.
.Ip "\(bu" 2
\f(CW($year,$month,$day) = Easter_Sunday($year);\fR
.Sp
This function calculates the date of easter sunday for all years in the
range from 1583 to 2299 (all other year numbers will result in a fatal
\*(L"year out of range\*(R" error message) using the method known as the \*(L"Gaussian
Rule\*(R".
.Sp
Some related christian feast days which depend on the date of easter sunday:
.Sp
.Vb 11
\&  Carnival Monday / Rosenmontag / Veille du Mardi Gras   =  -48 days
\&  Mardi Gras / Karnevalsdienstag / Mardi Gras            =  -47 days
\&  Ash Wednesday / Aschermittwoch / Mercredi des Cendres  =  -46 days
\&  Palm Sunday / Palmsonntag / Dimanche des Rameaux       =   -7 days
\&  Easter Friday / Karfreitag / Vendredi Saint            =   -2 days
\&  Easter Saturday / Ostersamstag / Samedi de Paques      =   -1 day
\&  Easter Monday / Ostermontag / Lundi de Paques          =   +1 day
\&  Ascension of Christ / Christi Himmelfahrt / Ascension  =  +39 days
\&  Whitsunday / Pfingstsonntag / Dimanche de Pentecote    =  +49 days
\&  Whitmonday / Pfingstmontag / Lundi de Pentecote        =  +50 days
\&  Feast of Corpus Christi / Fronleichnam / Fete-Dieu     =  +60 days
.Ve
Use the offsets shown above to calculate the date of the corresponding
feast day as follows:
.Sp
.Vb 1
\&  ($year,$month,$day) = Add_Delta_Days(Easter_Sunday($year), $offset));
.Ve
.Ip "\(bu" 2
\f(CWif ($month = Decode_Month($string))\fR
.Sp
This function takes a string as its argument, which should contain the
name of a month \fB\s-1IN\s0 \s-1THE\s0 \s-1CURRENTLY\s0 \s-1SELECTED\s0 \s-1LANGUAGE\s0\fR (see further below
for details about the multi-language support of this package), or any uniquely
identifying abbreviation of a month's name (i.e., the first few letters),
and returns the corresponding number (1..12) upon a successful match, or
\*(L"\f(CW0\fR\*(R" otherwise (therefore, the return value can also be used as the
conditional expression in an \*(L"if\*(R" statement).
.Sp
Note that the input string may not contain any other characters which do not
pertain to the month's name, especially no leading or trailing whitespace.
.Sp
Note also that matching is performed in a case-insensitive manner (this may
depend on the \*(L"locale\*(R" setting on your current system, though!)
.Sp
With \*(L"English\*(R" as the currently selected language (which is the default),
the following examples will all return the value \*(L"\f(CW9\fR":
.Sp
.Vb 4
\&  $month = Decode_Month("s");
\&  $month = Decode_Month("Sep");
\&  $month = Decode_Month("septemb");
\&  $month = Decode_Month("September");
.Ve
.Ip "\(bu" 2
\f(CWif ($dow = Decode_Day_of_Week($string))\fR
.Sp
This function takes a string as its argument, which should contain the
name of a day of week \fB\s-1IN\s0 \s-1THE\s0 \s-1CURRENTLY\s0 \s-1SELECTED\s0 \s-1LANGUAGE\s0\fR (see further
below for details about the multi-language support of this package), or any
uniquely identifying abbreviation of the name of a day of week (i.e., the
first few letters), and returns the corresponding number (1..7) upon a
successful match, or \*(L"\f(CW0\fR\*(R" otherwise (therefore, the return value can
also be used as the conditional expression in an \*(L"if\*(R" statement).
.Sp
Note that the input string may not contain any other characters which
do not pertain to the name of the day of week, especially no leading
or trailing whitespace.
.Sp
Note also that matching is performed in a case-insensitive manner (this may
depend on the \*(L"locale\*(R" setting on your current system, though!)
.Sp
With \*(L"English\*(R" as the currently selected language (which is the default),
the following examples will all return the value \*(L"\f(CW3\fR":
.Sp
.Vb 4
\&  $dow = Decode_Day_of_Week("w");
\&  $dow = Decode_Day_of_Week("Wed");
\&  $dow = Decode_Day_of_Week("wednes");
\&  $dow = Decode_Day_of_Week("Wednesday");
.Ve
.Ip "\(bu" 2
\f(CWif ($lang = Decode_Language($string))\fR
.Sp
This function takes a string as its argument, which should contain the
name of one of the languages supported by this package (\fB\s-1IN\s0 \s-1THIS\s0 \s-1VERY\s0
\s-1LANGUAGE\s0 \s-1ITSELF\s0\fR), or any uniquely identifying abbreviation of the name
of a language (i.e., the first few letters), and returns its corresponding
internal number (1..7 in the original distribution) upon a successful match,
or \*(L"\f(CW0\fR\*(R" otherwise (therefore, the return value can also be used as the
conditional expression in an \*(L"if\*(R" statement).
.Sp
Note that the input string may not contain any other characters which do
not pertain to the name of a language, especially no leading or trailing
whitespace.
.Sp
Note also that matching is performed in a case-insensitive manner (this may
depend on the \*(L"locale\*(R" setting on your current system, though!)
.Sp
The original distribution supports the following seven languages:
.Sp
.Vb 7
\&            English                    ==>   1    (default)
\&            Français    (French)       ==>   2
\&            Deutsch     (German)       ==>   3
\&            Español     (Spanish)      ==>   4
\&            Português   (Portuguese)   ==>   5
\&            Nederlands  (Dutch)        ==>   6
\&            Italiano    (Italian)      ==>   7
.Ve
See the section \*(L"How to install additional languages\*(R" in the file
\*(L"\s-1INSTALL\s0.txt\*(R" in this distribution for how to add more languages
to this package.
.Sp
In the original distribution (no other languages installed),
the following examples will all return the value \*(L"\f(CW3\fR":
.Sp
.Vb 3
\&  $lang = Decode_Language("d");
\&  $lang = Decode_Language("de");
\&  $lang = Decode_Language("Deutsch");
.Ve
Note that you may not be able to enter the special international characters
in some of the languages\*(R' names over the keyboard directly on some systems.
.Sp
This should never be a problem, though; just enter an abbreviation of the
name of the language consisting of the first few letters up to the character
before the first special international character.
.Ip "\(bu" 2
\f(CWif (($year,$month,$day) = Decode_Date_EU($string))\fR
.Sp
This function scans a given string and tries to parse any date
which might be embedded in it.
.Sp
The function returns an empty list if it can't successfully
extract a valid date from its input string, or else it returns
the date found.
.Sp
The function accepts almost any format, as long as the date is
given in the european order (hence its name) day-month-year.
.Sp
Thereby, zero or more \fB\s-1NON\s0\-\s-1NUMERIC\s0\fR characters may \fB\s-1PRECEDE\s0\fR
the day and \fB\s-1FOLLOW\s0\fR the year.
.Sp
Moreover, zero or more \fB\s-1NON\s0\-\s-1ALPHANUMERIC\s0\fR characters are permitted
\fB\s-1BETWEEN\s0\fR these three items (i.e., between day and month and between
month and year).
.Sp
The month may be given either numerically (i.e., a number from \*(L"\f(CW1\fR\*(R"
to \*(L"\f(CW12\fR"), or alphanumerically, i.e., as the name of the month \fB\s-1IN\s0
\s-1THE\s0 \s-1CURRENTLY\s0 \s-1SELECTED\s0 \s-1LANGUAGE\s0\fR, or any uniquely identifying abbreviation
thereof.
.Sp
(See further below for details about the multi-language support of this
package!)
.Sp
If the year is given as one or two digits only (i.e., if the year is less
than 100), it is mapped to the window \*(L"\f(CW1970 - 2069\fR\*(R" as follows:
.Sp
.Vb 2
\&   0 E<lt>= $year E<lt>  70  ==>  $year += 2000;
\&  70 E<lt>= $year E<lt> 100  ==>  $year += 1900;
.Ve
If the day, month and year are all given numerically but \fB\s-1WITHOUT\s0\fR any
delimiting characters between them, this string of digits will be mapped
to the day, month and year as follows:
.Sp
.Vb 7
\&                Length:        Mapping:
\&                  3              dmy
\&                  4              dmyy
\&                  5              dmmyy
\&                  6              ddmmyy
\&                  7              dmmyyyy
\&                  8              ddmmyyyy
.Ve
(Where \*(L"d\*(R" stands for \*(L"day\*(R", \*(L"m\*(R" stands for \*(L"month\*(R" and \*(L"y\*(R" stands for
\*(L"year\*(R".)
.Sp
All other strings consisting purely of digits (without any intervening
delimiters) are rejected, i.e., not recognized.
.Sp
Examples:
.Sp
.Vb 12
\&  "3.1.64"
\&  "3 1 64"
\&  "03.01.64"
\&  "03/01/64"
\&  "3. Jan 1964"
\&  "Birthday: 3. Jan '64 in Backnang/Germany"
\&  "03-Jan-64"
\&  "3.Jan1964"
\&  "3Jan64"
\&  "030164"
\&  "3ja64"
\&  "3164"
.Ve
Experiment! (See the corresponding example applications in the
\*(L"examples\*(R" subdirectory of this distribution in order to do so.)
.Ip "\(bu" 2
\f(CWif (($year,$month,$day) = Decode_Date_US($string))\fR
.Sp
This function scans a given string and tries to parse any date
which might be embedded in it.
.Sp
The function returns an empty list if it can't successfully
extract a valid date from its input string, or else it returns
the date found.
.Sp
The function accepts almost any format, as long as the date is
given in the U.S. american order (hence its name) month-day-year.
.Sp
Thereby, zero or more \fB\s-1NON\s0\-\s-1ALPHANUMERIC\s0\fR characters may \fB\s-1PRECEDE\s0\fR
and \fB\s-1FOLLOW\s0\fR the month (i.e., precede the month and separate it from
the day which follows behind).
.Sp
Moreover, zero or more \fB\s-1NON\s0\-\s-1NUMERIC\s0\fR characters are permitted
\fB\s-1BETWEEN\s0\fR the day and the year, as well as \fB\s-1AFTER\s0\fR the year.
.Sp
The month may be given either numerically (i.e., a number from \*(L"\f(CW1\fR\*(R"
to \*(L"\f(CW12\fR"), or alphanumerically, i.e., as the name of the month \fB\s-1IN\s0
\s-1THE\s0 \s-1CURRENTLY\s0 \s-1SELECTED\s0 \s-1LANGUAGE\s0\fR, or any uniquely identifying abbreviation
thereof.
.Sp
(See further below for details about the multi-language support of this
package!)
.Sp
If the year is given as one or two digits only (i.e., if the year is less
than 100), it is mapped to the window \*(L"\f(CW1970 - 2069\fR\*(R" as follows:
.Sp
.Vb 2
\&   0 E<lt>= $year E<lt>  70  ==>  $year += 2000;
\&  70 E<lt>= $year E<lt> 100  ==>  $year += 1900;
.Ve
If the month, day and year are all given numerically but \fB\s-1WITHOUT\s0\fR any
delimiting characters between them, this string of digits will be mapped
to the month, day and year as follows:
.Sp
.Vb 7
\&                Length:        Mapping:
\&                  3              mdy
\&                  4              mdyy
\&                  5              mddyy
\&                  6              mmddyy
\&                  7              mddyyyy
\&                  8              mmddyyyy
.Ve
(Where \*(L"m\*(R" stands for \*(L"month\*(R", \*(L"d\*(R" stands for \*(L"day\*(R" and \*(L"y\*(R" stands for
\*(L"year\*(R".)
.Sp
All other strings consisting purely of digits (without any intervening
delimiters) are rejected, i.e., not recognized.
.Sp
If only the day and the year form a contiguous string of digits, they
will be mapped as follows:
.Sp
.Vb 6
\&                Length:        Mapping:
\&                  2              dy
\&                  3              dyy
\&                  4              ddyy
\&                  5              dyyyy
\&                  6              ddyyyy
.Ve
(Where \*(L"d\*(R" stands for \*(L"day\*(R" and \*(L"y\*(R" stands for \*(L"year\*(R".)
.Sp
Examples:
.Sp
.Vb 9
\&  "1 3 64"
\&  "01/03/64"
\&  "Jan 3 '64"
\&  "Jan 3 1964"
\&  "===> January 3rd 1964 (birthday)"
\&  "Jan31964"
\&  "Jan364"
\&  "ja364"
\&  "1364"
.Ve
Experiment! (See the corresponding example applications in the
\*(L"examples\*(R" subdirectory of this distribution in order to do so.)
.Ip "\(bu" 2
\f(CW$date = Compress($year,$month,$day);\fR
.Sp
This function encodes a date in 16 bits, which is the value being returned.
.Sp
The encoding scheme is as follows:
.Sp
.Vb 2
\&            Bit number:    FEDCBA9 8765 43210
\&            Contents:      yyyyyyy mmmm ddddd
.Ve
(Where the \*(L"yyyyyyy\*(R" contain the number of the year, \*(L"mmmm\*(R" the number of
the month and \*(L"ddddd\*(R" the number of the day.)
.Sp
The function returns \*(L"\f(CW0\fR\*(R" if the given input values do not represent a
valid date. Therefore, the return value of this function can also be used
as the conditional expression in an \*(L"if\*(R" statement, in order to check
wether the given input values constitute a valid date).
.Sp
Through this special encoding scheme, it is possible to \fB\s-1COMPARE\s0\fR
compressed dates for equality and order (less than/greater than)
\fB\s-1WITHOUT\s0\fR any previous \fB\s-1DECODING\s0\fR!
.Sp
Note however that contiguous dates do \fB\s-1NOT\s0\fR necessarily have contiguous
compressed representations!
.Sp
I.e., incrementing the compressed representation of a date \fB\s-1MAY\s0 \s-1OR\s0 \s-1MAY\s0 \s-1NOT\s0\fR
yield a valid new date!
.Sp
Note also that this function can only handle dates within one century.
.Sp
This century can be chosen at random by defining a base century and year
(also called the \*(L"epoch"). In the original distribution of this package,
the base century is set to \*(L"1900\*(R" and the base year to \*(L"70\*(R" (which is
standard on \s-1UNIX\s0 systems).
.Sp
This allows this function to handle dates from \*(L"1970\*(R" up to \*(L"2069\*(R".
.Sp
If the given year is equal to, say, \*(L"95\*(R", this package will automatically
assume that you really mean \*(L"1995\*(R" instead. However, if you specify a year
number which is \fB\s-1SMALLER\s0\fR than 70, like \*(L"64\*(R", for instance, this package
will assume that you really mean \*(L"2064\*(R".
.Sp
You are not confined to two-digit (abbreviated) year numbers, though.
.Sp
The function also accepts \*(L"full-length\*(R" year numbers, provided that they
lie in the supported range (i.e., from \*(L"1970\*(R" to \*(L"2069\*(R", in the original
configuration of this package).
.Sp
Note that this function is maintained mainly for backward compatibility,
and that its use is not recommended.
.Ip "\(bu" 2
\f(CWif (($century,$year,$month,$day) = Uncompress($date))\fR
.Sp
This function decodes dates that were encoded previously using the function
\*(L"\f(CWCompress()\fR\*(R".
.Sp
It returns the century, year, month and day of the date encoded in \*(L"\f(CW$date\fR\*(R"
if \*(L"\f(CW$date\fR\*(R" represents a valid date, or an empty list otherwise.
.Sp
The year returned in \*(L"\f(CW$year\fR\*(R" is actually a two-digit year number
(i.e., the year number taken modulo 100), and only the expression
\*(L"\f(CW$century + $year\fR\*(R" yields the \*(L"full-length\*(R" year number
(for example, \f(CW1900 + 95 = 1995\fR).
.Sp
Note that this function is maintained mainly for backward compatibility,
and that its use is not recommended.
.Ip "\(bu" 2
\f(CWif (check_compressed($date))\fR
.Sp
This function returns \*(L"true\*(R" ("\f(CW1\fR") if the given input value
constitutes a valid compressed date, and \*(L"false\*(R" ("\f(CW0\fR") otherwise.
.Sp
Note that this function is maintained mainly for backward compatibility,
and that its use is not recommended.
.Ip "\(bu" 2
\f(CW$string = Compressed_to_Text($date);\fR
.Sp
This function returns a string of fixed length (always 9 characters long)
containing a textual representation of the compressed date encoded in
\*(L"\f(CW$date\fR\*(R".
.Sp
This string has the form \*(L"dd-Mmm-yy\*(R", where \*(L"dd\*(R" is the two-digit number
of the day, \*(L"Mmm\*(R" are the first three letters of the name of the month
in the currently selected language (see further below for details about
the multi-language support of this package), and \*(L"yy\*(R" is the two-digit
year number (i.e., the year number taken modulo 100).
.Sp
If \*(L"\f(CW$date\fR\*(R" does not represent a valid date, the string \*(L"??\-???\-??\*(R" is
returned instead.
.Sp
Note that this function is maintained mainly for backward compatibility,
and that its use is not recommended.
.Ip "\(bu" 2
\f(CW$string = Date_to_Text($year,$month,$day);\fR
.Sp
This function returns a string containing a textual representation of the
given date of the form \*(L"www dd-Mmm-yyyy\*(R", where \*(L"www\*(R" are the first three
letters of the name of the day of week in the currently selected language,
or a special abbreviation, if special abbreviations have been defined for
the currently selected language (see further below for details about the
multi-language support of this package), \*(L"dd\*(R" is the day (one or two digits),
\*(L"Mmm\*(R" are the first three letters of the name of the month in the currently
selected language, and \*(L"yyyy\*(R" is the number of the year in full length.
.Sp
If the given input values do not constitute a valid date, a fatal \*(L"not a
valid date\*(R" error occurs.
.Sp
(See the section \*(L"\s-1RECIPES\s0\*(R" near the end of this document for a code snippet
for how to print dates in any format you like.)
.Ip "\(bu" 2
\f(CW$string = Date_to_Text_Long($year,$month,$day);\fR
.Sp
This function returns a string containing a textual representation of the
given date roughly of the form \*(L"Wwwwww, dd Mmmmmm yyyy\*(R", where \*(L"Wwwwww\*(R"
is the name of the day of week in the currently selected language (see
further below for details about the multi-language support of this package),
\*(L"dd\*(R" is the day (one or two digits), \*(L"Mmmmmm\*(R" is the name of the month
in the currently selected language, and \*(L"yyyy\*(R" is the number of the year
in full length.
.Sp
The exact format of the output string depends on the currently selected
language. In the original distribution of this package, these formats are
defined as follows:
.Sp
.Vb 7
\&  1  English    :  "Wwwwww, Mmmmmm ddth yyyy"
\&  2  French     :  "Wwwwww, le dd Mmmmmm yyyy"
\&  3  German     :  "Wwwwww, den dd. Mmmmmm yyyy"
\&  4  Spanish    :  "Wwwwww, dd de Mmmmmm de yyyy"
\&  5  Portuguese :  "Wwwwww, dia dd de Mmmmmm de yyyy"
\&  6  Dutch      :  "Wwwwww, dd. Mmmmmm yyyy"
\&  7  Italian    :  "Wwwwww, dd Mmmmmm yyyy"
.Ve
(You can change these formats in the file \*(L"DateCalc.c\*(R" before
building this module in order to suit your personal preferences.)
.Sp
If the given input values do not constitute a valid date, a fatal
\*(L"not a valid date\*(R" error occurs.
.Sp
(See the section \*(L"\s-1RECIPES\s0\*(R" near the end of this document for
an example on how to print dates in any format you like.)
.Ip "\(bu" 2
\f(CW$string = English_Ordinal($number);\fR
.Sp
This function returns a string containing the (english) abbreviation
of the ordinal number for the given (cardinal) number \*(L"\f(CW$number\fR\*(R".
.Sp
I.e.,
.Sp
.Vb 10
\&    0  =>  '0th'    10  =>  '10th'    20  =>  '20th'
\&    1  =>  '1st'    11  =>  '11th'    21  =>  '21st'
\&    2  =>  '2nd'    12  =>  '12th'    22  =>  '22nd'
\&    3  =>  '3rd'    13  =>  '13th'    23  =>  '23rd'
\&    4  =>  '4th'    14  =>  '14th'    24  =>  '24th'
\&    5  =>  '5th'    15  =>  '15th'    25  =>  '25th'
\&    6  =>  '6th'    16  =>  '16th'    26  =>  '26th'
\&    7  =>  '7th'    17  =>  '17th'    27  =>  '27th'
\&    8  =>  '8th'    18  =>  '18th'    28  =>  '28th'
\&    9  =>  '9th'    19  =>  '19th'    29  =>  '29th'
.Ve
etc.
.Ip "\(bu" 2
\f(CW$string = Calendar($year,$month);\fR
.Sp
This function returns a calendar of the given month in the given year
(somewhat similar to the \s-1UNIX\s0 \*(L"cal\*(R" command), \fB\s-1IN\s0 \s-1THE\s0 \s-1CURRENTLY\s0 \s-1SELECTED\s0
\s-1LANGUAGE\s0\fR (see further below for details about the multi-language support
of this package).
.Sp
Example:
.Sp
.Vb 1
\&  print Calendar(1998,5);
.Ve
This will print:
.Sp
.Vb 7
\&           May 1998
\&  Mon Tue Wed Thu Fri Sat Sun
\&                    1   2   3
\&    4   5   6   7   8   9  10
\&   11  12  13  14  15  16  17
\&   18  19  20  21  22  23  24
\&   25  26  27  28  29  30  31
.Ve
.Ip "\(bu" 2
\f(CW$string = Month_to_Text($month);\fR
.Sp
This function returns the name of the given month in the currently selected
language (see further below for details about the multi-language support of
this package).
.Sp
If the given month lies outside of the valid range from \*(L"\f(CW1\fR\*(R" to \*(L"\f(CW12\fR\*(R",
a fatal \*(L"month out of range\*(R" error will occur.
.Ip "\(bu" 2
\f(CW$string = Day_of_Week_to_Text($dow);\fR
.Sp
This function returns the name of the given day of week in the currently
selected language (see further below for details about the multi-language
support of this package).
.Sp
If the given day of week lies outside of the valid range from \*(L"\f(CW1\fR\*(R" to \*(L"\f(CW7\fR\*(R",
a fatal \*(L"day of week out of range\*(R" error will occur.
.Ip "\(bu" 2
\f(CW$string = Day_of_Week_Abbreviation($dow);\fR
.Sp
This function returns the special abbreviation of the name of the given
day of week, \fB\s-1IF\s0\fR such special abbreviations have been defined for the
currently selected language (see further below for details about the
multi-language support of this package).
.Sp
(In the original distribution of this package, this is only true for
Portuguese.)
.Sp
If not, the first three letters of the name of the day of week in the
currently selected language are returned instead.
.Sp
If the given day of week lies outside of the valid range from \*(L"\f(CW1\fR\*(R"
to \*(L"\f(CW7\fR\*(R", a fatal \*(L"day of week out of range\*(R" error will occur.
.Sp
Currently, this table of special abbreviations is only used by the
functions \*(L"\f(CWDate_to_Text()\fR\*(R" and \*(L"\f(CWCalendar()\fR\*(R", internally.
.Ip "\(bu" 2
\f(CW$string = Language_to_Text($lang);\fR
.Sp
This function returns the name of any language supported by this package
when the internal number representing that language is given as input.
.Sp
The original distribution supports the following seven languages:
.Sp
.Vb 7
\&            1   ==>   English                     (default)
\&            2   ==>   Français    (French)
\&            3   ==>   Deutsch     (German)
\&            4   ==>   Español     (Spanish)
\&            5   ==>   Português   (Portuguese)
\&            6   ==>   Nederlands  (Dutch)
\&            7   ==>   Italiano    (Italian)
.Ve
See the section \*(L"How to install additional languages\*(R" in the file
\*(L"\s-1INSTALL\s0.txt\*(R" in this distribution for how to add more languages
to this package.
.Sp
See the description of the function \*(L"\f(CWLanguages()\fR\*(R" further below
to determine how many languages are actually available in a given
installation of this package.
.Ip "\(bu" 2
\f(CW$lang = Language();\fR
.Ip "\(bu" 2
\f(CWLanguage($lang);\fR
.Ip "\(bu" 2
\f(CW$oldlang = Language($newlang);\fR
.Sp
This function can be used to determine which language is currently selected,
and to change the selected language.
.Sp
Thereby, each language has a unique internal number.
.Sp
The original distribution contains the following seven languages:
.Sp
.Vb 7
\&            1   ==>   English                     (default)
\&            2   ==>   Français    (French)
\&            3   ==>   Deutsch     (German)
\&            4   ==>   Español     (Spanish)
\&            5   ==>   Português   (Portuguese)
\&            6   ==>   Nederlands  (Dutch)
\&            7   ==>   Italiano    (Italian)
.Ve
See the section \*(L"How to install additional languages\*(R" in the file
\*(L"\s-1INSTALL\s0.txt\*(R" in this distribution for how to add more languages
to this package.
.Sp
See the description of the function \*(L"\f(CWLanguages()\fR\*(R" further below
to determine how many languages are actually available in a given
installation of this package.
.Sp
\fB\s-1BEWARE\s0\fR that in order for your programs to be portable, you should \fB\s-1NEVER\s0\fR
actually use the internal number of a language in this package \fB\s-1EXPLICITLY\s0\fR,
because the same number could mean different languages on different systems,
depending on what languages have been added to any given installation of this
package.
.Sp
Therefore, you should always use a statement such as
.Sp
.Vb 1
\&  Language(Decode_Language("Name_of_Language"));
.Ve
to select the desired language, and
.Sp
.Vb 1
\&  $language = Language_to_Text(Language());
.Ve
or
.Sp
.Vb 1
\&  $old_language = Language_to_Text(Language("Name_of_new_Language"));
.Ve
to determine the (previously) selected language.
.Sp
If the so chosen language is not available in the current installation,
this will result in an appropriate error message, instead of silently
using the wrong (a random) language (which just happens to have the
same internal number in the other installation).
.Sp
Note that in the current implementation of this package, the selected
language is a global setting valid for \fB\s-1ALL\s0\fR functions that use the names
of months, days of week or languages internally, valid for \fB\s-1ALL\s0 \s-1PROCESSES\s0\fR
using the same copy of the \*(L"Date::Calc\*(R" shared library in memory!
.Sp
This may have surprising side-effects in a multi-user environment, and even
more so when Perl will be capable of multi-threading in some future release.
.Ip "\(bu" 2
\f(CW$max_lang = Languages();\fR
.Sp
This function returns the (maximum) number of languages which are
currently available in your installation of this package.
.Sp
(This may vary from installation to installation.)
.Sp
See the section \*(L"How to install additional languages\*(R" in the file
\*(L"\s-1INSTALL\s0.txt\*(R" in this distribution for how to add more languages
to this package.
.Sp
In the original distribution of this package there are seven built-in
languages, therefore the value returned by this function will be \*(L"\f(CW7\fR\*(R"
if no other languages have been added to your particular installation.
.Ip "\(bu" 2
\f(CWif (($year,$month,$day) = Decode_Date_EU2($string))\fR
.Sp
This function is the Perl equivalent of the function \*(L"\f(CWDecode_Date_EU()\fR\*(R"
(implemented in C), included here merely as an example to demonstrate how
easy it is to write your own routine in Perl (using regular expressions)
adapted to your own special needs, should the necessity arise, and intended
primarily as a basis for your own development.
.Sp
In one particular case this Perl version is actually slightly more permissive
than its C equivalent, as far as the class of permitted intervening (i.e.,
delimiting) characters is concerned.
.Sp
(Can you tell the subtle, almost insignificant difference by looking at
the code? Or by experimenting? Hint: Try the string \*(L"a3b1c64d\*(R" with both
functions.)
.Ip "\(bu" 2
\f(CWif (($year,$month,$day) = Decode_Date_US2($string))\fR
.Sp
This function is the Perl equivalent of the function \*(L"\f(CWDecode_Date_US()\fR\*(R"
(implemented in C), included here merely as an example to demonstrate how
easy it is to write your own routine in Perl (using regular expressions)
adapted to your own special needs, should the necessity arise, and intended
primarily as a basis for your own development.
.Sp
In one particular case this Perl version is actually slightly more permissive
than its C equivalent.
.Sp
(Hint: This is the same difference as with the \*(L"\f(CWDecode_Date_EU()\fR\*(R" and
\*(L"\f(CWDecode_Date_EU2()\fR\*(R" pair of functions.)
.Sp
In a different case, the C version is a little bit more permissive than its
Perl equivalent.
.Sp
(Can you tell the difference by looking at the code? Or by experimenting?
Hint: Try the string \*(L"(1/364)\*(R" with both functions.)
.Ip "\(bu" 2
\f(CWif (($year,$month,$day) = Parse_Date($string))\fR
.Sp
This function is useful for parsing dates as returned by the \s-1UNIX\s0 \*(L"\f(CWdate\fR\*(R"
command or as found in the headers of e-mail (in order to determine the
date at which some e-mail has been sent or received, for instance).
.Sp
Example #1:
.Sp
.Vb 1
\&  ($year,$month,$day) = Parse_Date(`/bin/date`);
.Ve
Example #2:
.Sp
.Vb 9
\&  while (<MAIL>)
\&  {
\&      if (/^From \eS/)
\&      {
\&          ($year,$month,$day) = Parse_Date($_);
\&          ...
\&      }
\&      ...
\&  }
.Ve
The function returns an empty list if it can't extract a valid date from
the input string.
.Ip "\(bu" 2
\f(CW$string = Date::Calc::Version();\fR
.Sp
This function returns a string with the (numeric) version number of the
C\ library ("DateCalc.c") at the core of this package (which is also
(automatically) the version number of the \*(L"Calc.xs\*(R" file).
.Sp
Note that under all normal circumstances, this version number should be
identical with the one found in the Perl variable \*(L"\f(CW$Date::Calc::VERSION\fR\*(R"
(the version number of the \*(L"Calc.pm\*(R" file).
.Sp
Since this function is not exported, you always have to qualify it explicitly,
i.e., \*(L"\f(CWDate::Calc::Version()\fR\*(R".
.Sp
This is to avoid possible name space conflicts with version functions from
other modules.
.SH "RECIPES"
.Ip "1)" 4
How do I compare two dates?
.Sp
Solution #1:
.Sp
.Vb 1
\&  use Date::Calc qw( Date_to_Days );
.Ve
.Vb 2
\&  if (Date_to_Days($year1,$month1,$day1)  <
\&      Date_to_Days($year2,$month2,$day2))
.Ve
.Vb 2
\&  if (Date_to_Days($year1,$month1,$day1)  <=
\&      Date_to_Days($year2,$month2,$day2))
.Ve
.Vb 2
\&  if (Date_to_Days($year1,$month1,$day1)  >
\&      Date_to_Days($year2,$month2,$day2))
.Ve
.Vb 2
\&  if (Date_to_Days($year1,$month1,$day1)  >=
\&      Date_to_Days($year2,$month2,$day2))
.Ve
.Vb 2
\&  if (Date_to_Days($year1,$month1,$day1)  ==
\&      Date_to_Days($year2,$month2,$day2))
.Ve
.Vb 2
\&  if (Date_to_Days($year1,$month1,$day1)  !=
\&      Date_to_Days($year2,$month2,$day2))
.Ve
.Vb 2
\&  $cmp = (Date_to_Days($year1,$month1,$day1)  <=>
\&          Date_to_Days($year2,$month2,$day2));
.Ve
Solution #2:
.Sp
.Vb 1
\&  use Date::Calc qw( Delta_Days );
.Ve
.Vb 2
\&  if (Delta_Days($year1,$month1,$day1,
\&                 $year2,$month2,$day2) > 0)
.Ve
.Vb 2
\&  if (Delta_Days($year1,$month1,$day1,
\&                 $year2,$month2,$day2) >= 0)
.Ve
.Vb 2
\&  if (Delta_Days($year1,$month1,$day1,
\&                 $year2,$month2,$day2) < 0)
.Ve
.Vb 2
\&  if (Delta_Days($year1,$month1,$day1,
\&                 $year2,$month2,$day2) <= 0)
.Ve
.Vb 2
\&  if (Delta_Days($year1,$month1,$day1,
\&                 $year2,$month2,$day2) == 0)
.Ve
.Vb 2
\&  if (Delta_Days($year1,$month1,$day1,
\&                 $year2,$month2,$day2) != 0)
.Ve
.Ip "2)" 4
How do I check wether a given date lies within a certain range of dates?
.Sp
.Vb 1
\&  use Date::Calc qw( Date_to_Days );
.Ve
.Vb 2
\&  $lower = Date_to_Days($year1,$month1,$day1);
\&  $upper = Date_to_Days($year2,$month2,$day2);
.Ve
.Vb 1
\&  $date = Date_to_Days($year,$month,$day);
.Ve
.Vb 8
\&  if (($date >= $lower) && ($date <= $upper))
\&  {
\&      # ok
\&  }
\&  else
\&  {
\&      # not ok
\&  }
.Ve
.Ip "3)" 4
How do I verify wether someone has a certain age?
.Sp
.Vb 1
\&  use Date::Calc qw( Decode_Date_EU Today leap_year Delta_Days );
.Ve
.Vb 1
\&  $date = <STDIN>; # get birthday
.Ve
.Vb 1
\&  ($year1,$month1,$day1) = Decode_Date_EU($date);
.Ve
.Vb 1
\&  ($year2,$month2,$day2) = Today();
.Ve
.Vb 2
\&  if (($day1 == 29) && ($month1 == 2) && !leap_year($year2))
\&      { $day1--; }
.Ve
.Vb 10
\&  if ( (($year2 - $year1) >  18) ||
\&     ( (($year2 - $year1) == 18) &&
\&     (Delta_Days($year2,$month1,$day1, $year2,$month2,$day2) >= 0) ) )
\&  {
\&      print "Ok - you are over 18.\en";
\&  }
\&  else
\&  {
\&      print "Sorry - you aren't 18 yet!\en";
\&  }
.Ve
.Ip "4)" 4
How do I calculate the number of the week of month
the current date lies in?
.Sp
For example:
.Sp
.Vb 7
\&            April 1998
\&    Mon Tue Wed Thu Fri Sat Sun
\&              1   2   3   4   5  =  week #1
\&      6   7   8   9  10  11  12  =  week #2
\&     13  14  15  16  17  18  19  =  week #3
\&     20  21  22  23  24  25  26  =  week #4
\&     27  28  29  30              =  week #5
.Ve
Solution:
.Sp
.Vb 1
\&  use Date::Calc qw( Today Day_of_Week );
.Ve
.Vb 1
\&  ($year,$month,$day) = Today();
.Ve
.Vb 1
\&  $week = int(($day + Day_of_Week($year,$month,1) - 2) / 7) + 1;
.Ve
.Ip "5)" 4
How do I calculate wether a given date is the 1st, 2nd, 3rd, 4th or 5th
of that day of week in the given month?
.Sp
For example:
.Sp
.Vb 8
\&           October 2000
\&    Mon Tue Wed Thu Fri Sat Sun
\&                              1
\&      2   3   4   5   6   7   8
\&      9  10  11  12  13  14  15
\&     16  17  18  19  20  21  22
\&     23  24  25  26  27  28  29
\&     30  31
.Ve
Is Sunday, the 15th of October 2000, the 1st, 2nd, 3rd, 4th or 5th
Sunday of that month?
.Sp
Solution:
.Sp
.Vb 4
\&  use Date::Calc qw( Day_of_Week Delta_Days
\&                     Nth_Weekday_of_Month_Year
\&                     Date_to_Text_Long English_Ordinal
\&                     Day_of_Week_to_Text Month_to_Text );
.Ve
.Vb 1
\&  ($year,$month,$day) = (2000,10,15);
.Ve
.Vb 1
\&  $dow = Day_of_Week($year,$month,$day);
.Ve
.Vb 4
\&  $n = int( Delta_Days(
\&            Nth_Weekday_of_Month_Year($year,$month,$dow,1),
\&            $year,$month,$day)
\&            / 7) + 1;
.Ve
.Vb 6
\&  printf("%s is the %s %s in %s %d.\en",
\&      Date_to_Text_Long($year,$month,$day),
\&      English_Ordinal($n),
\&      Day_of_Week_to_Text($dow),
\&      Month_to_Text($month),
\&      $year);
.Ve
This prints:
.Sp
.Vb 1
\&  Sunday, October 15th 2000 is the 3rd Sunday in October 2000.
.Ve
.Ip "6)" 4
How do I calculate the date of the Wednesday of the same week as
the current date?
.Sp
Solution #1:
.Sp
.Vb 1
\&  use Date::Calc qw( Today Day_of_Week Add_Delta_Days );
.Ve
.Vb 1
\&  $searching_dow = 3; # 3 = Wednesday
.Ve
.Vb 1
\&  @today = Today();
.Ve
.Vb 1
\&  $current_dow = Day_of_Week(@today);
.Ve
.Vb 1
\&  @date = Add_Delta_Days(@today, $searching_dow - $current_dow);
.Ve
Solution #2:
.Sp
.Vb 2
\&  use Date::Calc qw( Today Add_Delta_Days
\&                     Monday_of_Week Week_of_Year );
.Ve
.Vb 1
\&  $searching_dow = 3; # 3 = Wednesday
.Ve
.Vb 1
\&  @today = Today();
.Ve
.Vb 2
\&  @date = Add_Delta_Days( Monday_of_Week( Week_of_Year(@today) ),
\&                          $searching_dow - 1 );
.Ve
Solution #3:
.Sp
.Vb 2
\&  use Date::Calc qw( Standard_to_Business Today
\&                     Business_to_Standard );
.Ve
.Vb 1
\&  @business = Standard_to_Business(Today());
.Ve
.Vb 1
\&  $business[2] = 3; # 3 = Wednesday
.Ve
.Vb 1
\&  @date = Business_to_Standard(@business);
.Ve
.Ip "7)" 4
How can I add a week offset to a business date (including across
year boundaries)?
.Sp
.Vb 2
\&  use Date::Calc qw( Business_to_Standard Add_Delta_Days
\&                     Standard_to_Business );
.Ve
.Vb 1
\&  @temp = Business_to_Standard($year,$week,$dow);
.Ve
.Vb 1
\&  @temp = Add_Delta_Days(@temp, $week_offset * 7);
.Ve
.Vb 1
\&  ($year,$week,$dow) = Standard_to_Business(@temp);
.Ve
.Ip "8)" 4
How do I calculate the last and the next Saturday for any
given date?
.Sp
.Vb 2
\&  use Date::Calc qw( Today Day_of_Week Add_Delta_Days
\&                     Day_of_Week_to_Text Date_to_Text );
.Ve
.Vb 1
\&  $searching_dow = 6; # 6 = Saturday
.Ve
.Vb 1
\&  @today = Today();
.Ve
.Vb 1
\&  $current_dow = Day_of_Week(@today);
.Ve
.Vb 20
\&  if ($searching_dow == $current_dow)
\&  {
\&      @prev = Add_Delta_Days(@today,-7);
\&      @next = Add_Delta_Days(@today,+7);
\&  }
\&  else
\&  {
\&      if ($searching_dow > $current_dow)
\&      {
\&          @next = Add_Delta_Days(@today,
\&                    $searching_dow - $current_dow);
\&          @prev = Add_Delta_Days(@next,-7);
\&      }
\&      else
\&      {
\&          @prev = Add_Delta_Days(@today,
\&                    $searching_dow - $current_dow);
\&          @next = Add_Delta_Days(@prev,+7);
\&      }
\&  }
.Ve
.Vb 1
\&  $dow = Day_of_Week_to_Text($searching_dow);
.Ve
.Vb 4
\&  print "Today is:      ", ' ' x length($dow),
\&                               Date_to_Text(@today), "\en";
\&  print "Last $dow was:     ", Date_to_Text(@prev),  "\en";
\&  print "Next $dow will be: ", Date_to_Text(@next),  "\en";
.Ve
This will print something like:
.Sp
.Vb 3
\&  Today is:              Sun 12-Apr-1998
\&  Last Saturday was:     Sat 11-Apr-1998
\&  Next Saturday will be: Sat 18-Apr-1998
.Ve
.Ip "9)" 4
How can I calculate the last business day (payday!) of a month?
.Sp
Solution #1 (holidays \fB\s-1NOT\s0\fR taken into account):
.Sp
.Vb 1
\&  use Date::Calc qw( Days_in_Month Day_of_Week Add_Delta_Days );
.Ve
.Vb 7
\&  $day = Days_in_Month($year,$month);
\&  $dow = Day_of_Week($year,$month,$day);
\&  if ($dow > 5)
\&  {
\&      ($year,$month,$day) =
\&          Add_Delta_Days($year,$month,$day, 5-$dow);
\&  }
.Ve
Solution #2 (holidays taken into account):
.Sp
This solution expects a multi-dimensional array \*(L"\f(CW@holiday\fR\*(R", which
contains all holidays, as follows: \*(L"\f(CW$holiday[$year][$month][$day] = 1;\fR\*(R".
.Sp
(See the description of the function \*(L"\f(CWEaster_Sunday()\fR\*(R" further above for
how to calculate the moving (variable) christian feast days!)
.Sp
Days which are not holidays remain undefined or should have a value of zero
in this array.
.Sp
.Vb 1
\&  use Date::Calc qw( Days_in_Month Add_Delta_Days Day_of_Week );
.Ve
.Vb 16
\&  $day = Days_in_Month($year,$month);
\&  while (1)
\&  {
\&      while ($holiday[$year][$month][$day])
\&      {
\&          ($year,$month,$day) =
\&              Add_Delta_Days($year,$month,$day, -1);
\&      }
\&      $dow = Day_of_Week($year,$month,$day);
\&      if ($dow > 5)
\&      {
\&          ($year,$month,$day) =
\&              Add_Delta_Days($year,$month,$day, 5-$dow);
\&      }
\&      else { last; }
\&  }
.Ve
.Ip "10)" 4
How do I convert a \s-1MS\s0 Visual Basic \*(L"\s-1DATETIME\s0\*(R" value into its date
and time constituents?
.Sp
.Vb 1
\&  use Date::Calc qw( Add_Delta_DHMS Date_to_Text );
.Ve
.Vb 1
\&  $datetime = "35883.121653";
.Ve
.Vb 1
\&  ($Dd,$Dh,$Dm,$Ds) = ($datetime =~ /^(\ed+)\e.(\ed\ed)(\ed\ed)(\ed\ed)$/);
.Ve
.Vb 2
\&  ($year,$month,$day, $hour,$min,$sec) =
\&      Add_Delta_DHMS(1900,1,1, 0,0,0, $Dd,$Dh,$Dm,$Ds);
.Ve
.Vb 2
\&  printf("The given date is %s %02d:%02d:%02d\en",
\&      Date_to_Text($year,$month,$day), $hour, $min, $sec);
.Ve
This prints:
.Sp
.Vb 1
\&  The given date is Tue 31-Mar-1998 12:16:53
.Ve
.Ip "11)" 4
How can I send a reminder to members of a group on the day
before a meeting which occurs every first Friday of a month?
.Sp
.Vb 2
\&  use Date::Calc qw( Today Date_to_Days Add_Delta_YMD
\&                     Nth_Weekday_of_Month_Year );
.Ve
.Vb 1
\&  ($year,$month,$day) = Today();
.Ve
.Vb 1
\&  $tomorrow = Date_to_Days($year,$month,$day) + 1;
.Ve
.Vb 2
\&  $dow = 5; # 5 = Friday
\&  $n   = 1; # 1 = First of that day of week
.Ve
.Vb 2
\&  $meeting_this_month = Date_to_Days(
\&      Nth_Weekday_of_Month_Year($year,$month,$dow,$n) );
.Ve
.Vb 1
\&  ($year,$month,$day) = Add_Delta_YMD($year,$month,$day, 0,1,0);
.Ve
.Vb 2
\&  $meeting_next_month = Date_to_Days(
\&      Nth_Weekday_of_Month_Year($year,$month,$dow,$n) );
.Ve
.Vb 5
\&  if (($tomorrow == $meeting_this_month) ||
\&      ($tomorrow == $meeting_next_month))
\&  {
\&      # Send reminder e-mail!
\&  }
.Ve
.Ip "12)" 4
How can I print a date in a different format than provided by
the functions \*(L"\f(CWDate_to_Text()\fR\*(R", \*(L"\f(CWDate_to_Text_Long()\fR\*(R" or
\*(L"\f(CWCompressed_to_Text()\fR\*(R"?
.Sp
.Vb 3
\&  use Date::Calc qw( Today Day_of_Week_to_Text
\&                     Day_of_Week Month_to_Text
\&                     English_Ordinal );
.Ve
.Vb 1
\&  ($year,$month,$day) = Today();
.Ve
For example with leading zeros for the day: \*(L"Fri\ 03-Jan-1964\*(R"
.Sp
.Vb 5
\&  printf("%.3s %02d-%.3s-%d\en",
\&      Day_of_Week_to_Text(Day_of_Week($year,$month,$day)),
\&      $day,
\&      Month_to_Text($month),
\&      $year);
.Ve
For example in U.S. american format: \*(L"April\ 12th,\ 1998\*(R"
.Sp
.Vb 4
\&  $string = sprintf("%s %s, %d",
\&                Month_to_Text($month),
\&                English_Ordinal($day),
\&                $year);
.Ve
(See also the \f(CWprintf\fR entry in the \fIperlfunc(1)\fR manpage and/or the \f(CWsprintf\fR entry in the \fIperlfunc(1)\fR manpage!)
.Ip "13)" 4
How can I iterate through a range of dates?
.Sp
.Vb 1
\&  use Date::Calc qw( Delta_Days Add_Delta_Days );
.Ve
.Vb 2
\&  @start = (1999,5,27);
\&  @stop  = (1999,6,1);
.Ve
.Vb 1
\&  $j = Delta_Days(@start,@stop);
.Ve
.Vb 5
\&  for ( $i = 0; $i <= $j; $i++ )
\&  {
\&      @date = Add_Delta_Days(@start,$i);
\&      printf("%4d/%02d/%02d\en", @date);
\&  }
.Ve
Note that the loop can be improved; see also the recipe below.
.Ip "14)" 4
How can I create a (Perl) list of dates in a certain range?
.Sp
.Vb 1
\&  use Date::Calc qw( Delta_Days Add_Delta_Days Date_to_Text );
.Ve
.Vb 5
\&  sub date_range
\&  {
\&      my(@date) = (@_)[0,1,2];
\&      my(@list);
\&      my($i);
.Ve
.Vb 8
\&      $i = Delta_Days(@_);
\&      while ($i-- >= 0)
\&      {
\&          push( @list, [ @date ] );
\&          @date = Add_Delta_Days(@date, 1) if ($i >= 0);
\&      }
\&      return(@list);
\&  }
.Ve
.Vb 1
\&  @range = &date_range(1999,11,3, 1999,12,24); # in chronological order
.Ve
.Vb 4
\&  foreach $date (@range)
\&  {
\&      print Date_to_Text(@{$date}), "\en";
\&  }
.Ve
Note that you probably shouldn't use this one, because it is much
more efficient to iterate through all the dates (as shown in the
recipe immediately above) than to construct such an array and then
to loop through it. Also, it is much more space-efficient not to
create this array.
.Ip "15)" 4
How can I calculate the difference in days between dates,
but without counting Saturdays and Sundays?
.Sp
.Vb 5
\&  sub Delta_Business_Days
\&  {
\&      my(@date1) = (@_)[0,1,2];
\&      my(@date2) = (@_)[3,4,5];
\&      my($minus,$result,$dow1,$dow2,$diff,$temp);
.Ve
.Vb 44
\&      $minus  = 0;
\&      $result = Delta_Days(@date1,@date2);
\&      if ($result != 0)
\&      {
\&          if ($result < 0)
\&          {
\&              $minus = 1;
\&              $result = -$result;
\&              $dow1 = Day_of_Week(@date2);
\&              $dow2 = Day_of_Week(@date1);
\&          }
\&          else
\&          {
\&              $dow1 = Day_of_Week(@date1);
\&              $dow2 = Day_of_Week(@date2);
\&          }
\&          $diff = $dow2 - $dow1;
\&          $temp = $result;
\&          if ($diff != 0)
\&          {
\&              if ($diff < 0)
\&              {
\&                  $diff += 7;
\&              }
\&              $temp -= $diff;
\&              $dow1 += $diff;
\&              if ($dow1 > 6)
\&              {
\&                  $result--;
\&                  if ($dow1 > 7)
\&                  {
\&                      $result--;
\&                  }
\&              }
\&          }
\&          if ($temp != 0)
\&          {
\&              $temp /= 7;
\&              $result -= ($temp << 1);
\&          }
\&      }
\&      if ($minus) { return -$result; }
\&      else        { return  $result; }
\&  }
.Ve
This solution is probably of little practical value, however,
because it doesn't take legal holidays into account.
.SH "SEE ALSO"
\fIperl\fR\|(1), \fIperlfunc\fR\|(1), \fIperlsub\fR\|(1), \fIperlmod\fR\|(1),
\fIperlxs\fR\|(1), \fIperlxstut\fR\|(1), \fIperlguts\fR\|(1).
.PP
news:news.answers
\*(L"Calendar FAQ, v. 1.9 (modified 25 Apr 1998) Part 1/3\*(R"
.PP
news:news.answers
\*(L"Calendar FAQ, v. 1.9 (modified 25 Apr 1998) Part 2/3\*(R"
.PP
news:news.answers
\*(L"Calendar FAQ, v. 1.9 (modified 25 Apr 1998) Part 3/3\*(R"
.PP
http://www.math.uio.no/faq/calendars/faq.html
.PP
http://www.pip.dknet.dk/~pip10160/calendar.html
.PP
(All authored by Claus Tondering <c-t@pip.dknet.dk>)
.SH "LIMITATIONS"
In the current implementation of this package, the selected language
is stored in a global variable.
.PP
Therefore, when you are using a threaded Perl, this may cause undesired
side effects (of one thread always selecting the language for \fBALL OTHER\fR
threads as well).
.SH "VERSION"
This man page documents \*(L"Date::Calc\*(R" version 4.3.
.SH "AUTHOR"
.PP
.Vb 4
\&  Steffen Beyer
\&  Ainmillerstr. 5 / App. 513
\&  D-80801 Munich
\&  Germany
.Ve
.Vb 2
\&  mailto:sb@engelschall.com
\&  http://www.engelschall.com/u/sb/download/
.Ve
\fBPlease contact me by e-mail whenever possible!\fR
.SH "COPYRIGHT"
Copyright (c) 1995 \- 2000 by Steffen Beyer.
All rights reserved.
.SH "LICENSE"
This package is free software; you can redistribute it and/or
modify it under the same terms as Perl itself, i.e., under the
terms of the \*(L"Artistic License\*(R" or the \*(L"GNU General Public License\*(R".
.PP
The C library at the core of this Perl module can additionally
be redistributed and/or modified under the terms of the
\*(L"GNU Library General Public License\*(R".
.PP
Please refer to the files \*(L"Artistic.txt\*(R", \*(L"GNU_GPL.txt\*(R" and
\*(L"GNU_LGPL.txt\*(R" in this distribution for details!
.SH "DISCLAIMER"
This package is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
.PP
See the \*(L"GNU General Public License\*(R" for more details.

.rn }` ''
.IX Title "Calc 3"
.IX Name "Date::Calc - Gregorian calendar date calculations"

.IX Header "NAME"

.IX Header "PREFACE"

.IX Header "SYNOPSIS"

.IX Header "IMPORTANT NOTES"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Header "DESCRIPTION"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Header "RECIPES"

.IX Item "1)"

.IX Item "2)"

.IX Item "3)"

.IX Item "4)"

.IX Item "5)"

.IX Item "6)"

.IX Item "7)"

.IX Item "8)"

.IX Item "9)"

.IX Item "10)"

.IX Item "11)"

.IX Item "12)"

.IX Item "13)"

.IX Item "14)"

.IX Item "15)"

.IX Header "SEE ALSO"

.IX Header "LIMITATIONS"

.IX Header "VERSION"

.IX Header "AUTHOR"

.IX Header "COPYRIGHT"

.IX Header "LICENSE"

.IX Header "DISCLAIMER"

