.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH lib::Archive::Zip 3 "perl 5.005, patch 03" "27/Mar/2000" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
Archive::Zip \- Provide an interface to ZIP archive files.
.SH "SYNOPSIS"
.PP
.Vb 1
\& use Archive::Zip qw( :ERROR_CODES :CONSTANTS );
.Ve
.Vb 5
\& my $zip = Archive::Zip->new();
\& my $member = $zip->addDirectory( 'dirname/' );
\& $member = $zip->addString( 'This is a test', 'stringMember.txt' );
\& $member->desiredCompressionMethod( COMPRESSION_DEFLATED );
\& $member = $zip->addFile( 'xyz.pl', 'AnotherName.pl' );
.Ve
.Vb 1
\& die 'write error' if $zip->writeToFile( 'someZip.zip' ) != AZ_OK;
.Ve
.Vb 2
\& $zip = Archive::Zip->new();
\& die 'read error' if $zip->read( 'someZip.zip' ) != AZ_OK;
.Ve
.Vb 2
\& $member = $zip->memberNamed( 'stringMember.txt' );
\& $member->desiredCompressionMethod( COMPRESSION_STORED );
.Ve
.Vb 1
\& die 'write error' if $zip->writeToFile( 'someZip.zip' ) != AZ_OK;
.Ve
.SH "DESCRIPTION"
The Archive::Zip module allows a Perl program to create,
manipulate, read, and write Zip archive files.
.PP
Zip archives can be created, or you can read from existing zip files.
Once created, they can be written to files, streams, or strings.
.PP
Members can be added, removed, extracted, replaced, rearranged,
and enumerated.
They can also be renamed or have their dates, comments,
or other attributes queried or modified.
Their data can be compressed or uncompressed as needed.
Members can be created from members in existing Zip files,
or from existing directories, files, or strings.
.PP
This module uses the Compress::Zlib library
to read and write the compressed streams inside the files.
.SH "EXPORTS"
.Ip ":\s-1CONSTANTS\s0" 4
Exports the following constants:
.Sp
\s-1FA_MSDOS\s0 \s-1FA_UNIX\s0 \s-1GPBF_ENCRYPTED_MASK\s0
\s-1GPBF_DEFLATING_COMPRESSION_MASK\s0 \s-1GPBF_HAS_DATA_DESCRIPTOR_MASK\s0
\s-1COMPRESSION_STORED\s0 \s-1COMPRESSION_DEFLATED\s0
\s-1IFA_TEXT_FILE_MASK\s0 \s-1IFA_TEXT_FILE\s0 \s-1IFA_BINARY_FILE\s0
\s-1COMPRESSION_LEVEL_NONE\s0
\s-1COMPRESSION_LEVEL_DEFAULT\s0
\s-1COMPRESSION_LEVEL_FASTEST\s0
\s-1COMPRESSION_LEVEL_BEST_COMPRESSION\s0
.Ip ":\s-1MISC_CONSTANTS\s0" 4
Exports the following constants (only necessary for extending the module):
.Sp
\s-1FA_AMIGA\s0 \s-1FA_VAX_VMS\s0 \s-1FA_VM_CMS\s0 \s-1FA_ATARI_ST\s0
\s-1FA_OS2_HPFS\s0 \s-1FA_MACINTOSH\s0 \s-1FA_Z_SYSTEM\s0 \s-1FA_CPM\s0 \s-1FA_WINDOWS_NTFS\s0
\s-1GPBF_IMPLODING_8K_SLIDING_DICTIONARY_MASK\s0
\s-1GPBF_IMPLODING_3_SHANNON_FANO_TREES_MASK\s0
\s-1GPBF_IS_COMPRESSED_PATCHED_DATA_MASK\s0 \s-1COMPRESSION_SHRUNK\s0
\s-1DEFLATING_COMPRESSION_NORMAL\s0 \s-1DEFLATING_COMPRESSION_MAXIMUM\s0
\s-1DEFLATING_COMPRESSION_FAST\s0 \s-1DEFLATING_COMPRESSION_SUPER_FAST\s0
\s-1COMPRESSION_REDUCED_1\s0 \s-1COMPRESSION_REDUCED_2\s0 \s-1COMPRESSION_REDUCED_3\s0
\s-1COMPRESSION_REDUCED_4\s0 \s-1COMPRESSION_IMPLODED\s0 \s-1COMPRESSION_TOKENIZED\s0
\s-1COMPRESSION_DEFLATED_ENHANCED\s0
\s-1COMPRESSION_PKWARE_DATA_COMPRESSION_LIBRARY_IMPLODED\s0
.Ip ":\s-1ERROR_CODES\s0" 4
Explained below. Returned from most methods.
.Sp
\s-1AZ_OK\s0 \s-1AZ_STREAM_END\s0 \s-1AZ_ERROR\s0 \s-1AZ_FORMAT_ERROR\s0 \s-1AZ_IO_ERROR\s0
.SH "OBJECT MODEL"
.Sh "Inheritance"
.PP
.Vb 9
\& Exporter
\&    Archive::Zip                            Common base class, has defs.
\&        Archive::Zip::Archive               A Zip archive.
\&        Archive::Zip::Member                Abstract superclass for all members.
\&            Archive::Zip::StringMember      Member made from a string
\&            Archive::Zip::FileMember        Member made from an external file
\&                Archive::Zip::ZipFileMember Member that lives in a zip file
\&                Archive::Zip::NewFileMember Member whose data is in a file
\&            Archive::Zip::DirectoryMember   Member that is a directory
.Ve
.SH "ERROR CODES"
Many of the methods in Archive::Zip return error codes.
These are implemented as inline subroutines, using the \f(CWuse constant\fR pragma.
They can be imported into your namespace using the \f(CW:CONSTANT\fR
tag:
.PP
.Vb 3
\&    use Archive::Zip qw( :CONSTANTS );
\&    ...
\&    die "whoops!" if $zip->read( 'myfile.zip' ) != AZ_OK;
.Ve
.Ip "\s-1AZ_OK\s0 (0)" 4
Everything is fine.
.Ip "\s-1AZ_STREAM_END\s0 (1)" 4
The read stream (or central directory) ended normally.
.Ip "\s-1AZ_ERROR\s0 (2)" 4
There was some generic kind of error.
.Ip "\s-1AZ_FORMAT_ERROR\s0 (3)" 4
There is a format error in a \s-1ZIP\s0 file being read.
.Ip "\s-1AZ_IO_ERROR\s0 (4)" 4
There was an \s-1IO\s0 error.
.SH "COMPRESSION"
Archive::Zip allows each member of a ZIP file to be compressed (using
the Deflate algorithm) or uncompressed. Other compression algorithms
that some versions of ZIP have been able to produce are not supported.
.PP
Each member has two compression methods: the one it's stored as (this
is always COMPRESSION_STORED for string and external file members),
and the one you desire for the member in the zip file.
These can be different, of course, so you can make a zip member that
is not compressed out of one that is, and vice versa.
You can inquire about the current compression and set
the desired compression method:
.PP
.Vb 6
\&    my $member = $zip->memberNamed( 'xyz.txt' );
\&    $member->compressionMethod();    # return current compression
\&    # set to read uncompressed
\&    $member->desiredCompressionMethod( COMPRESSION_STORED );
\&    # set to read compressed
\&    $member->desiredCompressionMethod( COMPRESSION_DEFLATED );
.Ve
There are two different compression methods:
.Ip "\s-1COMPRESSION_STORED\s0" 4
file is stored (no compression)
.Ip "\s-1COMPRESSION_DEFLATED\s0" 4
file is Deflated
.Sh "Compression Levels"
If a member's desiredCompressionMethod is \s-1COMPRESSION_DEFLATED\s0,
you can choose different compression levels. This choice may
affect the speed of compression and decompression, as well as
the size of the compressed member data.
.PP
.Vb 1
\&    $member->desiredCompressionLevel( 9 );
.Ve
The levels given can be:
.Ip "0 or \s-1COMPRESSION_LEVEL_NONE\s0" 4
This is the same as saying
.Sp
.Vb 1
\&    $member->desiredCompressionMethod( COMPRESSION_STORED );
.Ve
.Ip "1 .. 9" 4
1 gives the best speed and worst compression, and 9 gives the best
compression and worst speed.
.Ip "\s-1COMPRESSION_LEVEL_FASTEST\s0" 4
This is a synonym for level 1.
.Ip "\s-1COMPRESSION_LEVEL_BEST_COMPRESSION\s0" 4
This is a synonym for level 9.
.Ip "\s-1COMPRESSION_LEVEL_DEFAULT\s0" 4
This gives a good compromise between speed and compression, and is
currently equivalent to 6 (this is in the zlib code).
.Sp
This is the level that will be used if not specified.
.SH "Archive::Zip methods"
The Archive::Zip class (and its invisible subclass Archive::Zip::Archive)
implement generic zip file functionality.
.PP
Creating a new Archive::Zip object actually makes an Archive::Zip::Archive
object, but you don't have to worry about this unless you're subclassing.
.Sh "Constructor"
.Ip "new( [$fileName] )" 4
Make a new, empty zip archive.
.Sp
.Vb 1
\&    my $zip = Archive::Zip->new();
.Ve
If an additional argument is passed, \fInew()\fR will call \fIread()\fR to read the
contents of an archive:
.Sp
.Vb 1
\&    my $zip = Archive::Zip->new( 'xyz.zip' );
.Ve
If a filename argument is passed and the read fails for any reason, new
will return undef. For this reason, it may be better to call read
separately.
.Sh "Utility Methods"
These Archive::Zip methods may be called as functions or as object
methods. Do not call them as class methods:
.PP
.Vb 3
\&    $zip = Archive::Zip->new();
\&    $crc = Archive::Zip::computeCRC32( 'ghijkl' );    # OK
\&    $crc = $zip->computeCRC32( 'ghijkl' );            # also OK
.Ve
.Vb 1
\&    $crc = Archive::Zip->computeCRC32( 'ghijkl' );    # NOT OK
.Ve
.Ip "Archive::Zip::computeCRC32( $string [, $crc] )" 4
This is a utility function that uses the Compress::Zlib \s-1CRC\s0
routine to compute a \s-1CRC\s0\-32.
.Sp
You can get the \s-1CRC\s0 of a string:
.Sp
.Vb 1
\&    $crc = Archive::Zip::computeCRC32( $string );
.Ve
Or you can compute the running \s-1CRC\s0:
.Sp
.Vb 3
\&    $crc = 0;
\&    $crc = Archive::Zip::computeCRC32( 'abcdef', $crc );
\&    $crc = Archive::Zip::computeCRC32( 'ghijkl', $crc );
.Ve
.Ip "Archive::Zip::setChunkSize( $number )" 4
Change chunk size used for reading and writing.
Currently, this defaults to 32K.
This is not exportable, so you must call it like:
.Sp
.Vb 1
\&    Archive::Zip::setChunkSize( 4096 );
.Ve
or as a method on a zip (though this is a global setting).
Returns old chunk size.
.Ip "Archive::Zip::setErrorHandler( \e&subroutine )" 4
Change the subroutine called with error strings.
This defaults to \e&Carp::carp, but you may want to change
it to get the error strings.
.Sp
This is not exportable, so you must call it like:
.Sp
.Vb 1
\&    Archive::Zip::setErrorHandler( \e&myErrorHandler );
.Ve
If no error handler is passed, resets handler to default.
.Sp
Returns old error handler.
.Sp
Note that if you call Carp::carp or a similar routine
or if you're chaining to the default error handler
from your error handler, you may want to increment the number
of caller levels that are skipped (do not just set it to a number):
.Sp
.Vb 1
\&    $Carp::CarpLevel++;
.Ve
.Sh "Accessors"
.Ip "members()" 4
Return a copy of my members array
.Sp
.Vb 1
\&    my @members = $zip->members();
.Ve
.Ip "numberOfMembers()" 4
Return the number of members I have
.Ip "memberNames()" 4
Return a list of the (internal) file names of my members
.Ip "memberNamed( $string )" 4
Return ref to member whose filename equals given filename or undef
.Ip "membersMatching( $regex )" 4
Return array of members whose filenames match given regular
expression in list context.
Returns number of matching members in scalar context.
.Sp
.Vb 3
\&    my @textFileMembers = $zip->membersMatching( '.*\e.txt' );
\&    # or
\&    my $numberOfTextFiles = $zip->membersMatching( '.*\e.txt' );
.Ve
.Ip "diskNumber()" 4
Return the disk that I start on.
Not used for writing zips, but might be interesting if you read a zip in.
This had better be 0, as Archive::Zip does not handle multi-volume archives.
.Ip "diskNumberWithStartOfCentralDirectory()" 4
Return the disk number that holds the beginning of the central directory.
Not used for writing zips, but might be interesting if you read a zip in.
This had better be 0, as Archive::Zip does not handle multi-volume archives.
.Ip "numberOfCentralDirectoriesOnThisDisk()" 4
Return the number of \s-1CD\s0 structures on this disk.
Not used for writing zips, but might be interesting if you read a zip in.
.Ip "numberOfCentralDirectories()" 4
Return the number of \s-1CD\s0 structures in the whole zip.
Not used for writing zips, but might be interesting if you read a zip in.
.Ip "centralDirectorySize()" 4
Returns central directory size, as read from an external zip file.
Not used for writing zips, but might be interesting if you read a zip in.
.Ip "centralDirectoryOffsetWRTStartingDiskNumber()" 4
Returns the offset into the zip file where the \s-1CD\s0 begins.
Not used for writing zips, but might be interesting if you read a zip in.
.Ip "zipfileComment( [$string] )" 4
Get or set the zipfile comment.
Returns the old comment.
.Sp
.Vb 2
\&    print $zip->zipfileComment();
\&    $zip->zipfileComment( 'New Comment' );
.Ve
.Sh "Member Operations"
Various operations on a zip file modify members.
When a member is passed as an argument, you can either use a reference
to the member itself, or the name of a member. Of course, using the
name requires that names be unique within a zip (this is not enforced).
.Ip "removeMember( $memberOrName )" 4
Remove and return the given member, or match its name and remove it.
Returns undef if member name doesn't exist in this Zip.
No-op if member does not belong to this zip.
.Ip "replaceMember( $memberOrName, $newMember )" 4
Remove and return the given member, or match its name and remove it.
Replace with new member.
Returns undef if member name doesn't exist in this Zip.
.Sp
.Vb 4
\&    my $member1 = $zip->removeMember( 'xyz' );
\&    my $member2 = $zip->replaceMember( 'abc', $member1 );
\&    # now, $member2 (named 'abc') is not in $zip,
\&    # and $member1 (named 'xyz') is, having taken $member2's place.
.Ve
.Ip "extractMember( $memberOrName )" 4
Extract the given member, or match its name and extract it.
Returns undef if member doesn't exist in this Zip.
If optional second arg is given, use it as the name of the
extracted member. Otherwise, the internal filename of the member is used
as the name of the extracted file or directory.
.Sp
All necessary directories will be created.
.Sp
Returns \f(CWAZ_OK\fR on success.
.Ip "extractMemberWithoutPaths( $memberOrName )" 4
Extract the given member, or match its name and extract it.
Does not use path information (extracts into the current directory).
Returns undef if member doesn't exist in this Zip.
If optional second arg is given, use it as the name of the
extracted member (its paths will be deleted too).
Otherwise, the internal filename of the member (minus paths) is used
as the name of the extracted file or directory.
.Sp
Returns \f(CWAZ_OK\fR on success.
.Ip "addMember( $member )" 4
Append a member (possibly from another zip file) to the zip file.
Returns the new member.
Generally, you will use \fIaddFile()\fR, \fIaddDirectory()\fR, \fIaddString()\fR, or \fIread()\fR
to add members.
.Sp
.Vb 3
\&    # Move member named 'abc' to end of zip:
\&    my $member = $zip->removeMember( 'abc' );
\&    $zip->addMember( $member );
.Ve
.Ip "addFile( $fileName )" 4
Append a member whose data comes from an external file,
returning the member or undef.
The member will have its file name set to the name of the external
file, and its desiredCompressionMethod set to \s-1COMPRESSION_DEFLATED\s0.
The file attributes and last modification time will be set from the file.
.Sp
If the name given does not represent a readable plain file or symbolic link,
undef will be returned.
.Sp
The text mode bit will be set if the contents appears to be text (as returned
by the \f(CW-T\fR perl operator).
.Ip "addString( $stringOrStringRef [, $name] )" 4
Append a member created from the given string or string reference.
The name is given by the optional second argument.
Returns the new member.
.Sp
The last modification time will be set to now,
and the file attributes will be set to permissive defaults.
.Sp
.Vb 1
\&    my $member = $zip->addString( 'This is a test', 'test.txt' );
.Ve
.Ip "addDirectory( $directoryName )" 4
Append a member created from the given directory name.
The directory name does not have to name an existing directory.
If the named directory exists, the file modification time and permissions
are set from the existing directory, otherwise they are set to now and
permissive default permissions.
.Sp
Returns the new member.
.Ip "contents( $memberOrMemberName [, $newContents ] )" 4
Returns the uncompressed data for a particular member, or undef.
.Sp
.Vb 1
\&    print "xyz.txt contains " . $zip->contents( 'xyz.txt' );
.Ve
Also can change the contents of a member:
.Sp
.Vb 1
\&    $zip->contents( 'xyz.txt', 'This is the new contents' );
.Ve
.Ip "writeToFileNamed( $fileName )" 4
Write a zip archive to named file.
Returns \f(CWAZ_OK\fR on success.
.Sp
.Vb 2
\&    my $status = $zip->writeToFileNamed( 'xx.zip' );
\&    die "error somewhere" if $status != AZ_OK;
.Ve
.Ip "writeToFileHandle( $fileHandle [, $seekable] )" 4
Write a zip archive to a file handle.
Return \s-1AZ_OK\s0 on success.
.Sp
The optional second arg tells whether or not to try to seek backwards
to re-write headers.
If not provided, it is set by testing seekability. This could fail
on some operating systems, though.
.Sp
.Vb 2
\&    my $fh = FileHandle->new( 'someFile.zip', 'w' );
\&    $zip->writeToFileHandle( $fh );
.Ve
If you pass a file handle that is not seekable (like if you're writing
to a pipe or a socket), pass a false as the second argument:
.Sp
.Vb 2
\&    my $fh = FileHandle->new( '| cat > somefile.zip', 'w' );
\&    $zip->writeToFileHandle( $fh, 0 );   # fh is not seekable
.Ve
.Ip "read( $fileName )" 4
Read zipfile headers from a zip file, appending new members.
Returns \f(CWAZ_OK\fR or error code.
.Sp
.Vb 2
\&    my $zipFile = Archive::Zip->new();
\&    my $status = $zipFile->read( '/some/FileName.zip' );
.Ve
.SH "MEMBER OPERATIONS"
.Sh "Class Methods"
Several constructors allow you to construct members without adding
them to a zip archive.
.PP
These work the same as the \fIaddFile()\fR, \fIaddDirectory()\fR, and \fIaddString()\fR
zip instance methods described above, but they don't add the new members
to a zip.
.Ip "Archive::Zip::Member->newFromString( $stringOrStringRef [, $fileName] )" 4
Construct a new member from the given string. Returns undef on error.
.Sp
.Vb 2
\&    my $member = Archive::Zip::Member->newFromString( 'This is a test',
\&                                                     'xyz.txt' );
.Ve
.Ip "newFromFile( $fileName )" 4
Construct a new member from the given file. Returns undef on error.
.Sp
.Vb 1
\&    my $member = Archive::Zip::Member->newFromFile( 'xyz.txt' );
.Ve
.Ip "newDirectoryNamed( $directoryName )" 4
Construct a new member from the given directory.
Returns undef on error.
.Sp
.Vb 1
\&    my $member = Archive::Zip::Member->newDirectoryNamed( 'CVS/' );
.Ve
.Sh "Simple accessors"
These methods get (and/or set) member attribute values.
.Ip "versionMadeBy()" 4
Gets the field from my member header.
.Ip "fileAttributeFormat( [$format] )" 4
Gets or sets the field from the member header.
These are \f(CWFA_*\fR values.
.Ip "versionNeededToExtract()" 4
Gets the field from my member header.
.Ip "bitFlag()" 4
Gets the general purpose bit field from my member header.
This is where the \f(CWGPBF_*\fR bits live.
.Ip "compressionMethod()" 4
Returns my compression method. This is the method that is
currently being used to compress my data.
.Sp
This will be \s-1COMPRESSION_STORED\s0 for added string or file members,
or any of the \f(CWCOMPRESSION_*\fR values for members from a zip file.
However, this module can only handle members whose data is in
\s-1COMPRESSION_STORED\s0 or \s-1COMPRESSION_DEFLATED\s0 format.
.Ip "desiredCompressionMethod( [$method] )" 4
Get or set my desiredCompressionMethod
This is the method that will be used to write.
Returns prior desiredCompressionMethod.
.Sp
Only \s-1COMPRESSION_DEFLATED\s0 or \s-1COMPRESSION_STORED\s0 are valid arguments.
.Sp
Changing to \s-1COMPRESSION_STORED\s0 will change my desiredCompressionLevel
to 0; changing to \s-1COMPRESSION_DEFLATED\s0 will change my
desiredCompressionLevel to \s-1COMPRESSION_LEVEL_DEFAULT\s0.
.Ip "desiredCompressionLevel( [$method] )" 4
Get or set my desiredCompressionLevel
This is the method that will be used to write.
Returns prior desiredCompressionLevel.
.Sp
Valid arguments are 0 through 9, \s-1COMPRESSION_LEVEL_NONE\s0,
\s-1COMPRESSION_LEVEL_DEFAULT\s0, \s-1COMPRESSION_LEVEL_BEST_COMPRESSION\s0, and
\s-1COMPRESSION_LEVEL_FASTEST\s0.
.Sp
0 or \s-1COMPRESSION_LEVEL_NONE\s0 will change the desiredCompressionMethod
to \s-1COMPRESSION_STORED\s0. All other arguments will change the
desiredCompressionMethod to \s-1COMPRESSION_DEFLATED\s0.
.Ip "fileName()" 4
Get or set my internal filename.
Returns the (possibly new) filename.
.Sp
Names will have backslashes converted to forward slashes,
and will have multiple consecutive slashes converted to single ones.
.Ip "lastModFileDateTime()" 4
Return my last modification date/time stamp in \s-1MS\s0\-\s-1DOS\s0 format.
.Ip "lastModTime()" 4
Return my last modification date/time stamp,
converted to unix localtime format.
.Sp
.Vb 1
\&    print "Mod Time: " . scalar( localtime( $member->lastModTime() ) );
.Ve
.Ip "setLastModFileDateTimeFromUnix()" 4
Set my lastModFileDateTime from the given unix time.
.Sp
.Vb 1
\&    $member->setLastModFileDateTimeFromUnix( time() );
.Ve
.Ip "internalFileAttributes()" 4
Return the internal file attributes field from the zip header.
This is only set for members read from a zip file.
.Ip "externalFileAttributes()" 4
Return member attributes as read from the \s-1ZIP\s0 file.
Note that these are \s-1NOT\s0 \s-1UNIX\s0!
.Ip "unixFileAttributes( [$newAttributes] )" 4
Get or set the member's file attributes using \s-1UNIX\s0 file attributes.
Returns old attributes.
.Sp
.Vb 1
\&    my $oldAttribs = $member->unixFileAttributes( 0666 );
.Ve
Note that the return value has more than just the file permissions,
so you will have to mask off the lowest bits for comparisions.
.Ip "localExtraField( [$newField] )" 4
Gets or sets the extra field that was read from the local header.
This is not set for a member from a zip file until after the
member has been written out.
.Sp
The extra field must be in the proper format.
.Ip "cdExtraField( [$newField] )" 4
Gets or sets the extra field that was read from the central directory header.
.Sp
The extra field must be in the proper format.
.Ip "extraFields()" 4
Return both local and \s-1CD\s0 extra fields, concatenated.
.Ip "fileComment( [$newComment] )" 4
Get or set the member's file comment.
.Ip "hasDataDescriptor()" 4
Get or set the data descriptor flag.
If this is set, the local header will not necessarily
have the correct data sizes. Instead, a small structure
will be stored at the end of the member data with these
values.
.Sp
This should be transparent in normal operation.
.Ip "crc32()" 4
Return the \s-1CRC\s0\-32 value for this member.
This will not be set for members that were constructed from strings
or external files until after the member has been written.
.Ip "crc32String()" 4
Return the \s-1CRC\s0\-32 value for this member as an 8 character printable
hex string.  This will not be set for members that were constructed
from strings or external files until after the member has been written.
.Ip "compressedSize()" 4
Return the compressed size for this member.
This will not be set for members that were constructed from strings
or external files until after the member has been written.
.Ip "uncompressedSize()" 4
Return the uncompressed size for this member.
.Ip "isEncrypted()" 4
Return true if this member is encrypted.
The Archive::Zip module does not currently create or extract
encrypted members.
.Ip "isTextFile( [$flag] )" 4
Returns true if I am a text file.
Also can set the status if given an argument (then returns old state).
Note that this module does not currently do anything with this flag
upon extraction or storage.
That is, bytes are stored in native format whether or not they came
from a text file.
.Ip "isBinaryFile()" 4
Returns true if I am a binary file.
Also can set the status if given an argument (then returns old state).
Note that this module does not currently do anything with this flag
upon extraction or storage.
That is, bytes are stored in native format whether or not they came
from a text file.
.Ip "extractToFileNamed( $fileName )" 4
Extract me to a file with the given name.
The file will be created with default modes.
Directories will be created as needed.
.Sp
Returns \s-1AZ_OK\s0 on success.
.Ip "isDirectory()" 4
Returns true if I am a directory.
.Sh "Low-level member data reading"
It is possible to use lower-level routines to access member
data streams, rather than the extract* methods and \fIcontents()\fR.
.PP
For instance, here is how to print the uncompressed contents
of a member in chunks using these methods:
.PP
.Vb 13
\&    my ( $member, $status, $bufferRef );
\&    $member = $zip->memberNamed( 'xyz.txt' );
\&    $member->desiredCompressionMethod( COMPRESSION_STORED );
\&    $status = $member->rewindData();
\&    die "error $status" if $status != AZ_OK;
\&    while ( ! $member->readIsDone() )
\&    {
\&        ( $bufferRef, $status ) = $member->readChunk();
\&        die "error $status" if $status != AZ_OK;
\&        # do something with $bufferRef:
\&        print $$bufferRef;
\&    }
\&    $member->endRead();
.Ve
.Ip "readChunk( [$chunkSize] )" 4
This reads the next chunk of given size from the member's data stream and
compresses or uncompresses it as necessary, returning a reference to the bytes
read and a status.
If size argument is not given, defaults to global set by
Archive::Zip::setChunkSize.
Status is \s-1AZ_OK\s0 on success. Returns \f(CW( \e$bytes, $status)\fR.
.Sp
.Vb 2
\&    my ( $outRef, $status ) = $self->readChunk();
\&    print $$outRef if $status != AZ_OK;
.Ve
.Ip "rewindData()" 4
Rewind data and set up for reading data streams or writing zip files.
Can take options for \f(CWinflateInit()\fR or \f(CWdeflateInit()\fR,
but this isn't likely to be necessary.
Subclass overrides should call this method.
Returns \f(CWAZ_OK\fR on success.
.Ip "endRead()" 4
Reset the read variables and free the inflater or deflater.
Must be called to close files, etc.
.Sp
Returns \s-1AZ_OK\s0 on success.
.Ip "readIsDone()" 4
Return true if the read has run out of data or errored out.
.Ip "contents()" 4
Return the entire uncompressed member data or undef in scalar context.
When called in array context, returns \f(CW( $string, $status )\fR; status
will be \s-1AZ_OK\s0 on success:
.Sp
.Vb 4
\&    my $string = $member->contents();
\&    # or
\&    my ( $string, $status ) = $member->contents();
\&    die "error $status" if $status != AZ_OK;
.Ve
Can also be used to set the contents of a member (this may change
the class of the member):
.Sp
.Vb 1
\&    $member->contents( "this is my new contents" );
.Ve
.Ip "extractToFileHandle( $fh )" 4
Extract (and uncompress, if necessary) my contents to the given file handle.
Return \s-1AZ_OK\s0 on success.
.SH "Archive::Zip::FileMember methods"
The Archive::Zip::FileMember class extends Archive::Zip::Member.
It is the base class for both ZipFileMember and NewFileMember classes.
This class adds an \f(CWexternalFileName\fR and an \f(CWfh\fR member to keep
track of the external file.
.Ip "externalFileName()" 4
Return my external filename.
.Ip "fh()" 4
Return my read file handle.
Automatically opens file if necessary.
.SH "Archive::Zip::ZipFileMember methods"
The Archive::Zip::ZipFileMember class represents members that have
been read from external zip files.
.Ip "diskNumberStart()" 4
Returns the disk number that my local header resides
in. Had better be 0.
.Ip "localHeaderRelativeOffset()" 4
Returns the offset into the zip file where my local header is.
.Ip "dataOffset()" 4
Returns the offset from the beginning of the zip file to
my data.
.SH "AUTHOR"
Ned Konz, perl@bike-nomad.com
.SH "COPYRIGHT"
Copyright (c) 2000 Ned Konz. All rights reserved.  This program is free
software; you can redistribute it and/or modify it under the same terms
as Perl itself.
.SH "SEE ALSO"
the \fICompress::Zlib\fR manpage

.rn }` ''
.IX Title "lib::Archive::Zip 3"
.IX Name "Archive::Zip - Provide an interface to ZIP archive files."

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Header "EXPORTS"

.IX Item ":\s-1CONSTANTS\s0"

.IX Item ":\s-1MISC_CONSTANTS\s0"

.IX Item ":\s-1ERROR_CODES\s0"

.IX Header "OBJECT MODEL"

.IX Subsection "Inheritance"

.IX Header "ERROR CODES"

.IX Item "\s-1AZ_OK\s0 (0)"

.IX Item "\s-1AZ_STREAM_END\s0 (1)"

.IX Item "\s-1AZ_ERROR\s0 (2)"

.IX Item "\s-1AZ_FORMAT_ERROR\s0 (3)"

.IX Item "\s-1AZ_IO_ERROR\s0 (4)"

.IX Header "COMPRESSION"

.IX Item "\s-1COMPRESSION_STORED\s0"

.IX Item "\s-1COMPRESSION_DEFLATED\s0"

.IX Subsection "Compression Levels"

.IX Item "0 or \s-1COMPRESSION_LEVEL_NONE\s0"

.IX Item "1 .. 9"

.IX Item "\s-1COMPRESSION_LEVEL_FASTEST\s0"

.IX Item "\s-1COMPRESSION_LEVEL_BEST_COMPRESSION\s0"

.IX Item "\s-1COMPRESSION_LEVEL_DEFAULT\s0"

.IX Header "Archive::Zip methods"

.IX Subsection "Constructor"

.IX Item "new( [$fileName] )"

.IX Subsection "Utility Methods"

.IX Item "Archive::Zip::computeCRC32( $string [, $crc] )"

.IX Item "Archive::Zip::setChunkSize( $number )"

.IX Item "Archive::Zip::setErrorHandler( \e&subroutine )"

.IX Subsection "Accessors"

.IX Item "members()"

.IX Item "numberOfMembers()"

.IX Item "memberNames()"

.IX Item "memberNamed( $string )"

.IX Item "membersMatching( $regex )"

.IX Item "diskNumber()"

.IX Item "diskNumberWithStartOfCentralDirectory()"

.IX Item "numberOfCentralDirectoriesOnThisDisk()"

.IX Item "numberOfCentralDirectories()"

.IX Item "centralDirectorySize()"

.IX Item "centralDirectoryOffsetWRTStartingDiskNumber()"

.IX Item "zipfileComment( [$string] )"

.IX Subsection "Member Operations"

.IX Item "removeMember( $memberOrName )"

.IX Item "replaceMember( $memberOrName, $newMember )"

.IX Item "extractMember( $memberOrName )"

.IX Item "extractMemberWithoutPaths( $memberOrName )"

.IX Item "addMember( $member )"

.IX Item "addFile( $fileName )"

.IX Item "addString( $stringOrStringRef [, $name] )"

.IX Item "addDirectory( $directoryName )"

.IX Item "contents( $memberOrMemberName [, $newContents ] )"

.IX Item "writeToFileNamed( $fileName )"

.IX Item "writeToFileHandle( $fileHandle [, $seekable] )"

.IX Item "read( $fileName )"

.IX Header "MEMBER OPERATIONS"

.IX Subsection "Class Methods"

.IX Item "Archive::Zip::Member->newFromString( $stringOrStringRef [, $fileName] )"

.IX Item "newFromFile( $fileName )"

.IX Item "newDirectoryNamed( $directoryName )"

.IX Subsection "Simple accessors"

.IX Item "versionMadeBy()"

.IX Item "fileAttributeFormat( [$format] )"

.IX Item "versionNeededToExtract()"

.IX Item "bitFlag()"

.IX Item "compressionMethod()"

.IX Item "desiredCompressionMethod( [$method] )"

.IX Item "desiredCompressionLevel( [$method] )"

.IX Item "fileName()"

.IX Item "lastModFileDateTime()"

.IX Item "lastModTime()"

.IX Item "setLastModFileDateTimeFromUnix()"

.IX Item "internalFileAttributes()"

.IX Item "externalFileAttributes()"

.IX Item "unixFileAttributes( [$newAttributes] )"

.IX Item "localExtraField( [$newField] )"

.IX Item "cdExtraField( [$newField] )"

.IX Item "extraFields()"

.IX Item "fileComment( [$newComment] )"

.IX Item "hasDataDescriptor()"

.IX Item "crc32()"

.IX Item "crc32String()"

.IX Item "compressedSize()"

.IX Item "uncompressedSize()"

.IX Item "isEncrypted()"

.IX Item "isTextFile( [$flag] )"

.IX Item "isBinaryFile()"

.IX Item "extractToFileNamed( $fileName )"

.IX Item "isDirectory()"

.IX Subsection "Low-level member data reading"

.IX Item "readChunk( [$chunkSize] )"

.IX Item "rewindData()"

.IX Item "endRead()"

.IX Item "readIsDone()"

.IX Item "contents()"

.IX Item "extractToFileHandle( $fh )"

.IX Header "Archive::Zip::FileMember methods"

.IX Item "externalFileName()"

.IX Item "fh()"

.IX Header "Archive::Zip::ZipFileMember methods"

.IX Item "diskNumberStart()"

.IX Item "localHeaderRelativeOffset()"

.IX Item "dataOffset()"

.IX Header "AUTHOR"

.IX Header "COPYRIGHT"

.IX Header "SEE ALSO"

