.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH Heap 3 "perl 5.005, patch 03" "20/Apr/2000" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
Heap \- Perl extensions for keeping data partially sorted
.SH "SYNOPSIS"
.PP
.Vb 1
\&  use Heap;
.Ve
.Vb 2
\&  my $heap = Heap->new;
\&  my $elem;
.Ve
.Vb 1
\&  use Heap::Elem::Num(NumElem);
.Ve
.Vb 4
\&  foreach $i ( 1..100 ) {
\&      $elem = NumElem( $i );
\&      $heap->add( $elem );
\&  }
.Ve
.Vb 3
\&  while( defined( $elem = $heap->extract_maximum ) ) {
\&      print "Smallest is ", $elem->val, "\en";
\&  }
.Ve
.SH "DESCRIPTION"
The Heap collection of modules provide routines that manage
a heap of elements.  A heap is a partially sorted structure
that is always able to easily extract the smallest of the
elements in the structure (or the largest if a reversed compare
routine is provided).
.PP
If the collection of elements is changing dynamically, the
heap has less overhead than keeping the collection fully
sorted.
.PP
The elements must be objects as described in the section on \fIHeap::Elem\fR
and all elements inserted into one heap must be mutually
compatible \- either the same class exactly or else classes that
differ only in ways unrelated to the \fBHeap::Elem\fR interface.
.SH "METHODS"
.Ip "$heap = HeapClass::new(); $heap2 = $heap1->new();" 4
Returns a new heap object of the specified (sub-)class.
This is often used as a subroutine instead of a method,
of course.
.Ip "$heap->\s-1DESTROY\s0" 4
Ensures that no internal circular data references remain.
Some variants of Heap ignore this (they have no such references).
Heap users normally need not worry about it, \s-1DESTROY\s0 is automatically
invoked when the heap reference goes out of scope.
.Ip "$heap->add($elem)" 4
Add an element to the heap.
.Ip "$elem = $heap->minimum" 4
Return the top element on the heap.  It is \fBnot\fR removed from
the heap but will remain at the top.  It will be the smallest
element on the heap (unless a reversed cmp function is being
used, in which case it will be the largest).  Returns \fIundef\fR
if the heap is empty.
.Ip "$elem = $heap->extract_minimum" 4
Delete the top element from the heap and return it.  Returns
\fIundef\fR if the heap was empty.
.Ip "$heap1->absorb($heap2)" 4
Merge all of the elements from \fI$heap2\fR into \fI$heap1\fR.
This will leave \fI$heap2\fR empty.
.Ip "$heap1->decrease_key($elem)" 4
The element will be moved closed to the top of the
heap if it is now smaller than any higher parent elements.
The user must have changed the value of \fI$elem\fR before
\fIdecrease_key\fR is called.  Only a decrease is permitted.
(This is a decrease according to the \fIcmp\fR function \- if it
is a reversed order comparison, then you are only permitted
to increase the value of the element.  To be pedantic, you
may only use \fIdecrease_key\fR if
\fI$elem-\fR\fIcmp\fR\|($elem_original) <= 0> if \fI$elem_original\fR were
an elem with the value that \fI$elem\fR had before it was
\fIdecreased\fR.)
.Ip "$elem = $heap->delete($elem)" 4
The element is removed from the heap (whether it is at
the top or not).
.SH "AUTHOR"
John Macdonald, jmm@elegant.com
.SH "COPYRIGHT"
Copyright 1998, O'Reilly & Associates.
.PP
This code is distributed under the same copyright terms as perl
itself.
.SH "SEE ALSO"
\fIHeap::Elem\fR\|(3), \fIHeap::Binary\fR\|(3), \fIHeap::Binomial\fR\|(3), \fIHeap::Fibonacci\fR\|(3).

.rn }` ''
.IX Title "Heap 3"
.IX Name "Heap - Perl extensions for keeping data partially sorted"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Header "METHODS"

.IX Item "$heap = HeapClass::new(); $heap2 = $heap1->new();"

.IX Item "$heap->\s-1DESTROY\s0"

.IX Item "$heap->add($elem)"

.IX Item "$elem = $heap->minimum"

.IX Item "$elem = $heap->extract_minimum"

.IX Item "$heap1->absorb($heap2)"

.IX Item "$heap1->decrease_key($elem)"

.IX Item "$elem = $heap->delete($elem)"

.IX Header "AUTHOR"

.IX Header "COPYRIGHT"

.IX Header "SEE ALSO"

