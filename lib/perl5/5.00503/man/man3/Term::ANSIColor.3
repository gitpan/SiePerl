.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH ANSIColor 3 "perl 5.005, patch 03" "10/Dec/1997" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
Term::ANSIColor \- Color screen output using ANSI escape sequences
.SH "SYNOPSIS"
.PP
.Vb 7
\&    use Term::ANSIColor;
\&    print color 'bold blue';
\&    print "This text is bold blue.\en";
\&    print color 'reset';
\&    print "This text is normal.\en";
\&    print colored ("Yellow on magenta.\en", 'yellow on_magenta');
\&    print "This text is normal.\en";
.Ve
.Vb 2
\&    use Term::ANSIColor qw(:constants);
\&    print BOLD, BLUE, "This text is in bold blue.\en", RESET;
.Ve
.Vb 4
\&    use Term::ANSIColor qw(:constants);
\&    $Term::ANSIColor::AUTORESET = 1;
\&    print BOLD BLUE "This text is in bold blue.\en";
\&    print "This text is normal.\en";
.Ve
.SH "DESCRIPTION"
This module has two interfaces, one through \fIcolor()\fR and \fIcolored()\fR and the
other through constants.
    
\fIcolor()\fR takes any number of strings as arguments and considers them to be
space-separated lists of attributes.  It then forms and returns the escape
sequence to set those attributes.  It doesn't print it out, just returns
it, so you'll have to print it yourself if you want to (this is so that
you can save it as a string, pass it to something else, send it to a file
handle, or do anything else with it that you might care to).
.PP
The recognized attributes (all of which should be fairly intuitive) are
clear, reset, bold, underline, underscore, blink, reverse, concealed,
black, red, green, yellow, blue, magenta, on_black, on_red, on_green,
on_yellow, on_blue, on_magenta, on_cyan, and on_white.  Case is not
significant.  Underline and underscore are equivalent, as are clear and
reset, so use whichever is the most intuitive to you.  The color alone
sets the foreground color, and on_color sets the background color.
.PP
Note that attributes, once set, last until they are unset (by sending the
attribute \*(L"reset").  Be careful to do this, or otherwise your attribute will
last after your script is done running, and people get very annoyed at
having their prompt and typing changed to weird colors.
.PP
As an aid to help with this, \fIcolored()\fR takes a scalar as the first
argument and any number of attribute strings as the second argument and
returns the scalar wrapped in escape codes so that the attributes will be
set as requested before the string and reset to normal after the string.
Normally, \fIcolored()\fR just puts attribute codes at the beginning and end of
the string, but if you set \f(CW$Term::ANSIColor::EACHLINE\fR to some string,
that string will be considered the line delimiter and the attribute will
be set at the beginning of each line of the passed string and reset at the
end of each line.  This is often desirable if the output is being sent to
a program like a pager that can be confused by attributes that span lines.
Normally you'll want to set \f(CW$Term::ANSIColor::EACHLINE\fR to \f(CW"\en"\fR to use
this feature.
.PP
Alternately, if you import \f(CW:constants\fR, you can use the constants CLEAR,
RESET, BOLD, UNDERLINE, UNDERSCORE, BLINK, REVERSE, CONCEALED, BLACK, RED,
GREEN, YELLOW, BLUE, MAGENTA, ON_BLACK, ON_RED, ON_GREEN, ON_YELLOW,
ON_BLUE, ON_MAGENTA, ON_CYAN, and ON_WHITE directly.  These are the same
as \fIcolor\fR\|('attribute') and can be used if you prefer typing:
.PP
.Vb 1
\&    print BOLD BLUE ON_WHITE "Text\en", RESET;
.Ve
to
.PP
.Vb 1
\&    print colored ("Text\en", 'bold blue on_white');
.Ve
When using the constants, if you don't want to have to remember to add the
\f(CW, RESET\fR at the end of each print line, you can set
\f(CW$Term::ANSIColor::AUTORESET\fR to a true value.  Then, the display mode will
automatically be reset if there is no comma after the constant.  In other
words, with that variable set:
.PP
.Vb 1
\&    print BOLD BLUE "Text\en";
.Ve
will reset the display mode afterwards, whereas:
.PP
.Vb 1
\&    print BOLD, BLUE, "Text\en";
.Ve
will not.
.PP
The subroutine interface has the advantage over the constants interface in
that only 2 soubrutines are exported into your namespace, verses 22 in the
constants interface.  On the flip side, the constants interface has the
advantage of better compile time error checking, since misspelled names of
colors or attributes in calls to \fIcolor()\fR and \fIcolored()\fR won't be caught
until runtime whereas misspelled names of constants will be caught at
compile time.  So, polute your namespace with almost two dozen subrutines
that you may not even use that oftin, or risk a silly bug by mistyping an
attribute.  Your choice, TMTOWTDI after all.
.SH "DIAGNOSTICS"
.Ip "Invalid attribute name %s" 4
You passed an invalid attribute name to either \fIcolor()\fR or \fIcolored()\fR.
.Ip "Identifier %s used only once: possible typo" 4
You probably mistyped a constant color name such as:
.Sp
.Vb 1
\&    print FOOBAR "This text is color FOOBAR\en";
.Ve
It's probably better to always use commas after constant names in order to
force the next error.
.Ip "No comma allowed after filehandle" 4
You probably mistyped a constant color name such as:
.Sp
.Vb 1
\&    print FOOBAR, "This text is color FOOBAR\en";
.Ve
Generating this fatal compile error is one of the main advantages of using
the constants interface, since you'll immediately know if you mistype a
color name.
.Ip "Bareword %s not allowed while \*(N"strict subs\*(T" in use" 4
You probably mistyped a constant color name such as:
.Sp
.Vb 1
\&    $Foobar = FOOBAR . "This line should be blue\en";
.Ve
or:
.Sp
.Vb 1
\&    @Foobar = FOOBAR, "This line should be blue\en";
.Ve
This will only show up under use strict (another good reason to run under
use strict).
.SH "RESTRICTIONS"
It would be nice if one could leave off the commas around the constants
entirely and just say:
.PP
.Vb 1
\&    print BOLD BLUE ON_WHITE "Text\en" RESET;
.Ve
but the syntax of Perl doesn't allow this.  You need a comma after the
string.  (Of course, you may consider it a bug that commas between all the
constants aren't required, in which case you may feel free to insert
commas unless you're using \f(CW$Term::ANSIColor::AUTORESET\fR.)
.PP
For easier debuging, you may prefer to always use the commas when not
setting \f(CW$Term::ANSIColor::AUTORESET\fR so that you'll get a fatal compile
error rather than a warning.
.SH "AUTHORS"
Original idea (using constants) by Zenin (zenin@best.com), reimplemented
using subs by Russ Allbery (rra@stanford.edu), and then combined with the
original idea by Russ with input from Zenin.

.rn }` ''
.IX Title "ANSIColor 3"
.IX Name "Term::ANSIColor - Color screen output using ANSI escape sequences"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Header "DIAGNOSTICS"

.IX Item "Invalid attribute name %s"

.IX Item "Identifier %s used only once: possible typo"

.IX Item "No comma allowed after filehandle"

.IX Item "Bareword %s not allowed while \*(N"strict subs\*(T" in use"

.IX Header "RESTRICTIONS"

.IX Header "AUTHORS"

