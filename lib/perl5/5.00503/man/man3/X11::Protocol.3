.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH Protocol 3 "perl 5.005, patch 03" "14/Jan/1998" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
X11::Protocol \- Perl module for the X Window System Protocol, version 11
.SH "SYNOPSIS"
.PP
.Vb 8
\&  use X11::Protocol;
\&  $x = X11::Protocol->new();
\&  $win = $x->new_rsrc;
\&  $x->CreateWindow($win, $x->root, 'InputOutput',
\&                   $x->root_depth, 'CopyFromParent',
\&                   ($x_coord, $y_coord), $width,
\&                   $height, $border_w);  
\&  ...
.Ve
.SH "DESCRIPTION"
X11::Protocol is a client-side interface to the X11 Protocol (see \fIX\fR\|(1) for
information about X11), allowing perl programs to display windows and
graphics on X11 servers.
.PP
A full description of the protocol is beyond the scope of this documentation;
for complete information, see the \fIX Window System Protocol, X Version 11\fR,
available as Postscript or *roff source from \f(CWftp://ftp.x.org\fR, or
\fIVolume 0: X Protocol Reference Manual\fR of O'Reilly & Associates's series of
books about X (ISBN 1-56592-083-X, \f(CWhttp://www.oreilly.com\fR), which contains
most of the same information.
.SH "DISCLAIMER"
``The protocol contains many management mechanisms that are
not intended for normal applications.  Not all mechanisms
are needed to build a particular user interface.  It is
important to keep in mind that the protocol is intended to
provide mechanism, not policy.'\*(R' -- Robert W. Scheifler
.SH "BASIC METHODS"
.Sh "new"
.PP
.Vb 5
\&  $x = X11::Protocol->new();
\&  $x = X11::Protocol->new($display_name);
\&  $x = X11::Protocol->new($connection);
\&  $x = X11::Protocol->new($display_name, [$auth_type, $auth_data]);
\&  $x = X11::Protocol->new($connection, [$auth_type, $auth_data]);
.Ve
Open a connection to a server. \f(CW$display_name\fR should be an X display
name, of the form \*(L'host:display_num.screen_num\*(R'; if no arguments are
supplied, the contents of the \s-1DISPLAY\s0 environment variable are
used. Alternatively, a pre-opened connection, of one of the
X11::Protocol::Connection classes (see
the \fIX11::Protocol::Connection\fR manpage,
the \fIX11::Protocol::Connection::FileHandle\fR manpage,
the \fIX11::Protocol::Connection::Socket\fR manpage,
the \fIX11::Protocol::Connection::\s-1UNIXFH\s0\fR manpage,
the \fIX11::Protocol::Connection::\s-1INETFH\s0\fR manpage,
the \fIX11::Protocol::Connection::UNIXSocket\fR manpage,
the \fIX11::Protocol::Connection::INETSocket\fR manpage) can be given. The
authorization data is obtained using X11::Auth or the second
argument. If the display is specified by \f(CW$display_name\fR, rather than
\f(CW$connection\fR, a \fIchoose_screen()\fR is also performed, defaulting to screen
0 if the \*(L'.screen_num\*(R' of the display name is not present.  Returns
the new protocol object.
.Sh "new_rsrc"
.PP
.Vb 1
\&  $x->new_rsrc;
.Ve
Returns a new resource identifier. A unique resource \s-1ID\s0 is required for every
object that the server creates on behalf of the client: windows, fonts,
cursors, etc. (IDs are chosen by the client instead of the server for
efficiency -- the client doesn't have to wait for the server to acknowledge
the creation before starting to use the object).
.Sh "handle_input"
.PP
.Vb 1
\&  $x->handle_input;
.Ve
Get one chunk of information from the server, and do something with it. If it's
an error, handle it using the protocol object's handler ('error_handler\*(R'
-- default is kill the program with an explanatory message). If it's an event,
pass it to the chosen event handler, or put it in a queue if the handler is
\&'queue\*(R'. If it's a reply to a request, save using the object's \*(L'replies\*(R' hash
for further processing.
.Sh "atom_name"
.PP
.Vb 1
\&  $name = $x->atom_name($atom);
.Ve
Return the string corresponding to the atom \f(CW$atom\fR. This is similar to the
GetAtomName request, but caches the result for efficiency.
.Sh "atom"
.PP
.Vb 1
\&  $atom = $x->atom($name);
.Ve
The inverse operation; Return the (numeric) atom correspoding to \f(CW$name\fR.
This is similar to the InternAtom request, but caches the result.
.Sh "choose_screen"
.PP
.Vb 1
\&  $x->choose_screen($screen_num);
.Ve
Indicate that you prefer to use a particular screen of the display. Per-screen
information, such as \*(L'root\*(R', \*(L'width_in_pixels\*(R', and \*(L'white_pixel\*(R' will be
made avaliable as 
.PP
.Vb 1
\&  $x->{'root'}
.Ve
instead of
.PP
.Vb 1
\&  $x->{'screens'}[$screen_num]{'root'}
.Ve
.SH "SYMBOLIC CONSTANTS"
Generally, symbolic constants used by the protocol, like \*(L'CopyFromParent\*(R'
or \*(L'PieSlice\*(R' are passed to methods as strings, and
converted into numbers by the module.  Their names are the same as
those in the protocol specification, including capitalization, but
with hyphens (\*(R'\-') changed to underscores ('_') to look more
perl-ish. If you want to do the conversion yourself for some reason,
the following methods are avaliable:
.Sh "num"
.PP
.Vb 1
\&  $num = $x->num($type, $str)
.Ve
Given a string representing a constant and a string specifying what
type of constant it is, return the corresponding number. \f(CW$type\fR should
be a name like \*(L'VisualClass\*(R' or \*(L'GCLineStyle\*(R'. If the name is not
recognized, it is returned intact.
.Sh "interp"
.PP
.Vb 1
\&  $name = $x->interp($type, $num)
.Ve
The inverse operation; given a number and string specifying its type, return
a string representing the constant.
.PP
You can disable \fIinterp()\fR and the module's internal interpretation of
numbers by setting \f(CW$x\fR\->{'do_interp'} to zero. Of course, this isn't
very useful, unless you have you own definitions for all the
constants.
.PP
Here is a list of available constant types:
.PP
.Vb 12
\&  AccessMode, AllowEventsMode, AutoRepeatMode, BackingStore,
\&  BitGravity, Bool, ChangePropertyMode, CirculateDirection,
\&  CirculatePlace, Class, ClipRectangleOrdering, CloseDownMode,
\&  ColormapNotifyState, CoordinateMode, CrossingNotifyDetail,
\&  CrossingNotifyMode, DeviceEvent, DrawDirection, Error, EventMask,
\&  Events, FocusDetail, FocusMode, GCArcMode, GCCapStyle, GCFillRule,
\&  GCFillStyle, GCFunction, GCJoinStyle, GCLineStyle, GCSubwindowMode,
\&  GrabStatus, HostChangeMode, HostFamily, ImageFormat,
\&  InputFocusRevertTo, KeyMask, LedMode, MapState, MappingChangeStatus,
\&  MappingNotifyRequest, PointerEvent, PolyShape, PropertyNotifyState,
\&  Request, ScreenSaver, ScreenSaverAction, Significance, SizeClass,
\&  StackMode, SyncMode, VisibilityState, VisualClass, WinGravity
.Ve
.SH "SERVER INFORMATION"
At connection time, the server sends a large amount of information about
itself to the client. This information is stored in the protocol object
for future reference. It can be read directly, like
.PP
.Vb 1
\&  $x->{'release_number'}
.Ve
or, for object oriented True Believers, using a method:
.PP
.Vb 1
\&  $x->release_number
.Ve
The method method also has a one argument form for setting variables, but
it isn't really useful for some of the more complex structures.
.PP
Here is an example of what the object's information might look like:
.PP
.Vb 57
\&  'connection' => X11::Connection::UNIXSocket(0x814526fd),
\&  'byte_order' => 'l',
\&  'protocol_major_version' => 11,
\&  'protocol_minor_version' => 0,
\&  'authorization_protocol_name' => 'MIT-MAGIC-COOKIE-1',
\&  'release_number' => 3110,
\&  'resource_id_base' => 0x1c000002,
\&  'motion_buffer_size' => 0,
\&  'maximum_request_length' => 65535, # units of 4 bytes
\&  'image_byte_order' => 'LeastSiginificant',
\&  'bitmap_bit_order' => 'LeastSiginificant',
\&  'bitmap_scanline_unit' => 32,
\&  'bitmap_scanline_pad' => 32,
\&  'min_keycode' => 8,
\&  'max_keycode' => 134,
\&  'vendor' => 'The XFree86 Project, Inc',
\&  'pixmap_formats' => {1 => {'bits_per_pixel' => 1,
\&                             'scanline_pad' => 32},
\&                       8 => {'bits_per_pixel' => 8,
\&                             'scanline_pad' => 32}},
\&  'screens' => [{'root' => 43, 'width_in_pixels' => 800,
\&                 'height_in_pixels' => 600,
\&                 'width_in_millimeters' => 271,
\&                 'height_in_millmerters' => 203,
\&                 'root_depth' => 8,
\&                 'root_visual' => 34,
\&                 'default_colormap' => 33,
\&                 'white_pixel' => 0, 'black_pixel' => 1,
\&                 'min_installed_maps' => 1,
\&                 'max_installed_maps' => 1,
\&                 'backing_stores' => 'Always',
\&                 'save_unders' => 1,
\&                 'current_input_masks' => 0x58003d,
\&                 'allowed_depths' =>
\&                    [{'depth' => 1, 'visuals' => []},
\&                     {'depth' => 8, 'visuals' => [
\&                        {'visual_id' => 34, 'blue_mask' => 0,
\&                         'green_mask' => 0, 'red_mask' => 0, 
\&                         'class' => 'PseudoColor',
\&                         'bits_per_rgb_value' => 6,
\&                         'colormap_entries' => 256},
\&                        {'visual_id' => 35, 'blue_mask' => 0xc0,
\&                         'green_mask' => 0x38, 'red_mask' => 0x7, 
\&                         'class' => 'DirectColor',
\&                         'bits_per_rgb_value' => 6,
\&                         'colormap_entries' => 8}, ...]}]],
\&  'visuals' => {34 => {'depth' => 8, 'class' => 'PseudoColor',
\&                       'red_mask' => 0, 'green_mask' => 0,
\&                       'blue_mask'=> 0, 'bits_per_rgb_value' => 6,
\&                       'colormap_entries' => 256},
\&                35 => {'depth' => 8, 'class' => 'DirectColor',
\&                       'red_mask' => 0x7, 'green_mask' => 0x38,
\&                       'blue_mask'=> 0xc0, 'bits_per_rgb_value' => 6,
\&                       'colormap_entries' => 8}, ...}
\&  'error_handler' => &\eX11::Protocol::default_error_handler,
\&  'event_handler' => sub {},
\&  'do_interp' => 1
.Ve
.SH "REQUESTS"
.Sh "request"
.PP
.Vb 3
\&  $x->request('CreateWindow', ...);
\&  $x->req('CreateWindow', ...);
\&  $x->CreateWindow(...);
.Ve
Send a protocol request to the server, and get the reply. For names of and 
information about individual requests, see below and/or
the protocol reference manual.
.Sh "add_reply"
.PP
.Vb 1
\&  $x->add_reply($sequence_num, \e$var);
.Ve
Add a stub for an expected reply to the object's \*(L'replies\*(R' hash. When a reply
numbered \f(CW$sequence_num\fR comes, it will be stored in \f(CW$var\fR.
.Sh "delete_reply"
.PP
.Vb 1
\&  $x->delete_reply($sequence_num);
.Ve
Delete the entry in \*(L'replies\*(R' for the specified reply. (This should be done
after the reply is recieved).
.Sh "send"
.PP
.Vb 1
\&  $x->send('CreateWindow', ...);
.Ve
Send a request, but do not wait for a reply. You must handle the reply, if any,
yourself, using \fIadd_reply()\fR, \fIhandle_input()\fR, \fIdelete_reply()\fR, and
\fIunpack_reply()\fR, generally in that order. 
.Sh "unpack_reply"
.PP
.Vb 1
\&  $x->unpack_reply('GetWindowAttributes', $data);
.Ve
Interpret the raw reply data \f(CW$data\fR, according to the reply format for the named
request. Returns data in the same format as \f(CWrequest($request_name, ...)\fR.
.PP
This section includes only a short calling summary for each request; for
full descriptions, see the protocol standard. Argument order is usually the
same as listed in the spec, but you generally don't have to pass lengths of
strings or arrays, since perl keeps track. Symbolic constants are generally
passed as strings. Most replies are returned as lists, but when there are
many values, a hash is used. Lists usually come last; when there is more than
one, each is passed by reference. In lists of multi-part structures, each
element is a list ref. Parenthesis are inserted in arg lists for clarity,
but are optional. Requests are listed in order by major opcode, so related
requests are usually close together. Replies follow the \*(L'=>\*(R'.
.PP
.Vb 3
\&  $x->CreateWindow($wid, $parent, $class, $depth, $visual, ($x, $y),
\&                   $width, $height, $border_width,
\&                   'attribute' => $value, ...)
.Ve
.Vb 1
\&  $x->ChangeWindowAttributes($window, 'attribute' => $value, ...)
.Ve
.Vb 3
\&  $x->GetWindowAttributes($window)
\&  =>
\&  ('backing_store' => $backing_store, ...)
.Ve
This is an example of a return value that is meant to be assigned to a hash.
.PP
.Vb 1
\&  $x->DestroyWindow($win)
.Ve
.Vb 1
\&  $x->DestroySubwindows($win)
.Ve
.Vb 1
\&  $x->ChangeSaveSet($window, $mode)
.Ve
.Vb 1
\&  $x->ReparentWindow($win, $parent, ($x, $y))
.Ve
.Vb 1
\&  $x->MapWindow($win)
.Ve
.Vb 1
\&  $x->MapSubwindows($win)
.Ve
.Vb 1
\&  $x->UnmapWindow($win)
.Ve
.Vb 1
\&  $x->UnmapSubwindows($win)
.Ve
.Vb 1
\&  $x->ConfigureWindow($win, 'attribute' => $value, ...)
.Ve
.Vb 1
\&  $x->CirculateWindow($win, $direction)
.Ve
Note that this request actually circulates the subwindows of \f(CW$win\fR,
not the window itself.
.PP
.Vb 3
\&  $x->GetGeometry($drawable)
\&  =>
\&  ('root' => $root, ...)
.Ve
.Vb 3
\&  $x->QueryTree($win)
\&  =>
\&  ($root, $parent, @kids)
.Ve
.Vb 3
\&  $x->InternAtom($name, $only_if_exists)
\&  =>
\&  $atom
.Ve
.Vb 3
\&  $x->GetAtomName($atom)
\&  =>
\&  $name
.Ve
.Vb 1
\&  $x->ChangeProperty($window, $property, $type, $format, $mode, $data)
.Ve
.Vb 1
\&  $x->DeleteProperty($win, $atom)
.Ve
.Vb 3
\&  $x->GetProperty($window, $property, $type, $offset, $length, $delete)
\&  =>
\&  ($value, $type, $format, $bytes_after)
.Ve
Notice that the value comes first, so you can easily ignore the rest.
.PP
.Vb 3
\&  $x->ListProperties($window)
\&  =>
\&  (@atoms)
.Ve
.Vb 1
\&  $x->SetSelectionOwner($selection, $owner, $time)
.Ve
.Vb 3
\&  $x->GetSelectionOwner($selection)
\&  =>
\&  $owner
.Ve
.Vb 1
\&  $x->ConvertSelection($selection, $target, $property, $requestor, $time)
.Ve
.Vb 1
\&  $x->SendEvent($destination, $propagate, $event_mask, $event)
.Ve
The \f(CW$event\fR argument should be the result of a \fIpack_event()\fR (see the section on \fI\s-1EVENTS\s0\fR)
.PP
.Vb 5
\&  $x->GrabPointer($grab_window, $owner_events, $event_mask,
\&                  $pointer_mode, $keyboard_mode, $confine_to,
\&                  $cursor, $time)
\&  =>
\&  $status
.Ve
.Vb 1
\&  $x->UngrabPointer($time)
.Ve
.Vb 3
\&  $x->GrabButton($modifiers, $button, $grab_window, $owner_events,
\&                 $event_mask, $pointer_mode, $keyboard_mode,
\&                 $confine_to, $cursor)
.Ve
.Vb 1
\&  $x->UngrabButton($modifiers, $button, $grab_window)
.Ve
.Vb 1
\&  $x->ChangeActivePointerGrab($event_mask, $cursor, $time)
.Ve
.Vb 4
\&  $x->GrabKeyboard($grab_window, $owner_events, $pointer_mode,
\&                   $keyboard_mode, $time)
\&  =>
\&  $status
.Ve
.Vb 1
\&  $x->UngrabKeyboard($time)
.Ve
.Vb 2
\&  $x->GrabKey($key, $modifiers, $grab_window, $owner_events,
\&              $pointer_mode, $keyboard_mode)
.Ve
.Vb 1
\&  $x->UngrabKey($key, $modifiers, $grab_window)
.Ve
.Vb 1
\&  $x->AllowEvents($mode, $time)
.Ve
.Vb 1
\&  $x->GrabServer
.Ve
.Vb 1
\&  $x->UngrabServer
.Ve
.Vb 3
\&  $x->QueryPointer($window)
\&  =>
\&  ('root' => $root, ...)
.Ve
.Vb 3
\&  $x->GetMotionEvents($start, $stop, $window)
\&  =>
\&  ([$time, ($x, $y)], [$time, ($x, $y)], ...)
.Ve
.Vb 3
\&  $x->TranslateCoordinates($src_window, $dst_window, $src_x, $src_y)
\&  =>
\&  ($same_screen, $child, $dst_x, $dst_y)
.Ve
.Vb 2
\&  $x->WarpPointer($src_window, $dst_window, $src_x, $src_y, $src_width,
\&                  $src_height, $dst_x, $dst_y)
.Ve
.Vb 1
\&  $x->SetInputFocus($focus, $revert_to, $time)
.Ve
.Vb 3
\&  $x->GetInputFocus
\&  =>
\&  ($focus, $revert_to)
.Ve
.Vb 3
\&  $x->QueryKeymap
\&  =>
\&  $keys
.Ve
$keys is a bit vector, so you should use \fIvec()\fR to read it.
.PP
.Vb 1
\&  $x->OpenFont($fid, $name)
.Ve
.Vb 1
\&  $x->CloseFont($font)
.Ve
.Vb 14
\&  $x->QueryFont($font)
\&  =>
\&  ('min_char_or_byte2' => $min_char_or_byte2,
\&   ..., 
\&   'min_bounds' =>
\&   [$left_side_bearing, $right_side_bearing, $character_width, $ascent,
\&    $descent, $attributes],
\&   ...,
\&   'char_infos' =>
\&   [[$left_side_bearing, $right_side_bearing, $character_width, $ascent,
\&     $descent, $attributes], 
\&    ...], 
\&   'properties' => {$prop => $value, ...}
\&   )
.Ve
.Vb 3
\&  $x->QueryTextExtents($font, $string)
\&  =>
\&  ('draw_direction' => $draw_direction, ...)
.Ve
.Vb 3
\&  $x->ListFonts($pattern, $max_names)
\&  =>
\&  @names
.Ve
.Vb 3
\&  $x->ListFontsWithInfo($pattern, $max_names)
\&  =>
\&  ({'name' => $name, ...}, {'name' => $name, ...}, ...)
.Ve
The information in each hash is the same as the the information returned by
QueryFont, but without per-character size information. This request is
special in that it is the only request that can have more than one reply.
This means you should probably only use \fIrequest()\fR with it, not \fIsend()\fR, as
the reply counting is complicated. Luckily, you never need this request
anyway, as its function is completely duplicated by other requests.
.PP
.Vb 1
\&  $x->SetFontPath(@strings)
.Ve
.Vb 3
\&  $x->GetFontPath
\&  =>
\&  @strings
.Ve
.Vb 1
\&  $x->CreatePixmap($pixmap, $drawable, $depth, $width, $height)
.Ve
.Vb 1
\&  $x->FreePixmap($pixmap)
.Ve
.Vb 1
\&  $x->CreateGC($cid, $drawable, 'attribute' => $value, ...)
.Ve
.Vb 1
\&  $x->ChangeGC($gc, 'attribute' => $value, ...)
.Ve
.Vb 1
\&  $x->CopyGC($src, $dest, 'attribute', 'attribute', ...)
.Ve
.Vb 1
\&  $x->SetDashes($gc, $dash_offset, (@dashes))
.Ve
.Vb 2
\&  $x->SetClipRectangles($gc, ($clip_x_origin, $clip_y_origin),
\&                        $ordering, [$x, $y, $width, $height], ...)
.Ve
.Vb 1
\&  $x->ClearArea($window, ($x, $y), $width, $height, $exposures)
.Ve
.Vb 2
\&  $x->CopyArea($src_drawable, $dst_drawable, $gc, ($src_x, $src_y),
\&               $width, $height, ($dst_x, $dst_y))
.Ve
.Vb 2
\&  $x->CopyPlane($src_drawable, $dst_drawable, $gc, ($src_x, $src_y),
\&                $width, $height, ($dst_x, $dst_y), $bit_plane)
.Ve
.Vb 2
\&  $x->PolyPoint($drawable, $gc, $coordinate_mode,
\&                ($x, $y), ($x, $y), ...)
.Ve
.Vb 2
\&  $x->PolyLine($drawable, $gc, $coordinate_mode,
\&               ($x, $y), ($x, $y), ...)
.Ve
.Vb 2
\&  $x->PolySegment($drawable, $gc, ($x, $y) => ($x, $y),
\&                  ($x, $y) => ($x, $y), ...)
.Ve
.Vb 2
\&  $x->PolyRectangle($drawable, $gc,
\&                    [($x, $y), $width, $height], ...)
.Ve
.Vb 2
\&  $x->PolyArc($drawable, $gc,
\&              [($x, $y), $width, $height, $angle1, $angle2], ...)
.Ve
.Vb 2
\&  $x->FillPoly($drawable, $gc, $shape, $coordinate_mode,
\&               ($x, $y), ...)
.Ve
.Vb 2
\&  $x->PolyFillRectangle($drawable, $gc,
\&                        [($x, $y), $width, $height], ...)
.Ve
.Vb 2
\&  $x->PolyFillArc($drawable, $gc,
\&                  [($x, $y), $width, $height, $angle1, $angle2], ...)
.Ve
.Vb 2
\&  $x->PutImage($drawable, $gc, $depth, $width, $height,
\&               ($dst_x, $dst_y), $left_pad, $format, $data)
.Ve
Currently, the module has no code to handle the various bitmap formats that
the server might specify. Therefore, this request will not work portably
without a lot of work.
.PP
.Vb 2
\&  $x->GetImage($drawable, ($x, $y), $width, $height, $plane_mask,
\&               $format)
.Ve
.Vb 2
\&  $x->PolyText8($drawable, $gc, ($x, $y),
\&                ($font OR [$delta, $string]), ...)
.Ve
.Vb 2
\&  $x->PolyText16($drawable, $gc, ($x, $y),
\&                 ($font OR [$delta, $string]), ...)
.Ve
.Vb 1
\&  $x->ImageText8($drawable, $gc, ($x, $y), $string)
.Ve
.Vb 1
\&  $x->ImageText16($drawable, $gc, ($x, $y), $string)
.Ve
.Vb 1
\&  $x->CreateColormap($mid, $visual, $window, $alloc)
.Ve
.Vb 1
\&  $x->FreeColormap($cmap)
.Ve
.Vb 1
\&  $x->CopyColormapAndFree($mid, $src_cmap)
.Ve
.Vb 1
\&  $x->InstallColormap($cmap)
.Ve
.Vb 1
\&  $x->UninstallColormap($cmap)
.Ve
.Vb 3
\&  $x->ListInstalledColormaps($window)
\&  =>
\&  @cmaps
.Ve
.Vb 3
\&  $x->AllocColor($cmap, ($red, $green, $blue))
\&  =>
\&  ($pixel, ($red, $green, $blue))
.Ve
.Vb 4
\&  $x->AllocNamedColor($cmap, $name)
\&  =>
\&  ($pixel, ($exact_red, $exact_green, $exact_blue),
\&   ($visual_red, $visual_green, $visual_blue))
.Ve
.Vb 3
\&  $x->AllocColorCells($cmap, $colors, $planes, $contiguous)
\&  =>
\&  ([@pixels], [@masks])
.Ve
.Vb 4
\&  $x->AllocColorPlanes($cmap, $colors, ($reds, $greens, $blues),
\&                       $contiguous)
\&  =>
\&  (($red_mask, $green_mask, $blue_mask), @pixels)
.Ve
.Vb 1
\&  $x->FreeColors($cmap, $plane_mask, @pixels)
.Ve
.Vb 1
\&  $x->StoreColors($cmap, [$pixel, $red, $green, $blue, $do_mask], ...)
.Ve
The 1, 2, and 4 bits in \f(CW$mask\fR are do-red, do-green, and do-blue. \f(CW$mask\fR can
be omitted, defaulting to 7, the usual case -- change the whole color.
.PP
.Vb 1
\&  $x->StoreNamedColor($cmap, $pixel, $name, $do_mask)
.Ve
$do_mask has the same interpretation as above, but is mandatory.
.PP
.Vb 3
\&  $x->QueryColors($cmap, @pixels)
\&  =>
\&  ([$red, $green, $blue], ...)
.Ve
.Vb 4
\&  $x->LookupColor($cmap, $name)
\&  =>
\&  (($exact_red, $exact_green, $exact_blue),
\&   ($visual_red, $visual_green, $visual_blue)) 
.Ve
.Vb 4
\&  $x->CreateCursor($cid, $source, $mask,
\&                   ($fore_red, $fore_green, $fore_blue),
\&                   ($back_red, $back_green, $back_blue),
\&                   ($x, $y))
.Ve
.Vb 6
\&  $x->CreateGlyphCursor($cid, $source_font, $mask_font,
\&                        $source_char, $mask_char,
\&                        ($fore_red, $fore_green, $fore_blue),
\&                        ($back_red, $back_green, $back_blue))
\&                        
\&  $x->FreeCursor($cursor)
.Ve
.Vb 2
\&  $x->RecolorCursor($cursor, ($fore_red, $fore_green, $fore_blue),
\&                    ($back_red, $back_green, $back_blue))
.Ve
.Vb 3
\&  $x->QueryBestSize($class, $drawable, $width, $height)
\&  =>
\&  ($width, $height)
.Ve
.Vb 3
\&  $x->QueryExtension($name)
\&  =>
\&  ($major_opcode, $first_event, $first_error)
.Ve
If the extension is not present, an empty list is returned.
.PP
.Vb 3
\&  $x->ListExtensions
\&  =>
\&  (@names)
.Ve
.Vb 2
\&  $x->ChangeModifierMapping($first_keycode, $keysysms_per_keycode,
\&                            @keysyms)
.Ve
.Vb 3
\&  $x->GetKeyboardMapping($first_keycode, $count)
\&  =>
\&  ($keysysms_per_keycode, [$keysym, ...], [$keysym, ...], ...)
.Ve
.Vb 1
\&  $x->ChangeKeyboardControl('attribute' => $value, ...)
.Ve
.Vb 3
\&  $x->GetKeyboardControl
\&  =>
\&  ('global_auto_repeat' => $global_auto_repeat, ...)
.Ve
.Vb 1
\&  $x->Bell($percent)
.Ve
.Vb 3
\&  $x->ChangePointerControl($do_acceleration, $do_threshold,
\&                           $acceleration_numerator,
\&                           $acceleration_denominator, $threshold)
.Ve
.Vb 3
\&  $x->GetPointerControl
\&  =>
\&  ($accerleration_numerator, $acceleration_denominator, $threshold)
.Ve
.Vb 2
\&  $x->SetScreenSaver($timeout, $interval, $prefer_blanking,
\&                     $allow_exposures)
.Ve
.Vb 3
\&  $x->GetScreenSaver
\&  =>
\&  ($timeout, $interval, $prefer_blanking, $allow_exposures)
.Ve
.Vb 1
\&  $x->ChangeHosts($mode, $host_family, $host_address) 
.Ve
.Vb 3
\&  $x->ListHosts
\&  =>
\&  ($mode, [$family, $host], ...)
.Ve
.Vb 1
\&  $x->SetAccessControl($mode)
.Ve
.Vb 1
\&  $x->SetCloseDownMode($mode)
.Ve
.Vb 1
\&  $x->KillClient($resource)
.Ve
.Vb 1
\&  $x->RotateProperties($win, $delta, @props)
.Ve
.Vb 1
\&  $x->ForceScreenSaver($mode)
.Ve
.Vb 3
\&  $x->SetPointerMapping(@map)
\&  =>
\&  $status
.Ve
.Vb 3
\&  $x->GetPointerMapping
\&  =>
\&  @map  
.Ve
.Vb 3
\&  $x->SetModifierMapping(@keycodes)
\&  =>
\&  $status
.Ve
.Vb 3
\&  $x->GetModiferMapping
\&  =>
\&  @keycodes
.Ve
.Vb 1
\&  $x->NoOperation($length)
.Ve
$length specifies the length of the entire useless request, in four byte units,
and is optional.
.SH "EVENTS"
To receive events, first set the \*(L'event_mask\*(R' attribute on a window to
indicate what types of events you desire (see
the section on \fIpack_event_mask\fR). Then, set the protocol object's \*(L'event_handler\*(R'
to a subroutine reference that will handle the events. Alternatively,
set \*(L'event_handler\*(R' to \*(L'queue\*(R', and retrieve events using
\fIdequeue_event()\fR. In both cases, events are returned as a hash. For
instance, a typical MotionNotify event might look like this:
.PP
.Vb 5
\&  %event = ('name' => 'MotionNotify', 'sequence_number' => 12,
\&            'state' => 0, 'event' => 58720256, 'root' => 43,
\&            'child' => None, 'same_screen' => 1, 'time' => 966080746,
\&            'detail' => 'Normal', 'event_x' => 10, 'event_y' => 3,
\&            'code' => 6, 'root_x' => 319, 'root_y' => 235)
.Ve
.Sh "pack_event_mask"
.PP
.Vb 1
\&  $mask = $x->pack_event_mask('ButtonPress', 'KeyPress', 'Exposure');
.Ve
Make an event mask (suitable as the \*(L'event_mask\*(R' of a window) from a list
of strings specifying event types.
.Sh "unpack_event_mask"
.PP
.Vb 1
\&  @event_types = $x->unpack_event_mask($mask);
.Ve
The inverse operation; convert an event mask obtained from the server into a
list of names of event categories.
.Sh "dequeue_event"
.PP
.Vb 1
\&  %event = $x->dequeue_event;
.Ve
If there is an event waiting in the queue, return it.
.Sh "next_event"
.PP
.Vb 1
\&  %event = $x->next_event;
.Ve
Like Xlib's \fIXNextEvent()\fR, this function is equivalent to
.PP
.Vb 1
\&  $x->handle_input until %event = dequeue_event;
.Ve
.Sh "pack_event"
.PP
.Vb 1
\&  $data = $x->pack_event(%event);
.Ve
Given an event in hash form, pack it into a string. This is only useful as
an argument to \fISendEvent()\fR.
.Sh "unpack_event"
.PP
.Vb 1
\&  %event = $x->unpack_event($data);
.Ve
The inverse operation; given the raw data for an event (32 bytes), unpack it
into hash form. Normally, this is done automatically.
.SH "EXTENSIONS"
Protocol extensions add new requests, event types, and error types to
the protocol. Support for them is compartmentalized in modules in the
X11::Protocol::Ext:: hierarchy. For an example, see
the \fIX11::Protocol::Ext:SHAPE\fR manpage. You can tell if the module has loaded an
extension by looking at
.PP
.Vb 1
\&  $x->{'ext'}{$extension_name}
.Ve
If the extension has been initialized, this value will be an array reference,
[$major_request_number, \f(CW$first_event_number\fR, \f(CW$first_error_number\fR, \f(CW$obj\fR], where
\f(CW$obj\fR is an object containing information private to the extension. 
.Sh "init_extension"
.PP
.Vb 1
\&  $x->init_extension($name);
.Ve
Initialize an extension: query the server to find the extension's request
number, then load the corresponding module. Returns 0 if the server does
not support the named extension, or if no module to interface with it exists.
.Sh "init_extensions"
.PP
.Vb 1
\&  $x->init_extensions;
.Ve
Initialize protocol extensions. This does a ListExtensions request, then calls
\fIinit_extension()\fR for each extension that the server supports.
.SH "WRITING EXTENSIONS"
Internally, the X11::Protocol module is table driven. All an extension has to
do is to add new add entries to the protocol object's tables. An extension
module should \f(CWuse X11::Protocol\fR, and should define an \fInew()\fR method
.PP
.Vb 2
\&  X11::Protocol::Ext::NAME
\&    ->new($x, $request_num, $event_num, $error_num)
.Ve
where \f(CW$x\fR is the protocol object and \f(CW$request_num\fR, \f(CW$event_num\fR and \f(CW$error_num\fR
are the values returned by \fIQueryExtension()\fR.
.PP
The \fInew()\fR method should add new types of constant like
.PP
.Vb 1
\&  $x->{'ext_const'}{'ConstantType'} = ['Constant', 'Constant', ...]
.Ve
and set up the corresponding name to number translation hashes like
.PP
.Vb 2
\&  $x->{'ext_const_num'}{'ConstType'} =
\&    {make_num_hash($x->{'ext_const'}{'ConstType'})}
.Ve
Event names go in
.PP
.Vb 1
\&  $x->{'ext_const'}{'Events'}[$event_number]
.Ve
while specifications for event contents go in
.PP
.Vb 1
\&  $x->{'ext_event'}[$event_number]
.Ve
each element of which is either \f(CW[\e&unpack_sub, \e&pack_sub]\fR or
\f(CW[$pack_format, $field, $field, ...]\fR, where each \f(CW$field\fR is \f(CW'name'\fR,
\f(CW['name', 'const_type']\fR, or \f(CW['name', ['special_name_for_zero',
\&'special_name_for_one']]\fR, where \f(CW'special_name_for_one'\fR is optional.
.PP
Finally,
.PP
.Vb 1
\&  $x->{'ext_request'}{$major_request_number}
.Ve
should be an array of arrays, with each array either \f(CW[$name, \e&packit]\fR or
\f(CW[$name, \e&packit, \e&unpackit]\fR, and
.PP
.Vb 1
\&  $x->{'ext_request_num'}{$request_name}
.Ve
should be initialized with \f(CW[$minor_num, $major_num]\fR for each request the
extension defines. For examples of code that does all of this, look at
X11::Protocol::Ext::SHAPE.
.PP
X11::Protocol exports several functions that might be useful in extensions
(note that these are \fInot\fR methods).
.Sh "padding"
.PP
.Vb 1
\&  $p = padding $x;
.Ve
Given an integer, compute the number need to round it up to a multiple of 4.
For instance, \f(CWpadding(5)\fR is 3.
.Sh "pad"
.PP
.Vb 1
\&  $p = pad $str;
.Ve
Given a string, return the number of extra bytes needed to make a multiple
of 4. Equivalent to \f(CWpadding(length($str))\fR.
.Sh "padded"
.PP
.Vb 1
\&  $data = pack(padded($str), $str);
.Ve
Return a format string, suitable for \fIpack()\fR, for a string padded to a multiple
of 4 bytes. For instance, \f(CWpack(padded('Hello'), 'Hello')\fR gives
\f(CW"Hello\e0\e0\e0"\fR.
.Sh "hexi"
.PP
.Vb 1
\&  $str = hexi $n;
.Ve
Format a number in hexidecimal, and add a \*(L"0x\*(R" to the front.
.Sh "make_num_hash"
.PP
.Vb 1
\&  %hash = make_num_hash(['A', 'B', 'C']);
.Ve
Given a reference to a list of strings, return a hash mapping the strings onto
numbers representing their position in the list, as used by
\f(CW$x->{'ext_const_num'}\fR.
.SH "BUGS"
This module is too big (~2500 lines), too slow (10 sec to load on a slow
machine), too inefficient (request args are copied several times), and takes
up too much memory (3000K for basicwin).
.PP
If you have more than 65535 replies outstanding at once, sequence numbers
can collide.
.PP
The protocol is too complex.
.SH "AUTHOR"
Stephen McCamant <alias@mcs.com>.
.SH "SEE ALSO"
the \fIperl(1)\fR manpage,
the \fIX(1)\fR manpage, 
the \fIX11::Keysyms\fR manpage, 
the \fIX11::Protocol::Ext::SHAPE\fR manpage,
the \fIX11::Protocol::Ext::BIG_REQUESTS\fR manpage,
the \fIX11::Auth\fR manpage,
\fIX Window System Protocol (X Version 11)\fR,
\fIInter-Client Communications Conventions Manual\fR,
\fIX Logical Font Description Conventions\fR.

.rn }` ''
.IX Title "Protocol 3"
.IX Name "X11::Protocol - Perl module for the X Window System Protocol, version 11"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Header "DISCLAIMER"

.IX Header "BASIC METHODS"

.IX Subsection "new"

.IX Subsection "new_rsrc"

.IX Subsection "handle_input"

.IX Subsection "atom_name"

.IX Subsection "atom"

.IX Subsection "choose_screen"

.IX Header "SYMBOLIC CONSTANTS"

.IX Subsection "num"

.IX Subsection "interp"

.IX Header "SERVER INFORMATION"

.IX Header "REQUESTS"

.IX Subsection "request"

.IX Subsection "add_reply"

.IX Subsection "delete_reply"

.IX Subsection "send"

.IX Subsection "unpack_reply"

.IX Header "EVENTS"

.IX Subsection "pack_event_mask"

.IX Subsection "unpack_event_mask"

.IX Subsection "dequeue_event"

.IX Subsection "next_event"

.IX Subsection "pack_event"

.IX Subsection "unpack_event"

.IX Header "EXTENSIONS"

.IX Subsection "init_extension"

.IX Subsection "init_extensions"

.IX Header "WRITING EXTENSIONS"

.IX Subsection "padding"

.IX Subsection "pad"

.IX Subsection "padded"

.IX Subsection "hexi"

.IX Subsection "make_num_hash"

.IX Header "BUGS"

.IX Header "AUTHOR"

.IX Header "SEE ALSO"

