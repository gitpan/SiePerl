.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH Map8 3 "perl 5.005, patch 03" "21/Jan/2000" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
Unicode::Map8 \- Mapping table between 8-bit chars and Unicode
.SH "SYNOPSIS"
.PP
.Vb 3
\& require Unicode::Map8;
\& my $no_map = Unicode::Map8->new("ISO646-NO") || die;
\& my $l1_map = Unicode::Map8->new("latin1")    || die;
.Ve
.Vb 3
\& my $ustr = $no_map->to16("V}re norske tegn b|r {res\en");
\& my $lstr = $l1_map->to8($ustr);
\& print $lstr;
.Ve
.Vb 1
\& print $no_map->tou("V}re norske tegn b|r {res\en")->utf8
.Ve
.SH "DESCRIPTION"
The \fIUnicode::Map8\fR class implement efficient mapping tables between
8-bit character sets and 16 bit character sets like Unicode.  The
tables are efficient both in terms of space allocated and translation
speed.  The 16-bit strings is assumed to use network byte order.
.PP
The following methods are available:
.Ip "$m = Unicode::Map8->new( [$charset] )" 4
The object constructor creates new instances of the Unicode::Map8
class.  I takes an optional argument that specify then name of a 8-bit
character set to initialize mappings from.  The argument can also be a
the name of a mapping file.  If the charset/file can not be located,
then the constructor returns \fIundef\fR.
.Sp
If you omit the argument, then an empty mapping table is constructed.
You must then add mapping pairs to it using the \fIaddpair()\fR method
described below.
.Ip "$m->addpair( $u8, $u16 );" 4
Adds a new mapping pair to the mapping object.  It takes two
arguments.  The first is the code value in the 8-bit character set and
the second is the corresponding code value in the 16-bit character
set.  The same codes can be used multiple times (but using the same
pair has no effect).  The first definition for a code is the one that
is used.
.Sp
Consider the following example:
.Sp
.Vb 3
\&  $m->addpair(0x20, 0x0020);
\&  $m->addpair(0x20, 0x00A0);
\&  $m->addpair(0xA0, 0x00A0);
.Ve
It means that the character 0x20 and 0xA0 in the 8-bit charset maps to
themselves in the 16-bit set, but in the 16-bit character set 0x0A0 maps
to 0x20.
.Ip "$m->default_to8( $u8 )" 4
Set the code of the default character to use when mapping from 16-bit to
8-bit strings.  If there is no mapping pair defined for a character
then this default is substituted by \fIto8()\fR and \fIrecode8()\fR.
.Ip "$m->default_to16( $u16 )" 4
Set the code of the default character to use when mapping from 8-bit to
16-bit strings. If there is no mapping pair defined for a character
then this default is used by \fIto16()\fR, \fItou()\fR and \fIrecode8()\fR.
.Ip "$m->nostrict;" 4
All undefined mappings are replaced with the identity mapping.
Undefined character are normally just removed (or replaced with the
default if defined) when converting between character sets.
.Ip "$m->to8( $ustr );" 4
Converts a 16-bit character string to the corresponding string in the
8-bit character set.
.Ip "$m->to16( $str );" 4
Converts a 8-bit character string to the corresponding string in the
16-bit character set.
.Ip "$m->tou( $str );" 4
Same an \fIto16()\fR but return a Unicode::String object instead of a plain
\s-1UCS2\s0 string.
.Ip "$m->recode8($m2, $str);" 4
Map the string \f(CW$str\fR from one 8-bit character set ($m) to another one
($m2).  Since we assume we know the mappings towards the common 16-bit
encoding we can use this to convert between any of the 8-bit character
sets.
.Ip "$m->to_char16( $u8 )" 4
Maps a single 8-bit character code to an 16-bit code.  If the 8-bit
character is unmapped then the constant \s-1NOCHAR\s0 is returned.  The
default is not used and the callback method is not invoked.
.Ip "$m->to_char8( $u16 )" 4
Maps a single 16-bit character code to an 8-bit code. If the 16-bit
character is unmapped then the constant \s-1NOCHAR\s0 is returned.  The
default is not used and the callback method is not invoked.
.PP
The following callback methods are available.  You can override these
methods by creating a subclass of Unicode::Map8.
.Ip "$m->unmapped_to8" 4
When mapping to 8-bit character string and there is no mapping defined
(and no default either), then this method is called as the last
resort.  It is called with a single integer argument which is the code
of the unmapped 16-bit character.  It is expected to return a string
that will be incorporated in the 8-bit string.  The default version of
this method always returns an empty string.
.Sp
Example:
.Sp
.Vb 9
\& package MyMapper;
\& @ISA=qw(Unicode::Map8);
\& 
\& sub unmapped_to8
\& {
\&    my($self, $code) = @_;
\&    require Unicode::CharName;
\&    "<" . Unicode::CharName::uname($code) . ">";
\& }
.Ve
.Ip "$m->unmapped_to16" 4
Likewise when mapping to 16-bit character string and no mapping is
defined then this method is called.  It should return a 16-bit string
with the bytes in network byte order.  The default version of
this method always returns an empty string.
.SH "FILES"
The \fIUnicode::Map8\fR constructor can parse two different file formats;
a binary format and a textual format.
.PP
The binary format is simple.  It consist of a sequence of 16-bit
integer pairs in network byte order.  The first pair should contain
the magic value 0xFFFE, 0x0001.  Of each pair, the first value is the
code of an 8-bit character and the second is the code of the 16-bit
character.  If follows from this that the first value should be less
than 256.
.PP
The textual format consist of lines that is either a comment (first
non-blank character is \*(L'#'), a completely blank line or a line with
two hexadecimal numbers.  The hexadecimal numbers must be preceded by
\*(L"0x\*(R" as in C and Perl.  This is the same format used by the Unicode
mapping files available from <URL:ftp://ftp.unicode.org/Public>.
.PP
The mapping table files are installed in the \fIUnicode/Map8/maps\fR
directory somewhere in the Perl \f(CW@INC\fR path.  The variable
\f(CW$Unicode::Map8::MAPS_DIR\fR is the complete path name to this directory.
Binary mapping files are stored within this directory with the suffix
\&\fI.bin\fR.  Textual mapping files are stored with the suffix \fI.txt\fR.
.PP
The scripts \fImap8_bin2txt\fR and \fImap8_txt2bin\fR can translate between
these mapping file formats.
.PP
A special file called \fIaliases\fR within \f(CW$MAPS_DIR\fR specify all the
alias names that can be used to denote the various character sets.
The first name of each line is the real file name and the rest is
alias names separated by space.
.PP
The `\f(CWumap --list\fR\*(R' command be used to list the character sets
supported.
.SH "BUGS"
Does not handle Unicode surrogate pairs as a single character.
.SH "SEE ALSO"
the \fIumap(1)\fR manpage,
the \fIUnicode::String\fR manpage
.SH "COPYRIGHT"
Copyright 1998 Gisle Aas.
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

.rn }` ''
.IX Title "Map8 3"
.IX Name "Unicode::Map8 - Mapping table between 8-bit chars and Unicode"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Item "$m = Unicode::Map8->new( [$charset] )"

.IX Item "$m->addpair( $u8, $u16 );"

.IX Item "$m->default_to8( $u8 )"

.IX Item "$m->default_to16( $u16 )"

.IX Item "$m->nostrict;"

.IX Item "$m->to8( $ustr );"

.IX Item "$m->to16( $str );"

.IX Item "$m->tou( $str );"

.IX Item "$m->recode8($m2, $str);"

.IX Item "$m->to_char16( $u8 )"

.IX Item "$m->to_char8( $u16 )"

.IX Item "$m->unmapped_to8"

.IX Item "$m->unmapped_to16"

.IX Header "FILES"

.IX Header "BUGS"

.IX Header "SEE ALSO"

.IX Header "COPYRIGHT"

