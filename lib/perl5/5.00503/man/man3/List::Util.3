.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH lib::List::Util 3 "perl 5.005, patch 03" "10/Apr/2000" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
List::Util \- A selection of general-utility list subroutines
.SH "SYNOPSIS"
.PP
.Vb 1
\&    use List::Util qw(first sum min max minstr maxstr reduce);
.Ve
.SH "DESCRIPTION"
\f(CWList::Util\fR contains a selection of subroutines that people have
expressed would be nice to have in the perl core, but the usage would
not really be high enough to warrant the use of a keyword, and the size
so small such that being individual extensions would be wasteful.
.PP
By default \f(CWList::Util\fR does not export any subroutines. The
subroutines defined are
.Ip "first \s-1BLOCK\s0 \s-1LIST\s0" 4
Similar to \f(CWgrep\fR in that it evaluates \s-1BLOCK\s0 setting \f(CW$_\fR to each element
of \s-1LIST\s0 in turn. \f(CWfirst\fR returns the first element where the result from
\s-1BLOCK\s0 is a true value. If \s-1BLOCK\s0 never returns true or \s-1LIST\s0 was empty then
\f(CWundef\fR is returned.
.Sp
.Vb 5
\&    $foo = first { defined($_) } @list    # first defined value in @list
\&    $foo = first { $_ > $value } @list    # first value in @list which
\&                                          # is greater than $value
\&    
\&This function could be implemented using C<reduce> like this
.Ve
.Vb 1
\&    $foo = reduce { defined($a) ? $a : wanted($b) ? $b : undef } undef, @list
.Ve
for example \fIwanted()\fR could be \fIdefined()\fR which would return the first
defined value in \f(CW@list\fR
.Ip "max \s-1LIST\s0" 4
Returns the entry in the list with the highest numerical value. If the
list is empty then \f(CWundef\fR is returned.
.Sp
.Vb 3
\&    $foo = max 1..10                # 10
\&    $foo = max 3,9,12               # 12
\&    $foo = max @bar, @baz           # whatever
.Ve
This function could be implemented using \f(CWreduce\fR like this
.Sp
.Vb 1
\&    $foo = reduce { $a > $b ? $a : $b } 1..10
.Ve
.Ip "maxstr \s-1LIST\s0" 4
Similar to \f(CWmax\fR, but treats all the entries in the list as strings
and returns the highest string as defined by the \f(CWgt\fR operator.
If the list is empty then \f(CWundef\fR is returned.
 
    \f(CW$foo\fR = maxstr \*(L'A\*(R'..'Z\*(R'     	    # \*(L'Z\*(R'
    \f(CW$foo\fR = maxstr \*(L"hello\*(R","world\*(R"   # \*(L"world\*(R"
    \f(CW$foo\fR = maxstr \f(CW@bar\fR, \f(CW@baz\fR        # whatever
.Sp
This function could be implemented using \f(CWreduce\fR like this
.Sp
.Vb 1
\&    $foo = reduce { $a gt $b ? $a : $b } 'A'..'Z'
.Ve
.Ip "min \s-1LIST\s0" 4
Similar to \f(CWmax\fR but returns the entry in the list with the lowest
numerical value. If the list is empty then \f(CWundef\fR is returned.
.Sp
.Vb 3
\&    $foo = min 1..10                # 1
\&    $foo = min 3,9,12               # 3
\&    $foo = min @bar, @baz           # whatever
.Ve
This function could be implemented using \f(CWreduce\fR like this
.Sp
.Vb 1
\&    $foo = reduce { $a < $b ? $a : $b } 1..10
.Ve
.Ip "minstr \s-1LIST\s0" 4
Similar to \f(CWmin\fR, but treats all the entries in the list as strings
and returns the lowest string as defined by the \f(CWlt\fR operator.
If the list is empty then \f(CWundef\fR is returned.
.Sp
.Vb 3
\&    $foo = maxstr 'A'..'Z'          # 'A'
\&    $foo = maxstr "hello","world"   # "hello"
\&    $foo = maxstr @bar, @baz        # whatever
.Ve
This function could be implemented using \f(CWreduce\fR like this
.Sp
.Vb 1
\&    $foo = reduce { $a lt $b ? $a : $b } 'A'..'Z'
.Ve
.Ip "reduce \s-1BLOCK\s0 \s-1LIST\s0" 4
Reduces \s-1LIST\s0 by calling \s-1BLOCK\s0 multiple times, setting \f(CW$a\fR and \f(CW$b\fR
each time. The first call will be with \f(CW$a\fR and \f(CW$b\fR set to the first
two elements of the list, subsequent calls will be done by
setting \f(CW$a\fR to the result of the previous call and \f(CW$b\fR to the next
element in the list. 
.Sp
Returns the result of the last call to \s-1BLOCK\s0. If \s-1LIST\s0 is empty then
\f(CWundef\fR is returned. If \s-1LIST\s0 only contains one element then that
element is returned and \s-1BLOCK\s0 is not executed.
.Sp
.Vb 4
\&    $foo = reduce { $a < $b ? $a : $b } 1..10       # min
\&    $foo = reduce { $a lt $b ? $a : $b } 'aa'..'zz' # minstr
\&    $foo = reduce { $a + $b } 1 .. 10               # sum
\&    $foo = reduce { $a . $b } @bar                  # concat
.Ve
.Ip "sum \s-1LIST\s0" 4
Returns the sum of all the elements in \s-1LIST\s0.
.Sp
.Vb 3
\&    $foo = sum 1..10                # 55
\&    $foo = sum 3,9,12               # 24
\&    $foo = sum @bar, @baz           # whatever
.Ve
This function could be implemented using \f(CWreduce\fR like this
.Sp
.Vb 1
\&    $foo = reduce { $a + $b } 1..10
.Ve
.SH "SUGGESTED ADDITIONS"
The following are additions that have been requested, but I have been reluctant
to add due to them being very simple to implement in perl
.PP
.Vb 1
\&  # One argument is true
.Ve
.Vb 1
\&  sub any { $_ && return 1 for @_; 0 }
.Ve
.Vb 1
\&  # All arguments are true
.Ve
.Vb 1
\&  sub all { $_ || return 0 for @_; 1 }
.Ve
.Vb 1
\&  # All arguments are false
.Ve
.Vb 1
\&  sub none { $_ && return 0 for @_; 1 }
.Ve
.Vb 1
\&  # One argument is false
.Ve
.Vb 1
\&  sub notall { $_ || return 1 for @_; 0 }
.Ve
.Vb 1
\&  # How many elements are true
.Ve
.Vb 1
\&  sub true { scalar grep { $_ } @_ }
.Ve
.Vb 1
\&  # How many elements are false
.Ve
.Vb 1
\&  sub false { scalar grep { !$_ } @_ }
.Ve
.SH "COPYRIGHT"
Copyright (c) 1997-2000 Graham Barr <gbarr@pobox.com>. All rights reserved.
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

.rn }` ''
.IX Title "lib::List::Util 3"
.IX Name "List::Util - A selection of general-utility list subroutines"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Item "first \s-1BLOCK\s0 \s-1LIST\s0"

.IX Item "max \s-1LIST\s0"

.IX Item "maxstr \s-1LIST\s0"

.IX Item "min \s-1LIST\s0"

.IX Item "minstr \s-1LIST\s0"

.IX Item "reduce \s-1BLOCK\s0 \s-1LIST\s0"

.IX Item "sum \s-1LIST\s0"

.IX Header "SUGGESTED ADDITIONS"

.IX Header "COPYRIGHT"

