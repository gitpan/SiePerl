.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH Fields 3 "perl 5.005, patch 03" "30/Jan/1998" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
Sort::Fields \- Sort lines containing delimited fields
.SH "SYNOPSIS"
.PP
.Vb 3
\&  use Sort::Fields;
\&  @sorted = fieldsort [3, '2n'], @lines;
\&  @sorted = fieldsort '\e+', [-1, -3, 0], @lines;
.Ve
.Vb 2
\&  $sort_3_2n = make_fieldsort [3, '2n'], @lines;
\&  @sorted = $sort_3_2n->(@lines);
.Ve
.SH "DESCRIPTION"
Sort::Fields provides a general purpose technique for efficiently sorting
lists of lines that contain data separated into fields.
.PP
Sort::Fields automatically imports two subroutines, \f(CWfieldsort\fR and
\f(CWmake_fieldsort\fR, and two variants, \f(CWstable_fieldsort\fR and 
\f(CWmake_stable_fieldsort\fR.  \f(CWmake_fieldsort\fR generates a sorting subroutine
and returns a reference to it.  \f(CWfieldsort\fR is a wrapper for
the \f(CWmake_fieldsort\fR subroutine.
.PP
The first argument to make_fieldsort is a delimiter string, which is
used as a regular expression argument for a \f(CWsplit\fR operator.  The
delimiter string is optional.  If it is not supplied, make_fieldsort
splits each line using \f(CW/\es+/\fR.
.PP
The second argument is an array reference containing one or more 
field specifiers.  The specifiers indicate what fields in the strings
will be used to sort the data.  The specifier \*(L"1\*(R" indicates the first
field, \*(L"2\*(R" indicates the second, and so on.  A negative specifier
like \*(L"\-2\*(R" means to sort on the second field in reverse (descending)
order.  To indicate a numeric rather than alphabetic comparison,
append \*(L"n\*(R" to the specifier.  A specifier of \*(L"0\*(R" means the entire
string (\*(R"\-0\*(R" means the entire string, in reverse order).
.PP
The order in which the specifiers appear is the order in which they
will be used to sort the data.  The primary key is first, the secondary
key is second, and so on.
.PP
\f(CWfieldsort [1, 2], @data\fR is roughly equivalent to
\f(CWmake_fieldsort([1, 2])->(@data)\fR.  Avoid calling fieldsort repeatedly
with the same sort specifiers.  If you need to use a particular
sort more than once, it is more efficient to call \f(CWmake_fieldsort\fR
once and reuse the subroutine it returns.
.PP
\f(CWstable_fieldsort\fR and \f(CWmake_stable_fieldsort\fR are like their
\*(L"unstable\*(R" counterparts, except that the items that compare the same
are maintained in their original order.
.SH "EXAMPLES"
Some sample data (in array \f(CW@data\fR):
.PP
.Vb 8
\&  123   asd   1.22   asdd
\&  32    ewq   2.32   asdd
\&  43    rewq  2.12   ewet
\&  51    erwt  34.2   ewet
\&  23    erww  4.21   ewet
\&  91    fdgs  3.43   ewet
\&  123   refs  3.22   asdd
\&  123   refs  4.32   asdd
.Ve
.Vb 2
\&  # alpha sort on column 1
\&  print fieldsort [1], @data;
.Ve
.Vb 8
\&  123   asd   1.22   asdd
\&  123   refs  3.22   asdd
\&  123   refs  4.32   asdd
\&  23    erww  4.21   ewet
\&  32    ewq   2.32   asdd
\&  43    rewq  2.12   ewet
\&  51    erwt  34.2   ewet
\&  91    fdgs  3.43   ewet
.Ve
.Vb 2
\&  # numeric sort on column 1
\&  print fieldsort ['1n'], @data;
.Ve
.Vb 8
\&  23    erww  4.21   ewet
\&  32    ewq   2.32   asdd
\&  43    rewq  2.12   ewet
\&  51    erwt  34.2   ewet
\&  91    fdgs  3.43   ewet
\&  123   asd   1.22   asdd
\&  123   refs  3.22   asdd
\&  123   refs  4.32   asdd
.Ve
.Vb 2
\&  # reverse numeric sort on column 1
\&  print fieldsort ['-1n'], @data;
.Ve
.Vb 8
\&  123   asd   1.22   asdd
\&  123   refs  3.22   asdd
\&  123   refs  4.32   asdd
\&  91    fdgs  3.43   ewet
\&  51    erwt  34.2   ewet
\&  43    rewq  2.12   ewet
\&  32    ewq   2.32   asdd
\&  23    erww  4.21   ewet
.Ve
.Vb 2
\&  # alpha sort on column 2, then alpha on entire line
\&  print fieldsort [2, 0], @data;
.Ve
.Vb 8
\&  123   asd   1.22   asdd
\&  51    erwt  34.2   ewet
\&  23    erww  4.21   ewet
\&  32    ewq   2.32   asdd
\&  91    fdgs  3.43   ewet
\&  123   refs  3.22   asdd
\&  123   refs  4.32   asdd
\&  43    rewq  2.12   ewet
.Ve
.Vb 3
\&  # alpha sort on column 4, then numeric on column 1, then reverse
\&  # numeric on column 3
\&  print fieldsort [4, '1n', '-3n'], @data;
.Ve
.Vb 8
\&  32    ewq   2.32   asdd
\&  123   refs  4.32   asdd
\&  123   refs  3.22   asdd
\&  123   asd   1.22   asdd
\&  23    erww  4.21   ewet
\&  43    rewq  2.12   ewet
\&  51    erwt  34.2   ewet
\&  91    fdgs  3.43   ewet
.Ve
.Vb 4
\&  # now, splitting on either literal period or whitespace
\&  # sort numeric on column 4 (fractional part of decimals) then
\&  # numeric on column 3 (whole part of decimals)
\&  print fieldsort '(?:\e.|\es+)', ['4n', '3n'], @data;
.Ve
.Vb 8
\&  51    erwt  34.2   ewet
\&  43    rewq  2.12   ewet
\&  23    erww  4.21   ewet
\&  123   asd   1.22   asdd
\&  123   refs  3.22   asdd
\&  32    ewq   2.32   asdd
\&  123   refs  4.32   asdd
\&  91    fdgs  3.43   ewet
.Ve
.Vb 3
\&  # alpha sort on column 4, then numeric on the entire line
\&  # NOTE: produces warnings under -w
\&  print fieldsort [4, '0n'], @data;
.Ve
.Vb 8
\&  32    ewq   2.32   asdd
\&  123   asd   1.22   asdd
\&  123   refs  3.22   asdd
\&  123   refs  4.32   asdd
\&  23    erww  4.21   ewet
\&  43    rewq  2.12   ewet
\&  51    erwt  34.2   ewet
\&  91    fdgs  3.43   ewet
.Ve
.Vb 3
\&  # stable alpha sort on column 4 (maintains original relative order
\&  # among items that compare the same)
\&  print stable_fieldsort [4], @data;
.Ve
.Vb 8
\&  123   asd   1.22   asdd
\&  32    ewq   2.32   asdd
\&  123   refs  3.22   asdd
\&  123   refs  4.32   asdd
\&  43    rewq  2.12   ewet
\&  51    erwt  34.2   ewet
\&  23    erww  4.21   ewet
\&  91    fdgs  3.43   ewet
.Ve
.SH "BUGS"
Some rudimentary tests now.
.PP
Perhaps something should be done to catch things like:
.PP
.Vb 1
\&  fieldsort '.', [1, 2], @lines;
.Ve
\&\f(CW'.'\fR translates to \f(CWsplit /./\fR -- probably not what you want.
.PP
Passing blank lines and/or lines containing the wrong kind of
data (alphas instead of numbers) can result in copious warning messages
under \f(CW-w\fR.
.PP
If the regexp contains memory parentheses (\f(CW(...)\fR rather than \f(CW(?:...)\fR),
split will function in \*(L"delimiter retention\*(R" mode, capturing the
contents of the parentheses as well as the stuff between the delimiters.
I could imagine how this could be useful, but on the other hand I
could also imagine how it could be confusing if encountered unexpectedly.
Caveat sortor.
.PP
Not really a bug, but if you are planning to sort a large text file,
consider using \fIsort\fR\|(1).  Unless, of course, your operating system
doesn't have \fIsort\fR\|(1).
.SH "AUTHOR"
Joseph N. Hall, joseph@5sigma.com
.SH "SEE ALSO"
\fIperl\fR\|(1).

.rn }` ''
.IX Title "Fields 3"
.IX Name "Sort::Fields - Sort lines containing delimited fields"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Header "EXAMPLES"

.IX Header "BUGS"

.IX Header "AUTHOR"

.IX Header "SEE ALSO"

