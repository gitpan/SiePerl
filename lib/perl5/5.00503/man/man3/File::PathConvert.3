.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH PathConvert 3 "perl 5.005, patch 03" "2/Feb/1999" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
abs2rel \- convert an absolute path to a relative path
.PP
rel2abs \- convert a relative path to an absolute path
.PP
realpath \- convert a logical path to a physical path (resolve symlinks)
.PP
splitpath \- split a path in to volume, directory and filename components
.PP
joinpath \- join volume, directory, and filename components to form a path
.PP
splitdirs \- split directory specification in to component names
.PP
joindirs \- join component names in to a directory specification
.PP
setfstype \- set the file system type
.SH "SYNOPSIS"
.PP
.Vb 2
\&    use File::PathConvert qw(realpath abs2rel rel2abs setfstype splitpath 
\&      joinpath splitdirs joindirs $resolved);
.Ve
.Vb 2
\&    $relpath = abs2rel($abspath);
\&    $abspath = abs2rel($abspath, $base);
.Ve
.Vb 2
\&    $abspath = rel2abs($relpath);
\&    $abspath = rel2abs($relpath, $base);
.Ve
.Vb 1
\&    $path = realpath($logpath) || die "resolution stopped at $resolved";
.Ve
.Vb 2
\&    ( $volume, $directory, $filename )= splitpath( $path ) ;
\&    ( $volume, $directory, $filename )= splitpath( $path, 'nofile' ) ;
.Ve
.Vb 1
\&    $path= joinpath( $volume, $directory, $filename ) ;
.Ve
.Vb 2
\&    @directories= splitdirs( $directory ) ;
\&    $directory= joindirs( @directories ) ;
.Ve
.SH "DESCRIPTION"
File::PathConvert provides functions to convert between absolute and
relative paths, and from logical paths to physical paths on a variety of
filesystems, including the URL \*(L'filesystem\*(R'.
.PP
Paths are decomposed internally in to volume, directory, and, sometimes
filename portions as appropriate to the operation and filesystem, then
recombined.  This preserves the volume and filename portions so that they may
be returned, and prevents them from interfering with the path conversions.  
.PP
Here are some examples of path decomposition.  A \*(L'****\*(R' in a column indicates
the column is not used in \f(CWabs2rel\fR and \f(CWrel2abs\fR functions for that
filesystem type.
.PP
.Vb 5
\&    FS      VOLUME                  Directory       filename
\&    ======= ======================= =============== =============
\&    URL     http:                   /a/b/           c?query
\&            http://fubar.com        /a/b/           c?query
\&            //p.d.q.com             /a/b/c/         ?query
.Ve
.Vb 3
\&    VMS     Server::Volume:         [a.b]           c
\&            Server"access spec"::   [a.b]           c
\&            Volume:                 [a.b]           c
.Ve
.Vb 3
\&    Win32   A:                      \ea\eb\ec          ****
\&            \e\eserver\eVolume         \ea\eb\ec          ****
\&            \e\eserver\eVolume         \ea/b/c          ****
.Ve
.Vb 1
\&    Unix    ****                    \ea\eb\ec          ****
.Ve
.Vb 1
\&    MacOS   Volume::                a:b:c           ****
.Ve
Many more examples abound in the test.pl included with this module.
.PP
Only the VMS and URL filesystems indicate if the last name in a path is a
directory or file.  For other filesystems, all non-volume names are assumed to
be directory names.  For URLs, the last name in a path is assumed to be a
filename unless it ends in \*(L'/\*(R', \*(L'/.\*(R', or \*(L'/..\*(R'.   
.PP
Other assumptions are made as well, especially MacOS and VMS. THESE MAY CHANGE
BASED ON PROGRAMMER FEEDBACK!
.PP
The conversion routines \f(CWabs2rel\fR, \f(CWrel2abs\fR, and \f(CWrealpath\fR are the 
main focus of this package.  \f(CWsplitpath\fR and \f(CWjoinpath\fR are provided to 
allow volume oriented filesystems (almost anything non-unixian, actually)
to be accomodated.  \f(CWsplitdirs\fR and \f(CWjoindirs\fR provide directory path
grammar parsing and encoding, which is especially useful for VMS.
.Ip "setfstype" 4
This is called automatically on module load to set the filesystem type
according to $^O. The user can call this later set the filesystem type
manually.  If the name is not recognized, unix defaults are used.  Names
matching /^\s-1URL$/\s0i, /^\s-1VMS$/\s0i, /^MacOS$/i, or /^(ms)?(win|dos)/32|nt)?$/i yield
the appropriate (hopefully) filesystem settings.  These strings may be
generalized in the future.
.Sp
Examples:
.Sp
.Vb 3
\&    File::PathConvert::setfstype( 'url' ) ; 
\&    File::PathConvert::setfstype( 'Win32' ) ;
\&    File::PathConvert::setfstype( 'HAL9000' ) ; # Results in Unix default
.Ve
.Ip "abs2rel" 4
\f(CWabs2rel\fR converts an absolute path name to a relative path:
converting /1/2/3/a/b/c relative to /1/2/3 returns a/b/c
.Sp
.Vb 2
\&    $relpath= abs2rel( $abspath ) ;
\&    $relpath= abs2rel( $abspath, $base ) ;
.Ve
If \f(CW$abspath\fR is already relative, it is returned unchanged.  Otherwise the
relative path from \f(CW$base\fR to \f(CW$abspath\fR is returned.  If \f(CW$base\fR is undefined the
current directory is used.
.Sp
The volume and filename portions of \f(CW$base\fR are ignored if present.  
If \f(CW$abspath\fR and \f(CW$base\fR are on different volumes, the volume from \f(CW$abspath\fR is
used.
.Sp
No filesystem calls are made except for getting the current working directory
if \f(CW$base\fR is undefined, so symbolic links are not checked for or resolved, and
no check is done for existance.
.Sp
Examples
.Sp
.Vb 3
\&    # Unix
\&    'a/b/c' == abs2rel( 'a/b/c', $anything )
\&    'a/b/c' == abs2rel( '/1/2/3/a/b/c', '/1/2/3' )
.Ve
.Vb 3
\&    # DOS
\&    'a\e\eb/c' == abs2rel( 'a\e\eb/c', $anything )
\&    'a\e\eb/c' == abs2rel( '/1\e\e2/3/a\e\eb/c', '/1/2/3' )
.Ve
.Vb 8
\&    # URL
\&    'http:a/b/c'           == abs2rel( 'http:a/b/c', $anything ) 
\&    'http:a/b/c'           == abs2rel( 'http:/1/2/3/a/b/c',
\&                                       'ftp://t.org/1/2/3/?z' )
\&    'http:a/b/c?q'         == abs2rel( 'http:/1/2/3/a/b/c/?q',
\&                                       'ftp://t.org/1/2/3?z'  )
\&    'http://s.com/a/b/c?q' == abs2rel( 'http://s.com/1/2/3/a/b/c?q',
\&                                       'ftp://t.org/1/2/3/?z')
.Ve
.Ip "rel2abs" 4
\f(CWrel2abs\fR makes converts a relative path name to an absolute path: 
converting a/b/c relative to /1/2/3 returns /1/2/3/a/b/c.
.Sp
.Vb 2
\&    $abspath= rel2abs( $relpath ) ;
\&    $abspath= rel2abs( $relpath, $base ) ;
.Ve
If \f(CW$relpath\fR is already absolute, it is returned unchanged.  Otherwise \f(CW$relpath\fR
is taken to be relative to \f(CW$base\fR and the resulting absolute path is returned.
If \f(CW$base\fR is not supplied, the current working directory is used.
.Sp
The volume portion of \f(CW$relpath\fR is ignored.  The filename portion of \f(CW$base\fR is
also ignored. The volume from \f(CW$base\fR is returned if present. The filename
portion of \f(CW$abspath\fR is returned if present.
.Sp
No filesystem calls are made except for getting the current working directory
if \f(CW$base\fR is undefined, so symbolic links are not checked for or resolved, and
no check is done for existance.
.Sp
\f(CWrel2abs\fR will not return a path of the form \*(L"./file\*(R".
.Sp
Examples
.Sp
.Vb 3
\&    # Unix
\&    '/a/b/c'       == rel2abs( '/a/b/c', $anything )
\&    '/1/2/3/a/b/c' == rel2abs( 'a/b/c', '/1/2/3' )
.Ve
.Vb 5
\&    # DOS
\&    '\e\ea\e\eb/c'                == rel2abs( '\e\ea\e\eb/c', $anything )
\&    '/1\e\e2/3\e\ea\e\eb/c'         == rel2abs( 'a\e\eb/c', '/1\e\e2/3' )
\&    'C:/1\e\e2/3\e\ea\e\eb/c'       == rel2abs( 'D:a\e\eb/c', 'C:/1\e\e2/3' )
\&    '\e\e\e\es\e\ev/1\e\e2/3\e\ea\e\eb/c' == rel2abs( 'D:a\e\eb/c', '\e\e\e\es\e\ev/1\e\e2/3' )
.Ve
.Vb 4
\&    # URL
\&    'http:/a/b/c?q'            == rel2abs( 'http:/a/b/c?q', $anything )
\&    'ftp://t.org/1/2/3/a/b/c?q'== rel2abs( 'http:a/b/c?q',
\&                                           'ftp://t.org/1/2/3?z' )
.Ve
.Ip "realpath" 4
\f(CWrealpath\fR makes a canonicalized absolute pathname and
resolves all symbolic links, extra ``/'\*(R' characters, and references
to /./ and /../ in the path.
\f(CWrealpath\fR resolves both absolute and relative paths.
It returns the resolved name on success, otherwise it returns undef
and sets the valiable \f(CW$File::PathConvert::resolved\fR to the pathname
that caused the problem.
.Sp
All but the last component of the path must exist.
.Sp
This implementation is based on 4.4BSD \fIrealpath\fR\|(3).  It is not tested under
other operating systems at this time.
.Sp
If \*(L'/sys\*(R' is a symbolic link to \*(L'/usr/src/sys':
.Sp
.Vb 3
\&    chdir('/usr');
\&    '/usr/src/sys/kern' == realpath('../sys/kern');
\&    '/usr/src/sys/kern' == realpath('/sys/kern');
.Ve
.Ip "splitpath" 4
To be written...
.Ip "joinpath" 4
To be written...
.Sp
Note that \f(CWjoinpath( splitpath( $path ) )\fR usually yields path.  URLs
with directory components ending in \*(L'/.\*(R' or \*(L'/..\*(R' will be fixed 
up to end in \*(L'/./\*(R' and \*(L'/../\*(R'.
.Ip "splitdirs" 4
To be written...
.Ip "joindirs" 4
.SH "BUGS"
\f(CWrealpath\fR is not fully multiplatform.
.SH "LIMITATIONS"
.Ip "\(bu" 4
In URLs, paths not ending in \*(L'/\*(R' are split such that the last name in the
path is a filename.  This is not intuitive: many people use such URLs for
directories, and most servers send a redirect.  This may cause programers
using this package to code in bugs, it may be more pragmatic to always assume
all names are directory names.  (Note that the query portion is always part
of the filename).
.Ip "\(bu" 4
If the relative and base paths are on different volumes, no error is
returned.  A silent, hopefully reasonable assumption is made.
.Ip "\(bu" 4
No detection of unix style paths is done when other filesystems are
selected, like File::Basename does.
.SH "AUTHORS"
Barrie Slaymaker <rbs@telerama.com>
Shigio Yamaguchi <shigio@wafu.netgate.net>

.rn }` ''
.IX Title "PathConvert 3"
.IX Name "abs2rel - convert an absolute path to a relative path"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Item "setfstype"

.IX Item "abs2rel"

.IX Item "rel2abs"

.IX Item "realpath"

.IX Item "splitpath"

.IX Item "joinpath"

.IX Item "splitdirs"

.IX Item "joindirs"

.IX Header "BUGS"

.IX Header "LIMITATIONS"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Header "AUTHORS"

